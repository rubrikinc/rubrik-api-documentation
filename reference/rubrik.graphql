type Query {
  # List of Availability Zones (AZs) in the specified region on the specified AWS Native account.
  allAvailabilityZonesByRegionFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!): [String!]!

  # List of all AWS cloud account configurations with the given search query.
  allAwsCloudAccountConfigs(
    # Arguments for get cloud accounts configs.
    awsCloudAccountsArg: AwsCloudAccountConfigsInput!): [AwsFeatureConfig!]!

  # List of active AWS cloud accounts and the features for the accounts. A cloud account is an AWS account added to the Rubrik platform.
  allAwsCloudAccountsWithFeatures(
    # Arguments for get cloud accounts.
    awsCloudAccountsArg: AwsCloudAccountsWithFeaturesInput!): [AwsCloudAccountWithFeatures!]!

  # List of all AWS exocompute configurations filtered by a cloud account ID or a cloud account name prefix.
  allAwsExocomputeConfigs(
    # A query that searches for Exocompute configurations with an account name or account native ID that is prefixed by the search query.
    awsNativeAccountIdOrNamePrefix: String!): [AwsExocomputeConfig!]!

  # Retrieves a list of all the missing permissions on Azure subscriptions that are a part of the Azure Cloud Account.
  allAzureCloudAccountMissingPermissions(
    # Session ID of the current OAuth session.
    sessionId: String!,

    # List of Azure subscription IDs.
    subscriptionIds: [UUID!]!,

    # The cloud account action to be performed. Some examples are: isCreate, isUpdateRegions, isDelete.
    cloudAccountAction: CloudAccountAction!): [AzureSubscriptionMissingPermissions!]!

  # Retrieves all subnets in the specified region and subscription. Subnets allow you to choose IP address range of your choice. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/network-overview#virtual-network-and-subnets.
  allAzureCloudAccountSubnetsByRegion(
    # The Rubrik ID of the cloud account.
    cloudAccountId: UUID!,

    # Azure region.
    region: AzureCloudAccountRegion!): [AzureNativeSubnet!]!

  # Retrieves a list of all Azure Subscriptions with feature details such as feature, status, and regions.
  allAzureCloudAccountSubscriptionsByFeature(
    # Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides.
    feature: CloudAccountFeature!,

    # List of subscription status filters to apply.
    subscriptionStatusFilters: [CloudAccountStatus!]!): [AzureSubscriptionWithFeaturesType!]!

  # Retrieves a list of all the Azure tenants and tenant subscriptions for features. The list can be filtered by feature status, subscription native ID, and subscription name.
  allAzureCloudAccountTenants(
    # Cloud account features. A feature refers to the Polaris feature that Rubrik provides.
    features: [CloudAccountFeature!],

    # Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides.
    feature: CloudAccountFeature!,

    # Specifies whether the details about the subscriptions in the tenants are included in the response or not.
    includeSubscriptionDetails: Boolean!): [AzureCloudAccountTenant!]!

  # Retrieves a list of Azure Exocompute configurations filtered by a cloud account ID or a search query.
  allAzureExocomputeConfigsInAccount(
    # A query that searches for Exocompute configurations with an account name or account native ID that is prefixed by the search query.
    azureExocomputeSearchQuery: String,

    # IDs of cloud accounts.
    cloudAccountIDs: [UUID!]): [AzureExocomputeConfigsInAccount!]!

  # Retrieves all availability sets in the specified region, resource group, and subscription. An availability set is a logical grouping of VMs to facilitate redundancy and availability. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/availability-set-overview.
  allAzureNativeAvailabilitySetsByRegionFromAzure(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!,

    # Resource Group Name.
    resourceGroupName: String!,

    # The azure region.
    region: AzureNativeRegion!): [AzureNativeAvailabilitySet!]!

  # Retrieves all supported disk types when exporting a specific snapshot. Not all disk types are supported in all the regions. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types.
  allAzureNativeExportCompatibleDiskTypesByRegionFromAzure(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!,

    # The azure region.
    region: AzureNativeRegion!): [AzureNativeExportCompatibleDiskTypes!]!

  # Retrieves all supported virtual machine (VM) sizes when exporting a particular snapshot. Not all VM sizes are supported in all the regions. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes.
  allAzureNativeExportCompatibleVmSizesByRegionFromAzure(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!,

    # The azure region.
    region: AzureNativeRegion!,

    # Snapshot ID
    vmSnapshotId: UUID!): [AzureNativeExportCompatibleVmSizes!]!

  # Retrieves all security groups in the specified region and subscription. Security groups enable you to configure network security as a natural extension of an application's structure, allowing you to group virtual machines and define network security policies based on those groups. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/application-security-groups.
  allAzureNativeSecurityGroupsByRegionFromAzure(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!,

    # The azure region.
    region: AzureNativeRegion!): [AzureNativeSecurityGroup!]!

  # Retrieves list of all storage Accounts in a subscription.
  allAzureNativeStorageAccountsFromAzure(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!): [AzureNativeStorageAccount!]!

  # Retrieves all subnets in the specified region and subscription. Subnets allow you to choose IP address range of your choice. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/network-overview#virtual-network-and-subnets.
  allAzureNativeSubnetsByRegionFromAzure(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!,

    # The azure region.
    region: AzureNativeRegion!): [AzureNativeSubnet!]!

  # Retrieves all virtual machine (VM) sizes in the subscriptions protected by Rubrik that have been configured for protection. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes.
  allAzureNativeVirtualMachineSizes(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID): [String!]!

  # Retrieves all virtual networks (VNets) in the protected subscriptions. VNet enables secure communication with other VNets, the internet, and on-premise networks. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview.
  allAzureNativeVirtualNetworks(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID): [AzureNativeVirtualNetwork!]!

  # List of all DB parameter groups in a given region. Refers to container for engine configuration that applies to one or more DB Instances. For more information, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithOptionGroups.html.
  allDbParameterGroupsByRegionFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!,

    # DB Engine of RDS Instance.
    dbEngine: AwsNativeRdsDbEngine!,

    # Version of DB engine.
    dbEngineVersion: String!): [DbParameterGroup!]!

  # All DB subnet groups in a given region. Refers to logical isolation of RDS on a network. For more information, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html.
  allDbSubnetGroupsByRegionFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!): [SubnetGroup!]!

  # List of all key pairs for a given region. A key pair, consisting of a public key and a private key, is a set of security credentials that you use to prove your identity when connecting to an EC2 instance. For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html.
  allEc2KeyPairsByRegionFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!): [String!]!

  # List of encryption keys in the specified region on the specified AWS Native account. All the encrytion keys listed are managed by AWS Key Management System (KMS). For more information, see https://aws.amazon.com/kms/.
  allKmsEncryptionKeysByRegionFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!): [KmsEncryptionKey!]!

  # List of all RDS option groups in a given region. Refers to settings of how a particular option works for an RDS Instance. For more information, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithOptionGroups.html.
  allOptionGroupsByRegionFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!,

    # DB Engine of RDS Instance.
    dbEngine: AwsNativeRdsDbEngine!,

    # Version of DB engine.
    dbEngineVersion: String!,

    # Major version of the option group engine.
    majorEngineVersion: String!): [OptionGroup!]!

  # Retrieves a list og all resource groups in the specified account.
  allResourceGroupsFromAzure(
    # The Rubrik ID of the cloud account.
    cloudAccountId: UUID!,

    # The Native ID of the subscription.
    azureSubscriptionNativeId: UUID!,

    # Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides.
    feature: CloudAccountFeature!): [AzureResourceGroup!]!

  # List of all S3 bucket names across regions for the AWS Native account.
  allS3BucketsFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!): [String!]!

  # List of all Virtual Private Clouds (VPCs) in the AWS Native account, classified by region.
  allVpcsByRegionFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!): [AwsVpc!]!

  # List of all Virtual Private Clouds (VPCs) in the AWS Native account.
  allVpcsFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID): [AwsVpc!]!

  # Amazon Machine Image (AMI) type for export of an archived EC2 Instance snapshot. For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instances-and-amis.html.
  amiTypeForAwsNativeArchivedSnapshotExport(
    # Input for AmiTypeForAwsNativeArchivedSnapshotExport.
    input: AmiTypeForAwsNativeArchivedSnapshotExportInput!): AmiTypeForAwsNativeArchivedSnapshotExportReply!

  # List of AWS cloud accounts and the features for each account, classified by ID.
  awsCloudAccountWithFeatures(
    # The Rubrik ID of the cloud account.
    cloudAccountId: UUID!,

    # Arguments for get cloud account.
    awsCloudAccountArg: AwsCloudAccountWithFeaturesInput!): AwsCloudAccountWithFeatures!

  # Refers to the AWS Native account that serves as a container for all your AWS resources. The AWS Native account contains information about the metadata related to the AWS Native resources.
  awsNativeAccount(
    # The Rubrik ID for the AWS Native account.
    awsNativeAccountRubrikId: UUID!,

    # Cloud native protection feature.
    awsNativeProtectionFeature: AwsNativeProtectionFeature!): AwsNativeAccount!

  # Paginated list of all AWS Native accounts.
  awsNativeAccounts(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS accounts.
    sortBy: AwsNativeAccountSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, accountFilters: AwsNativeAccountFilters, authorizedOperationFilter: Operation,

    # Cloud native protection feature.
    awsNativeProtectionFeature: AwsNativeProtectionFeature!): AwsNativeAccountConnection!

  # Refers to the Amazon Elastic Block Store (EBS) Volume represented by a specific ID. For more information, see https://aws.amazon.com/ebs/.
  awsNativeEbsVolume(
    # Rubrik ID for the AWS EBS Volume object.
    ebsVolumeRubrikId: UUID!): AwsNativeEbsVolume!

  # Paginated list of all AWS EBS Volumes.
  awsNativeEbsVolumes(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS EBS volumes.
    sortBy: AwsNativeEbsVolumeSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, ebsVolumeFilters: AwsNativeEbsVolumeFilters): AwsNativeEbsVolumeConnection!

  # Paginated list of all AWS EBS Volumes by name or substring of name.
  awsNativeEbsVolumesByName(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS EBS volumes.
    sortBy: AwsNativeEbsVolumeSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder,

    # The native name for the AWS EBS Volume object.
    ebsVolumeName: String!): AwsNativeEbsVolumeConnection!

  # Refers to Amazon Elastic Compute Cloud (EC2) Instance represented by a specific ID. For more information, see https://aws.amazon.com/ec2/.
  awsNativeEc2Instance(
    # Rubrik ID for the AWS EC2 Instance.
    ec2InstanceRubrikId: UUID!): AwsNativeEc2Instance!

  # Paginated list of all AWS EC2 Instances.
  awsNativeEc2Instances(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS EC2 instances.
    sortBy: AwsNativeEc2InstanceSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder,

    # Filter the CDM cloud hosts by workload type.
    descendantTypeFilter: [HierarchyObjectTypeEnum!], ec2InstanceFilters: AwsNativeEc2InstanceFilters): AwsNativeEc2InstanceConnection!

  # Paginated list of all AWS EC2 Instances by name or substring of name.
  awsNativeEc2InstancesByName(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS EC2 instances.
    sortBy: AwsNativeEc2InstanceSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder,

    # Native name for the AWS EC2 Instance object.
    ec2InstanceName: String!): AwsNativeEc2InstanceConnection!

  # Refers to the default values for the export operation of the RDS DB Instance in the AWS Native account.
  awsNativeRdsExportDefaults(
    # The Rubrik ID for the AWS RDS Instance.
    rdsInstanceRubrikId: UUID!,

    # ID of the snapshot if the export is manual.
    snapshotId: String,

    # Specifies whether the export of the instance is manual or Point-in-Time.
    isPointInTime: Boolean!): RdsInstanceExportDefaults!

  # Refers to AWS Relational Database Service (RDS) represented by a specific ID. For more information, see https://aws.amazon.com/rds/.
  awsNativeRdsInstance(
    # The Rubrik ID for the AWS RDS Instance.
    rdsInstanceRubrikId: UUID!): AwsNativeRdsInstance!

  # Paginated list of AWS RDS Instances on AWS Native account.
  awsNativeRdsInstances(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS RDS instances.
    sortBy: AwsNativeRdsInstanceSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, rdsInstanceFilters: AwsNativeRdsInstanceFilters): AwsNativeRdsInstanceConnection!

  # Point-in-Time (PiT) restore window of the RDS Instance in the AWS Native account. Refers to the range of time within which the database is available to be restored to a particular point in time. For more information,see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIT.html.
  awsNativeRdsPointInTimeRestoreWindow(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!,

    # Name of the RDS DB Instance
    rdsInstanceName: String!): AwsNativeRdsPointInTimeRestoreWindow!

  # Retrieves the configuration consisting of role permissions and feature policy version required for Azure subscription setup. Features refer to the Polaris features that the customer wants to be enabled on the cloud account.
  azureCloudAccountPermissionConfig(
    # Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides.
    feature: CloudAccountFeature!): AzureCloudAccountPermissionConfigResponse!

  # Retrieves the details of the Azure tenant and all the subscriptions of the tenant, for a feature.
  azureCloudAccountTenant(
    # Tenant ID of the Azure tenant.
    tenantId: UUID!,

    # Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides.
    feature: CloudAccountFeature!,

    # List of subscription status filters to apply.
    subscriptionStatusFilters: [CloudAccountStatus!]!,

    # Search text for subscription name and native ID.
    subscriptionSearchText: String!,

    # List of subscription IDs to filter on.
    subscriptionIdsFilter: [UUID!]): AzureCloudAccountTenant!

  # Retrieves details about the Azure cloud account tenant including the Exocompute configurations for the tenant subscriptions, for a specified feature.
  azureCloudAccountTenantWithExoConfigs(
    # Tenant ID of the Azure tenant.
    tenantId: UUID!,

    # Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides.
    feature: CloudAccountFeature!,

    # List of subscription status filters to apply.
    subscriptionStatusFilters: [CloudAccountStatus!]!,

    # Search text for subscription name and native ID.
    subscriptionSearchText: String!,

    # List of subscription IDs to filter on.
    subscriptionIdsFilter: [UUID!]): AzureCloudAccountTenantWithExoConfigs!

  # Retrieves an Azure Native Managed Disk that refers to the block storage designed to be used with Azure Virtual Machines. Some examples are: ultra disks, premium solid-state drives (SSD), standard SSDs, and standard hard disk drives (HDD). For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/managed-disks-overview.
  azureNativeManagedDisk(
    # Rubrik ID of the Azure Managed Disk.
    azureManagedDiskRubrikId: UUID!): AzureNativeManagedDisk!

  # Retrieves a paginated list of all Azure Native Managed Disks.
  azureNativeManagedDisks(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of Azure disks.
    sortBy: AzureNativeDiskSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, diskFilters: AzureNativeDiskFilters): AzureNativeManagedDiskConnection!

  # Retrieves an Azure Native Resource Group. Refers to a collection of resources in which multiple Azure services can reside.
  azureNativeResourceGroup(
    # Resource Group ID of Virtual Machine (VM) or Disk.
    resourceGroupId: UUID!): AzureNativeResourceGroup!

  # Retrieves a paginated list of all Azure Native Resource Groups.
  azureNativeResourceGroups(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for listing Azure resource groups.
    sortBy: AzureNativeCommonResourceGroupSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder,

    # Filters for listing Azure resource groups
    commonResourceGroupFilters: AzureNativeCommonResourceGroupFilters,

    # List of protected object types.
    protectedObjectTypes: [SnappableLevelHierarchyTypeEnum!],

    # The type of Azure Native features that Polaris supports.
    azureNativeProtectionFeatures: [AzureNativeProtectionFeature!]): AzureNativeResourceGroupConnection!

  # Retrieves an Azure Native Subscription. Refers to the logical entity that provides entitlement to deploy and consume Azure resources.
  azureNativeSubscription(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!): AzureNativeSubscription!

  # Retrieves a paginated list of all Azure Native Subscriptions.
  azureNativeSubscriptions(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of Azure subscriptions.
    sortBy: AzureNativeSubscriptionSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, subscriptionFilters: AzureNativeSubscriptionFilters,

    # Filters according to the operation given.
    authorizedOperationFilter: Operation,

    # Snappable hierarchy.
    snappableHierarchy: SnappableLevelHierarchyTypeEnum,

    # The type of Azure Native feature that Polaris supports.
    azureNativeProtectionFeature: AzureNativeProtectionFeature): AzureNativeSubscriptionConnection!

  # Retrieves an Azure Virtual Machine that refers to the Azure infrastructure as a service (IaaS) used to deploy persistent VMs. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/.
  azureNativeVirtualMachine(
    # Rubrik ID of the Azure Virtual Machine.
    azureVirtualMachineRubrikId: UUID!): AzureNativeVirtualMachine!

  # Retrieves a paginated list of all Azure Virtual Machines (VMs).
  azureNativeVirtualMachines(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of Azure virtual machines.
    sortBy: AzureNativeVirtualMachineSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder,

    # Filter the CDM cloud hosts by workload type.
    descendantTypeFilter: [HierarchyObjectTypeEnum!], virtualMachineFilters: AzureNativeVirtualMachineFilters): AzureNativeVirtualMachineConnection!

  # Checks if a resource group with the specified name exists in the specified account.
  doesAzureNativeResourceGroupExist(
    # The Rubrik ID of the cloud account.
    cloudAccountId: UUID!,

    # The Native ID of the subscription.
    azureSubscriptionNativeId: UUID!,

    # The name of the resource group.
    resourceGroupName: String!,

    # Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides.
    feature: CloudAccountFeature!): Boolean!

  # Specified whether an EBS volume is restorable. For an EBS Volume to be restorable, the volume should be able to replace where attached.
  isAwsNativeEbsVolumeSnapshotRestorable(
    # UUID of the snapshot
    snapshotId: String!): IsVolumeSnapshotRestorableReply!

  # Specifies whether the given DbInstance class, storage type, multi-az capability, encryption capability, iops value are supported for the given dbEngine, dbEngineVersion in the specified availability zone. When true, the specification is valid for a RDS Instance and can be used to create a new Instance.
  isAwsNativeRdsInstanceLaunchConfigurationValid(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!,

    # DB Engine of RDS Instance.
    dbEngine: AwsNativeRdsDbEngine!,

    # Version of DB engine.
    dbEngineVersion: String!,

    # DB class of the exported RDS DB instance.
    dbClass: AwsNativeRdsDbInstanceClass!,

    # AZ in which the exported RDS DB instance must be launched.
    primaryAz: String,

    # Storage type of the exported RDS DB instance.
    storageType: AwsNativeRdsStorageType,

    # Whether the exported RDS DB instance is multi-AZ or not.
    isMultiAz: Boolean!,

    # KMS Key ID of the exported RDS DB instance.
    kmsKeyId: String,

    # IOPs of the exported RDS DB instance.
    iops: Int): Boolean!

  # Specifies whether an S3 bucket name is available for use in AWS or not. When true, the bucket name is available for use.
  isAwsS3BucketNameAvailable(
    # Name of the S3 bucket.
    bucketName: String!,

    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!): Boolean!

  # Specifies whether the Managed Disk snapshot is restorable or not. A managed disk is restorable when the restore settings of the Managed Disk are configured on the Azure portal and on the Rubrik platform. When the value is true, the managed disk snapshot is restorable.
  isAzureNativeManagedDiskSnapshotRestorable(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!,

    # Snapshot ID
    diskSnapshotId: UUID!): Boolean!

  # Specifies whether the given storage account name is valid and available in Azure to be assigned to a new storage account. When the value is true, the specified account name is available in Azure.
  isAzureStorageAccountNameAvailable(
    # Rubrik ID of the Azure Subscription.
    azureSubscriptionRubrikId: UUID!,

    # A unique name for the storage account. Storage account names must be between 3 and 24 characters in length and may contain numbers and lowercase letters only.
    storageAccountName: String!): Boolean!

  # Details of the RDS Instance in the AWS Native account.
  rdsInstanceDetailsFromAws(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!,

    # Name of the RDS DB Instance
    rdsInstanceName: String!): RdsInstanceDetailsFromAws!

  # Validates the name used for an RDS Instance during an export operation. Returns true if the RDS Instance name is valid. Returns false, with an error message, if the RDS Instance name validation fails. Returns false, without an error message for all other failures.
  validateAwsNativeRdsInstanceNameForExport(
    # Rubrik ID for AWS account.
    awsAccountRubrikId: UUID!,

    # Region in AWS.
    region: AwsNativeRegion!,

    # Name of the RDS DB Instance
    rdsInstanceName: String!): ValidateAwsNativeRdsInstanceNameForExportReply!

  # Validates if Azure subnets are correctly configured for running Azure Kubernetes Service (AKS) Clusters. When correctly configured, the Azure subnets allow the required region-specific outbound connectivity and do not overlap with Azure restricted IP Address Space.
  validateAzureCloudAccountExocomputeConfigurations(
    # Input for validating Exocompute configurations for an Azure Cloud Account.
    input: ValidateAzureCloudAccountExocomputeConfigurationsInput!): ValidateAzureSubnetsForCloudAccountExocomputeReply!
}
type Mutation {
  # Add the Azure Subscriptions cloud account for the given feature.
  addAzureCloudAccount(
    # Input for adding an Azure Cloud Account.
    input: AddAzureCloudAccountInput!): AddAzureCloudAccountReply!

  # Add Exocompute configurations for an Azure Cloud Account.
  addAzureCloudAccountExocomputeConfigurations(
    # Input for adding Exocompute configurations for an Azure Cloud Account.
    input: AddAzureCloudAccountExocomputeConfigurationsInput!): AddAzureCloudAccountExocomputeConfigurationsReply!

  # Add the Azure Subscription cloud account for the given feature without OAuth.
  addAzureCloudAccountWithoutOauth(
    # Input for adding an Azure Cloud Account without OAuth.
    input: AddAzureCloudAccountWithoutOauthInput!): AddAzureCloudAccountWithoutOauthReply!

  # Complete the Azure OAuth flow and pass the authorization code.
  completeAzureCloudAccountOauth(
    # Input for completing authentication of the Azure Cloud Accounts.
    input: CompleteAzureCloudAccountOauthInput!): CompleteAzureCloudAccountOauthReply!

  # Create AWS Exocompute configs.
  createAwsExocomputeConfigs(
    # Input to create AWS exocompute configurations.
    input: CreateAwsExocomputeConfigsInput!): CreateAwsExocomputeConfigsReply!

  # Deletes AWS Exocompute configs.
  deleteAwsExocomputeConfigs(
    # List of AWS exocompute configuration IDs.
    input: DeleteAwsExocomputeConfigsInput!): DeleteAwsExocomputeConfigsReply!

  # Delete the Azure Subscriptions cloud account for the given feature.
  deleteAzureCloudAccount(
    # Input for deleting an Azure Cloud Account.
    input: DeleteAzureCloudAccountInput!): DeleteAzureCloudAccountReply!

  # Delete Exocompute configurations for an Azure Cloud Account.
  deleteAzureCloudAccountExocomputeConfigurations(
    # Input for adding Exocompute configurations for an Azure Cloud Account.
    input: DeleteAzureCloudAccountExocomputeConfigurationsInput!): DeleteAzureCloudAccountExocomputeConfigurationsReply!

  # Delete the Azure Subscriptions cloud account for the given feature without OAuth.
  deleteAzureCloudAccountWithoutOauth(
    # Input for deleting an Azure Cloud Account without OAuth.
    input: DeleteAzureCloudAccountWithoutOauthInput!): DeleteAzureCloudAccountWithoutOauthReply!

  # Mark AWS Native EBS Volumes to be excluded from EC2 Instance snapshot. By default, all EBS Volumes are marked as included.
  excludeAwsNativeEbsVolumesFromSnapshot(
    # Input to mark EBS volumes to be excluded for EC2 snapshot.
    input: ExcludeAwsNativeEbsVolumesFromSnapshotInput!): Void

  # Exclude the Managed Disks from snapshots, for the specified virtual machines.
  excludeAzureNativeManagedDisksFromSnapshot(
    # Input for excluding Azure Native Managed Disks from Snapshot.
    input: ExcludeAzureNativeManagedDisksFromSnapshotInput!): Void

  # Process and finalize deletion of cloud account is the last step in deletion of a feature from cloud account. This endpoint is a MUST for deletion of disconnected features.
  finalizeAwsCloudAccountDeletion(
    # Arguments to process AWS cloud accounts for deletion.
    input: FinalizeAwsCloudAccountDeletionInput!): FinalizeAwsCloudAccountDeletionReply!

  # Process cloud account. This is the second step after validate and create in addition of a feature for cloud account.The CloudFormation stack should be created after this step using the CloudFormation URL provided in the first step.
  finalizeAwsCloudAccountProtection(
    # Arguments for process cloud accounts.
    input: FinalizeAwsCloudAccountProtectionInput!): FinalizeAwsCloudAccountProtectionReply!

  # Prepare deletion of cloud account. This is the first step to delete AWS cloud account. It generated template for deletion of cloud account and does not change any state of account.
  prepareAwsCloudAccountDeletion(
    # Args for initiate aws cloud accounts for deletion.
    input: PrepareAwsCloudAccountDeletionInput!): PrepareAwsCloudAccountDeletionReply!

  # Prepare manual update features to latest version.
  prepareFeatureUpdateForAwsCloudAccount(
    # Input to prepare feature update for AWS cloud account.
    input: PrepareFeatureUpdateForAwsCloudAccountInput!): PrepareFeatureUpdateForAwsCloudAccountReply!

  # Set credentials for the customer application, for the tenant domain name.
  setAzureCloudAccountCustomerAppCredentials(
    # Input for setting the app credentials in the Azure Cloud Accounts.
    input: SetAzureCloudAccountCustomerAppCredentialsInput!): Boolean!

  # Starts a job to disable AWS Exocompute feature. When complete, the job will disable exocompute feature for the specified AWS Native account.
  startAwsExocomputeDisableJob(
    # Input required to start the job to disable AWS Exocompute.
    input: StartAwsExocomputeDisableJobInput!): AsyncJobStatus!

  # Starts a job to disable a specific AWS Native account. When complete, the job will disable protection for the specified AWS Native account.
  startAwsNativeAccountDisableJob(
    # Input for AWS native account disable job.
    input: StartAwsNativeAccountDisableJobInput!): AsyncJobStatus!

  # Start an on demand create snapshot job for AWS EC2 Instances.When completed, this will start taking an on-demand snapshot of the selected EC2 Instances  as per the SLA Policy assigned to the respective instances.
  startAwsNativeEc2InstanceSnapshotsJob(
    # Input for create AWS EC2 Instance snapshots job.
    input: StartAwsNativeEc2InstanceSnapshotsJobInput!): BatchAsyncJobStatus!

  # Start job to create snapshots of RDS Instance with given IDs. When completed, this will start taking an on-demand snapshot of the selected RDS Instances  as per the SLA Policy assigned to the respective instances.
  startAwsNativeRdsInstanceSnapshotsJob(
    # Input to trigger job to create AWS RDS Instance snapshots.
    input: StartAwsNativeRdsInstanceSnapshotsJobInput!): BatchAsyncJobStatus!

  # Initiates a session before doing Azure OAuth flow. If a custom app is configured for the tenant, the client ID of the custom app is returned. Otherwise, the client ID of the default app is returned.
  startAzureCloudAccountOauth(
    # Input for initiating authentication of the Azure Cloud Accounts.
    input: StartAzureCloudAccountOauthInput!): StartAzureCloudAccountOauthReply!

  # Start job to create snapshots of EBS Volumes with given IDs. When completed, this will start taking an on-demand snapshot of the selected EBS Volumes  as per the SLA Policy assigned to the respective volumes.
  startCreateAwsNativeEbsVolumeSnapshotsJob(
    # Input for create AWS EBS volume create snapshots job.
    input: StartCreateAwsNativeEbsVolumeSnapshotsJobInput!): BatchAsyncJobStatus!

  # Start a job to create snapshots of the Azure Native Managed Disks identified by the given IDs. When started, this will start taking an on-demand snapshot of the selected disks as per the SLA Policy assigned to the respective disks.
  startCreateAzureNativeManagedDiskSnapshotsJob(
    # Input for the job to create Azure Native Managed Disk Snapshots.
    input: StartCreateAzureNativeManagedDiskSnapshotsJobInput!): BatchAsyncJobStatus!

  # Start a job to create a snapshot for the Azure Native virtual machine identified by the IDs. When started, this will start taking an on-demand snapshot of the selected VMs as per the SLA Policy assigned to the respective VMs.
  startCreateAzureNativeVirtualMachineSnapshotsJob(
    # Input for the job to create Azure Native Virtual Machine snapshots.
    input: StartCreateAzureNativeVirtualMachineSnapshotsJobInput!): BatchAsyncJobStatus!

  # Start a job to disable protection for a specified Azure subscription.
  startDisableAzureNativeSubscriptionProtectionJob(
    # Input for the job to start disabling protection from the Azure Native Subscription.
    input: StartDisableAzureNativeSubscriptionProtectionJobInput!): AsyncJobStatus!

  # Starts a job to export an EC2 Instance snapshot. The job creates a new EC2 Instance with the same properties as that of the snapshot that is exported.
  startEc2InstanceSnapshotExportJob(
    # Input to trigger export AWS native EC2 Instance snapshot job.
    input: StartEc2InstanceSnapshotExportJobInput!): AsyncJobStatus!

  # Start a job to export EBS Volume. The job creates a new EBS Volume with the same properties as that of the snapshot that is exported.
  startExportAwsNativeEbsVolumeSnapshotJob(
    # Input to trigger export AWS native EBS volume snapshot job.
    input: StartExportAwsNativeEbsVolumeSnapshotJobInput!): AsyncJobStatus!

  # Start a job to export the specified Azure Native Managed Disks to the desired destination.
  startExportAzureNativeManagedDiskJob(
    # Input for the job to export the specified Azure Native Managed Disk to the specified destination.
    input: StartExportAzureNativeManagedDiskJobInput!): AsyncJobStatus!

  # Start a job to export the Azure native virtual machine for a specified snapshot to a specified destination.
  startExportAzureNativeVirtualMachineJob(
    # Input for the job to export the specified Azure Native Virtual Machine to the specified destination.
    input: StartExportAzureNativeVirtualMachineJobInput!): AsyncJobStatus!

  # Start a job to export RDS Instance. The job creates a new RDS Instance with the same properties as that of the instance that is exported.
  startExportRdsInstanceJob(
    # Input to trigger export AWS native RDS Instance job.
    input: StartExportRdsInstanceJobInput!): AsyncJobStatus!

  # Start an on demand job to refresh AWS accounts. The job updates the Rubrik platform with changes to the AWS Native accounts.
  startRefreshAwsNativeAccountsJob(
    # Input for refresh AWS native accounts job.
    input: StartRefreshAwsNativeAccountsJobInput!): BatchAsyncJobStatus!

  # Start a job to refresh Azure Native subscription for the given subscription IDs. When started, this job will update the Rubrik platform with any changes that have been done on Azure for the respective subscription.
  startRefreshAzureNativeSubscriptionsJob(
    # Input for the job to refresh Azure Native subscriptions.
    input: StartRefreshAzureNativeSubscriptionsJobInput!): BatchAsyncJobStatus!

  # Start an on demand restore snapshot job for AWS EC2 Instance. When completed, this will replace the original EC2 Instance with the selected snapshot.
  startRestoreAwsNativeEc2InstanceSnapshotJob(
    # Input for restore AWS EC2 Instance snapshot job.
    input: StartRestoreAwsNativeEc2InstanceSnapshotJobInput!): AsyncJobStatus!

  # Start a job to restore Azure Native virtual machine with the selected snapshot. When started, this will replace the original VM with the selected snapshot.
  startRestoreAzureNativeVirtualMachineJob(
    # Input for the job to restore Azure Native Virtual Machine.
    input: StartRestoreAzureNativeVirtualMachineJobInput!): AsyncJobStatus!

  # Initiates on-demand Exocompute health check.
  triggerExocomputeHealthCheck(
    # Input to initiate Exocompute health check.
    input: TriggerExocomputeHealthCheckInput!): TriggerExocomputeHealthCheckReply!

  # Update properties for a given AWS cloud account.
  updateAwsCloudAccount(
    # Arguments to update properties of AWS cloud account.
    input: UpdateAwsCloudAccountInput!): Void

  # Updates regions, stack ARN, and role ARN for a feature for a given cloud account.
  updateAwsCloudAccountFeature(
    # Arguments to update AWS cloud account feature.
    input: UpdateAwsCloudAccountFeatureInput!): UpdateAwsCloudAccountFeatureReply!

  # Update names of the Azure Subscriptions cloud account and regions for the given feature.
  updateAzureCloudAccount(
    # Input for updating an Azure Cloud Account.
    input: UpdateAzureCloudAccountInput!): UpdateAzureCloudAccountReply!

  # Update permissions of the Azure Subscriptions cloud account for given feature.
  upgradeAzureCloudAccount(
    # Input for upgrading an Azure Cloud Account.
    input: UpgradeAzureCloudAccountInput!): UpgradeAzureCloudAccountReply!

  # Set Azure Cloud Account feature status to Connected from Update Permissions state without any permission validation. It should be used by caution from cloud accounts which have been set up without using OAuth, only after adding the latest permissions that are required.
  upgradeAzureCloudAccountPermissionsWithoutOauth(
    # Input to set status of azure cloud account to connected from update permissions state without OAuth.
    input: UpgradeAzureCloudAccountPermissionsWithoutOauthInput!): UpgradeAzureCloudAccountPermissionsWithoutOauthReply!

  # Validate and create AWS cloud account. If validation fails, no error is returned and the cause is present in the \"message\" field of return object or within admin/child accounts of return object. In case validation succeeds, it initiates creation of AWS cloud account. This is the first step to set up native protection.
  validateAndCreateAwsCloudAccount(
    # Input to validate AWS cloud account arguments.
    input: ValidateAndCreateAwsCloudAccountInput!): ValidateAndCreateAwsCloudAccountReply!
}
type Activity {
  time: DateTime!
  type: ActivityTypeEnum!
  status: ActivityStatusEnum!
  severity: ActivitySeverityEnum!
  message: String!
  objectId: String!
  objectType: ActivityObjectTypeEnum!
  clusterId: UUID!
  progress: String
  activityInfo: String
  id: ID!
  activitySeries: ActivitySeries!
}
# Paginated list of Activity objects.
type ActivityConnection {
  # List of Activity objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [ActivityEdge!]!

  # List of Activity objects.
  nodes: [Activity!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of Activity objects matching the request arguments.
  count: Int!
}
# Wrapper around the Activity object. This wrapper is used for pagination.
type ActivityEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual Activity object wrapped by this edge.
  node: Activity!
}
enum ActivityObjectTypeEnum {
  AppBlueprint
  AppFlows
  AuthDomain
  AwsAccount
  AwsEventType
  AwsNativeAccount
  AwsNativeEbsVolume
  AwsNativeEc2Instance
  AwsNativeRdsInstance
  AzureNativeDisk
  AzureNativeSubscription
  AzureNativeVm
  AzureSqlDatabase
  AzureSqlDatabaseServer
  AzureSqlManagedInstance
  AzureSqlManagedInstanceDatabase
  CASSANDRA_COLUMN_FAMILY
  CASSANDRA_KEYSPACE
  CASSANDRA_SOURCE
  CapacityBundle
  Certificate
  CloudNativeVirtualMachine
  CloudNativeVm
  Cluster
  ComputeInstance
  DataLocation
  Db2Database
  Db2Instance
  Ec2Instance
  Envoy
  ExchangeDatabase
  Exocompute
  FailoverClusterApp
  GcpNativeDisk
  GcpNativeGceInstance
  GcpNativeProject
  Hdfs
  Host
  HypervScvmm
  HypervServer
  HypervVm
  JobInstance
  KuprCluster
  KuprNamespace
  Ldap
  LinuxFileset
  LinuxHost
  MONGODB_COLLECTION
  MONGODB_DATABASE
  MONGODB_SOURCE
  ManagedVolume
  Mssql
  NAS_FILESET
  NasHost
  NasSystem
  NutanixCluster
  NutanixVm
  O365Calendar
  O365Group
  O365Mailbox
  O365Onedrive
  O365Organization
  O365SharePointDrive
  O365SharePointList
  O365Site
  O365Team
  ObjectProtection
  Oracle
  OracleDb
  OracleHost
  OracleRac
  PolarisAccount
  PolarisEbsVolume
  PolarisEc2Instance
  PublicCloudMachineInstance
  SamlSso
  SapHanaDb
  SapHanaSystem
  ShareFileset
  SlaDomain
  SmbDomain
  SnapMirrorCloud
  StorageArray
  StorageArrayVolumeGroup
  StorageLocation
  Storm
  SupportBundle
  UnknownObjectType
  Upgrade
  User
  Vcd
  VcdVapp
  Vcenter
  VmwareComputeCluster
  VmwareVm
  VolumeGroup
  WEBHOOK
  WindowsFileset
  WindowsHost
}
type ActivitySeries {
  id: Long!
  startTime: DateTime
  lastUpdated: DateTime!
  lastActivityType: ActivityTypeEnum!
  lastActivityStatus: ActivityStatusEnum!
  severity: ActivitySeverityEnum!
  objectId: String!
  objectName: String
  objectType: ActivityObjectTypeEnum!
  activitySeriesId: UUID!
  clusterUuid: UUID!
  clusterName: String!
  lastEventAddedAt: DateTime
  lastVerifiedAt: DateTime
  isCancelable: Boolean
  location: String!
  isPolarisEventSeries: Boolean!
  fid: UUID
  progress: String
  failureReason: String
  causeErrorMessage: String
  causeErrorCode: String
  causeErrorReason: String
  causeErrorRemedy: String
  cluster: Cluster
  activityConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String): ActivityConnection!
}
# Paginated list of ActivitySeries objects.
type ActivitySeriesConnection {
  # List of ActivitySeries objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [ActivitySeriesEdge!]!

  # List of ActivitySeries objects.
  nodes: [ActivitySeries!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of ActivitySeries objects matching the request arguments.
  count: Int!
}
# Wrapper around the ActivitySeries object. This wrapper is used for pagination.
type ActivitySeriesEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual ActivitySeries object wrapped by this edge.
  node: ActivitySeries!
}
# Filter event series data.
input ActivitySeriesFilterInput {
  # Status of the last event in the event series.
  lastActivityStatus: [ActivityStatusEnum!]

  # Type of the last event in the event series.
  lastActivityType: [ActivityTypeEnum!]

  # Severity of the event series.
  severity: [ActivitySeverityEnum!]

  # Name of the object.
  objectName: String

  # Object type.
  objectType: [ActivityObjectTypeEnum!]

  # Start time greater than.
  startTimeGt: DateTime

  # Start time less than.
  startTimeLt: DateTime

  # Last updated time greater than.
  lastUpdatedGt: DateTime

  # Last updated time less than.
  lastUpdatedLt: DateTime

  # Cluster ID and type.
  cluster: CommonClusterFilterInput

  # Forever IDs of objects.
  objectFids: [UUID!]

  # Ancestor ID of the object.
  ancestorId: UUID

  # Text to search event content.
  searchTerm: String
}
enum ActivitySeriesSortByEnum {
  ActivityStatus
  ActivityType
  ClusterName
  LastUpdated
  Location
  ObjectName
  ObjectType
  Severity
  StartTime
}
enum ActivitySeverityEnum {
  Critical
  Info
  Warning
}
enum ActivityStatusEnum {
  Canceled
  Canceling
  Failure
  Info
  Queued
  Running
  Success
  TaskFailure
  TaskSuccess
  Warning
}
enum ActivityTypeEnum {
  Anomaly
  Archive
  AuthDomain
  AwsEvent
  Backup
  Classification
  CloudNativeSource
  CloudNativeVirtualMachine
  CloudNativeVm
  Configuration
  Connection
  Conversion
  Diagnostic
  Discovery
  Download
  EmbeddedEvent
  Failover
  Fileset
  Hardware
  Hdfs
  HostEvent
  HypervScvmm
  HypervServer
  Index
  Instantiate
  LegalHold
  LocalRecovery
  LockSnapshot
  Maintenance
  NutanixCluster
  RadarAnalysis
  Recovery
  Replication
  ResourceOperations
  Storage
  StorageArray
  StormResource
  Support
  Sync
  System
  TestFailover
  ThreatHunt
  Tpr
  UnknownEventType
  Upgrade
  VCenter
  Vcd
  VolumeGroup
}
# Input for adding Exocompute configurations for an Azure Cloud Account.
input AddAzureCloudAccountExocomputeConfigurationsInput {
  # Rubrik ID of the Azure Cloud Account.
  cloudAccountId: UUID!

  # List of Exocompute configurations to be added.
  azureExocomputeRegionConfigs: [AzureExocomputeAddConfigInputType!]!

  # Specifies whether to start Exocompute health check.
  triggerHealthCheck: Boolean = false
}
# Response of the operation to add Exocompute Configurations to Azure Cloud Account.
type AddAzureCloudAccountExocomputeConfigurationsReply {
  # Configuration details of the Exocompute for the Azure Cloud Account.
  configs: [AzureExocomputeConfigDetails!]!
}
# Input for enabling a feature for an Azure cloud account.
input AddAzureCloudAccountFeatureInput {
  # Resource group to be used for creating all the resources for the feature. It is required only for the Cloud Native Archival feature. It will be ignored for other features.
  resourceGroup: AddAzureCloudAccountResourceGroupInput

  # Feature to be enabled.
  featureType: CloudAccountFeature!
}
# Input for enabling a feature for an Azure cloud account without oauth.
input AddAzureCloudAccountFeatureInputWithoutOauth {
  # Version of the Azure role policy.
  policyVersion: Int!

  # Resource group to be used for creating all the resources for the feature. Resource group is required only for the Cloud Native Archival/Archival-Encryption features. It will be ignored for other features.
  resourceGroup: AddAzureCloudAccountResourceGroupInput

  # Specific feature input to be used for enabling the feature. It is required only for the Cloud Native Archival Encryption feature. It will be ignored for other features.
  specificFeatureInput: AddAzureCloudAccountSpecificFeatureInput

  # Feature to be enabled.
  featureType: CloudAccountFeature!
}
# Input for adding an Azure Cloud Account.
input AddAzureCloudAccountInput {
  # Session ID of the current OAuth session.
  sessionId: String!

  # Domain name of the Azure Tenant.
  tenantDomainName: String!

  # Subscriptions to be added to the Azure Cloud Account.
  subscriptions: [AddAzureCloudAccountSubscriptionInput!]!

  # Regions to be added to the Azure Cloud Account.
  regions: [AzureCloudAccountRegion!]!
}
# Response of the operation to add an Azure Cloud Account.
type AddAzureCloudAccountReply {
  # Status of the operation to add Azure Cloud Account.
  status: [AddAzureCloudAccountStatus!]!

  # Tenant ID for the added subscriptions.
  tenantId: String!
}
# Input for the resource group to be used for the feature being enabled.
input AddAzureCloudAccountResourceGroupInput {
  # The name of the resource group.
  name: String!

  # The tags to be added on the resource group. If not passed, no tags will be added on the resource group.
  tags: TagsInput

  # The region name of the resource group.
  region: AzureCloudAccountRegion!
}
# Input for specific feature details to be used for the feature being enabled.
input AddAzureCloudAccountSpecificFeatureInput {
  # Details of the user-assigned managed identity.
  userAssignedManagedIdentityInput: AddAzureCloudAccountUserAssignedManagedIdentityInput!
}
# Status of the operation to add Azure Cloud Account.
type AddAzureCloudAccountStatus {
  # Native ID of the Azure Subscription.
  azureSubscriptionNativeId: String!

  # Rubrik ID of the Azure Subscription.
  azureSubscriptionRubrikId: String!

  # Error encountered, if any.
  error: String!
}
# Input for adding a subscription.
input AddAzureCloudAccountSubscriptionInput {
  # Features to be enabled for the Azure Cloud Account.
  features: [AddAzureCloudAccountFeatureInput!]!

  # Subscription to be added to the Azure Cloud Account.
  subscription: AzureSubscriptionInput!
}
# Input for adding a subscription without oauth.
input AddAzureCloudAccountSubscriptionInputWithoutOauth {
  # Features to be enabled for the Azure Cloud Account.
  features: [AddAzureCloudAccountFeatureInputWithoutOauth!]!

  # Subscription to be added to the Azure Cloud Account.
  subscription: AzureSubscriptionInput!
}
# Input to specify the details of the user-assigned managed identity to be used for CLOUD_NATIVE_ARCHIVAL_ENCRYPTION feature.
input AddAzureCloudAccountUserAssignedManagedIdentityInput {
  # The name of the managed identity.
  name: String!

  # The name of the resource group of the managed identity.
  resourceGroupName: String!

  # The ID of the service principal object associated with the managed identity.
  principalId: String!

  # The region of the managed identity.
  region: AzureCloudAccountRegion!
}
# Input for adding an Azure Cloud Account without OAuth.
input AddAzureCloudAccountWithoutOauthInput {
  # Domain Name of the Azure tenant.
  tenantDomainName: String!

  # Subscriptions to be added to the Azure Cloud Account.
  subscriptions: [AddAzureCloudAccountSubscriptionInputWithoutOauth!]!

  # Regions to be added to the Azure Cloud Account.
  regions: [AzureCloudAccountRegion!]!

  # Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud.
  azureCloudType: AzureCloudType = AZUREPUBLICCLOUD
}
# Response of the operation to add Azure Cloud Account without OAuth.
type AddAzureCloudAccountWithoutOauthReply {
  # Tenant ID for the added subscriptions.
  tenantId: String!

  # Status of the operation to add Azure Cloud Account.
  status: [AddAzureCloudAccountStatus!]!
}
# AMIType to be used for exporting an archived EC2 instance snapshot.
enum AmiType {
  # EC2 instance is a linux instance wihtout marketplace code. AMI will be created at runtime.
  CREATED_AT_RUNTIME

  # An AMI already exists which can be used for export.
  EXISTING

  # User needs to provide an AMI id, which will be used for export.
  USER_SPECIFIED
}
# Input to fetch Amazon Machine Image (AMI) type for AWS Archived snapshot export.
input AmiTypeForAwsNativeArchivedSnapshotExportInput {
  # ID of snapshot to export. Snapshot should have an archived copy present.
  snapshotId: UUID!

  # Target region for export.
  destinationRegionId: AwsNativeRegion!

  # Rubrik ID of the target AWS account for export.
  destinationAwsAccountRubrikId: UUID!
}
# Amazon Machine Image (AMI) type for exporting an archived EC2 Instance snapshot.
type AmiTypeForAwsNativeArchivedSnapshotExportReply {
  # Type of the AMI to be used for export of EC2 instance archived snapshot. This can be an existing AMI, or a runtime-generated AMI or a user-specified AMI.
  amiType: AmiType!

  # If amiType is pre-existing, this field will contain the ID of the AMI.
  amiId: String!

  # Rubrik Id of the aws account which contains the pre-existing AMI.
  awsAccountRubrikId: String!

  # Region where the pre-existing AMI exists.
  regionNativeId: AwsNativeRegion!
}
# Connection status for archival group.
type ArchivalGroupConnectionStatus {
  status: ConnectionStatusType!
}
# Tiering status options for archival groups.
enum ArchivalGroupTieringStatus {
  # Instant tiering not supported.
  INSTANT_TIERING_NOT_SUPPORTED

  # Smart tiering not supported.
  SMART_TIERING_NOT_SUPPORTED

  # Unknown tiering status.
  UNKNOWN_ARCHIVAL_GROUP_TIERING_STATUS
}
# Type of archival location.
enum ArchivalGroupTypeEnum {
  # Archival location is created automatically and managed by Polaris.
  AUTOMATIC_ARCHIVAL_GROUP

  # Archival location created for cloud native workflows.
  CLOUD_NATIVE_ARCHIVAL_GROUP

  # This is a union field for both automatic and manual archival locations.
  DATACENTER_ARCHIVAL_GROUP

  # Archival location is created in Polaris.
  MANUAL_ARCHIVAL_GROUP

  # Type of archival location is unknown.
  UNKNOWN_ARCHIVAL_GROUP
}
type ArchivalLocation {
  id: String!
  name: String!
  locationType: ArchivalLocationType!
  isActive: Boolean!
  bucket: String
}
# Availability status of the archival location.
enum ArchivalLocationStatus {
  # Location is deleted.
  DELETED

  # Location is disabled.
  DISABLED

  # Location is paused.
  PAUSED

  # Location is read-only.
  READ_ONLY

  # Location is read-write.
  READ_WRITE

  # Location status is unknown.
  UNKNOWN_ARCHIVAL_LOCATION_STATUS
}
# Mapping between archival location and Rubrik cluster.
type ArchivalLocationToClusterMapping {
  # Cluster on which the archival location is created.
  cluster: SlaArchivalCluster

  # Location used as archival target.
  location: DlsArchivalLocation
}
enum ArchivalLocationType {
  Azure
  Cleversafe
  Glacier
  Google
  HDS
  Nfs
  Qstar
  Rehydrated
  S3
  S3Compatible
  Scality
}
type ArchivalSpec {
  threshold: Int!
  thresholdUnit: RetentionUnitEnum!
  archivalTieringSpec: ArchivalTieringSpec

  # Archives all snapshots taken with the specified frequency.
  frequencies: [RetentionUnitEnum!]!

  # Mapping between archival location and Rubrik cluster.
  archivalLocationToClusterMapping: [ArchivalLocationToClusterMapping!]!
  storageSetting: TargetMapping
}
# Archival tiering specification.
type ArchivalTieringSpec {
  # True when instant tiering enabled.
  isInstantTieringEnabled: Boolean!

  # Minimum accessible duration specified for smart tiering.
  minAccessibleDurationInSeconds: Long!

  # Cold storage class for tiering.
  coldStorageClass: ColdStorageClass!

  # Tier existing snapshots for instant tiering, when true.
  shouldTierExistingSnapshots: Boolean!
}
type AsyncJobStatus {
  # Job ID for object if pre validation succeeds for object. If pre validation failed Job ID will be empty and detials will be present in error field.
  jobId: String!

  # Error message if pre validation failed.
  error: String!
}
type AsyncJobStatusJobError {
  rubrikObjectId: String!
  error: String!
}
type AsyncJobStatusJobId {
  rubrikObjectId: String!
  jobId: String!
}
# Host AWS EC2 instance specifications for AWS EBS volume.
type AttachmentSpecForEbsVolume {
  # EC2 instance ID.
  awsNativeEc2InstanceId: String!

  # The device path of the EBS volume on the instance.
  devicePath: String!

  # Specifies whether the EBS volume is excluded from snapshots of the EC2 instance..
  isExcludedFromSnapshot: Boolean!

  # Specifies whether the EBS volume is the root volume.
  isRootVolume: Boolean!
}
# EBS volume attachment specifications.
type AttachmentSpecForEc2Instance {
  # EBS volume ID.
  awsNativeEbsVolumeId: String!

  # The device path of this EBS volume attachment.
  devicePath: String!

  # Specifies whether this EBS volume is excluded from snapshots.
  isExcludedFromSnapshot: Boolean!

  # Specifies whether this EBS volume is the root volume of the corresponding EC2 instance.
  isRootVolume: Boolean!
}
# Attachment Specifications for Azure Native Managed Disk.
type AttachmentSpecsForManagedDisk {
  # Virtual machine ID to which the Azure managed disk is attached.
  attachedToVmId: String!

  # Specifies if the managed disk is an OS disk.
  isOsDisk: Boolean!

  # Logical Unit Number (LUN) associated with a managed disk in a virtual machine.
  lun: Int!

  # Specifies whether the managed disk is excluded from snapshots.
  isExcludedFromSnapshot: Boolean!
}
# Attachment Specifications for Azure Native Virtual Machine.
type AttachmentSpecsForVirtualMachine {
  # ID of the Azure managed disk attached ot the virtual machine.
  managedDiskId: String!

  # Specifies if the managed disk is an OS disk.
  isOsDisk: Boolean!

  # Logical Unit Number (LUN) associated with a managed disk in a virtual machine.
  lun: Int!

  # Specifies whether the managed disk is excluded from snapshots.
  isExcludedFromSnapshot: Boolean!
}
# Auth type for the NFS type location.
enum AuthTypeEnum {
  # Kerberos based auth type.
  KERBEROS

  # No auth type.
  NONE
}
type AuthorizedOperations {
  id: String!
  operations: [Operation!]!
  snappableHierarchy: SnappableLevelHierarchyTypeEnum
}
# AWS Account specific info.
type AwsAccount implements CloudAccount {
  # Access key for IAM user, which is required while adding new AWS cloud account.
  accessKey: String!

  # The ID of this Cloud Account.
  cloudAccountId: String!

  # The name of this Cloud Account.
  name: String!

  # The description of this Cloud Account.
  description: String

  # The type of this Cloud Provider.
  cloudProvider: CloudAccountType!

  # The connection status of this Cloud Account.
  connectionStatus: ConnectionStatusType!
}
# Status of an AWS Account.
enum AwsAccountStatus {
  # The AWS account has been added.
  ADDED

  # The AWS account has been deleted.
  DELETED

  # The AWS account is in the process of being deleted.
  DELETING

  # The deletion of the AWS account has failed.
  DELETION_FAILED

  # The AWS account is disconnected.
  DISCONNECTED

  # The AWS account has been refreshed.
  REFRESHED

  # The AWS account is refreshing.
  REFRESHING

  # The AWS account has failed to refresh.
  REFRESH_FAILED
}
# Validate given aws accounts.
type AwsAccountValidationResponse {
  # AWS account native ID.
  nativeId: String!

  # AWS account name.
  accountName: String!

  # AWS account validation response message.
  message: String!

  # Specfies whether seamless flow is enabled for this AWS account.
  seamlessFlowEnabled: Boolean!

  # AWS account cloud type.
  cloudType: AwsCloudType!
}
# AWS authentication server based cloud account region names.
enum AwsAuthServerBasedCloudAccountRegion {
  # AWS cloud unknown region.
  UNKNOWN_AWS_AUTH_SERVER_BASED_REGION

  # AWS cloud US ISOB East 1 region.
  US_ISOB_EAST_1

  # AWS cloud US ISO East 1 region.
  US_ISO_EAST_1

  # AWS cloud US ISO West 1 region.
  US_ISO_WEST_1
}
# Details of AWS authentication server-based cloud account.
type AwsAuthServerDetail {
  # Agency name for the feature.
  agency: String!

  # Role name for the feature.
  roleName: String!

  # Host name of the authentication server.
  authServerHostName: String!

  # Client's TLS Certificate ID for the authentication server.
  authServerUserClientCertId: Long!

  # CA certificate ID for the authentication server.
  authServerCaCertId: Long!

  # List of AWS secret regions.
  authServerAwsRegions: [AwsAuthServerBasedCloudAccountRegion!]!
}
# Details of AWS account.
type AwsCloudAccount {
  # Rubrik ID of cloud account.
  id: String!

  # Native ID of cloud account.
  nativeId: String!

  # Name of cloud account.
  accountName: String!

  # Message for cloud account, in case of error.
  message: String!

  # Whether seamless flow is enabled on cloud account.
  seamlessFlowEnabled: Boolean!

  # Type of cloud account.
  cloudType: AwsCloudType!
}
# Input to get AWS cloud account configurations.
input AwsCloudAccountConfigsInput {
  # Type of cloud native protection feature.
  feature: CloudAccountFeature!

  # List of status filters for listing cloud accounts.
  statusFilters: [CloudAccountStatus!]!

  # Admin account ID to filter.
  awsAdminAccountFilter: UUID

  # Search text to match in native ID, account name, or role ARN.
  columnSearchFilter: String
}
# Initiate aws cloud accounts.
type AwsCloudAccountCreateResponse {
  # List of AWS regions for the cloud account.
  awsRegions: [AwsCloudAccountRegion!]

  # AWS CloudFormation template URL.
  templateUrl: String!

  # Stack name of template to run, only for single account addition.
  stackName: String

  # StackSet name of template to run, only for bulk account addition.
  stackSetName: String

  # AWS CloudFormation URL.
  cloudFormationUrl: String!

  # External ID for the cloud account.
  externalId: String!

  # List of feature versions.
  featureVersions: [AwsCloudAccountFeatureVersion!]!

  # Role ARN for the feature (if valid).
  roleArn: String!
}
# Feature version of AWS cloud accounts.
type AwsCloudAccountFeatureVersion {
  # Feature Enum.
  feature: CloudAccountFeature!

  # Version.
  version: Int!
}
# Input to protect a feature for the AWS cloud account.
input AwsCloudAccountFeatureVersionInput {
  # Name of feature to be protected for cloud account.
  feature: CloudAccountFeature!

  # Version of feature. This should be same as the response given in the first step (validateAndCreateAwsCloudAccount).
  version: Int!
}
# Details of an AWS cloud account.
input AwsCloudAccountInput {
  # Rubrik ID of the AWS cloud account.
  id: String = ""

  # Native ID of cloud account.
  nativeId: String = ""

  # Name of cloud account.
  accountName: String = ""

  # Whether seamless setup flow is enabled on cloud account.
  seamlessFlowEnabled: Boolean = false

  # Cloud type (Standard/China) for the cloud account.
  cloudType: AwsCloudType = STANDARD
}
# AWS cloud account regions enum.
enum AwsCloudAccountRegion {
  # AWS cloud Africa (Cape Town) region.
  AF_SOUTH_1

  # AWS cloud Asia Pacific (Hong Kong) region.
  AP_EAST_1

  # AWS cloud Asia Pacific (Tokyo) region.
  AP_NORTHEAST_1

  # AWS cloud Asia Pacific (Seoul) region.
  AP_NORTHEAST_2

  # AWS cloud Asia Pacific (Singapore) region.
  AP_SOUTHEAST_1

  # AWS cloud Asia Pacific (Sydney) region.
  AP_SOUTHEAST_2

  # AWS cloud Asia Pacific (Mumbai) region.
  AP_SOUTH_1

  # AWS cloud Canada (Central) region.
  CA_CENTRAL_1

  # AWS cloud China (Ningxia) region.
  CN_NORTHWEST_1

  # AWS cloud China (Beijing) region.
  CN_NORTH_1

  # AWS cloud EU (Frankfurt) region.
  EU_CENTRAL_1

  # AWS cloud EU (Stockholm) region.
  EU_NORTH_1

  # AWS cloud EU (Milan) region.
  EU_SOUTH_1

  # AWS cloud EU (Ireland) region.
  EU_WEST_1

  # AWS cloud EU (London) region.
  EU_WEST_2

  # AWS cloud EU (Paris) region.
  EU_WEST_3

  # AWS cloud Middle East (Bahrain) region.
  ME_SOUTH_1

  # AWS cloud South America (Sao Paulo) region.
  SA_EAST_1

  # AWS cloud region is unknown.
  UNKNOWN_AWS_REGION

  # AWS cloud US East (N. Virginia) region.
  US_EAST_1

  # AWS cloud US East (Ohio) region.
  US_EAST_2

  # AWS Gov cloud US East 1 (N. Virginia) region.
  US_GOV_EAST_1

  # AWS Gov cloud US West 1 (N. California) region.
  US_GOV_WEST_1

  # AWS cloud US West (N. California) region.
  US_WEST_1

  # AWS cloud US West (Oregon) region.
  US_WEST_2
}
# Aws cloud accounts validate response.
type AwsCloudAccountValidateResponse {
  # Contains error message for admin account.
  invalidAwsAdminAccount: AwsAccountValidationResponse

  # Contains error message for account(s).
  invalidAwsAccounts: [AwsAccountValidationResponse!]!
}
# Aws cloud accounts features.
type AwsCloudAccountWithFeatures {
  # AWS account details.
  awsCloudAccount: AwsCloudAccount

  # Feature details for the cloud account.
  featureDetails: [FeatureDetail!]!
}
# AWS cloud account with features.
input AwsCloudAccountWithFeaturesInput {
  # Type of cloud native protection features.
  features: [CloudAccountFeature!]!
}
# AWS cloud accounts with features.
input AwsCloudAccountsWithFeaturesInput {
  # Type of cloud native protection feature.
  feature: CloudAccountFeature!

  # List of status filters for listing cloud accounts.
  statusFilters: [CloudAccountStatus!]!

  # Admin account ID to filter.
  awsAdminAccountFilter: UUID

  # Search text to match in native ID, account name, and role ARN.
  columnSearchFilter: String
}
# AWS Cloud Type Enum.
enum AwsCloudType {
  # Cloud type for AWS C2S cloud account.
  C2S

  # Cloud type for AWS China cloud account.
  CHINA

  # Cloud type for AWS Gov cloud account.
  GOV

  # Cloud type for AWS SC2S cloud account.
  SC2S

  # Cloud type for AWS Commercial cloud account.
  STANDARD
}
# Compute setting for AWS Target.
type AwsComputeSettings {
  id: String!
  subnetId: String!
  vpcId: String!
  securityGroupId: String!
  proxySettings: ProxySettings
  region: AwsRegion!
  name: String!
  isArchived: Boolean!
  isPolarisManaged: Boolean!
  clusterInterfaceCidrs: [ClusterInfCidrs!]!
  cloudAccount: CloudAccount
}
# AWS Exocompute configurations in an AWS account.
type AwsExocomputeConfig {
  # Account details.
  awsCloudAccount: AwsCloudAccount!

  # Feature details.
  featureDetail: FeatureDetail!

  # List of regions for which exocompute can be configured.
  exocomputeEligibleRegions: [AwsCloudAccountRegion!]!

  # AWS exocompute get configurations response.
  configs: [AwsExocomputeGetConfigResponse!]!
}
# AWS exocompute configuration to add.
input AwsExocomputeConfigInput {
  # The region for which the configuration is specified.
  region: AwsCloudAccountRegion!

  # AWS ID of cluster control plane security group. Not required if isPolarisManaged is true.
  clusterSecurityGroupId: String = ""

  # AWS ID of the VPC.
  vpcId: String!

  # AWS ID of worker node security group. Not required if isPolarisManaged is true.
  nodeSecurityGroupId: String = ""

  # List of exactly 2 subnets.
  subnets: [AwsExocomputeSubnetInputType!]!

  # True, if security groups are to be managed to be polaris. False, if security groups are managed by user.
  isPolarisManaged: Boolean!
}
# AWS Exocompute configurations Deletion status.
type AwsExocomputeConfigsDeletionStatusType {
  # Exocompute configuration ID.
  exocomputeConfigId: String!

  # Specifies whether the deletion of the Exocompute configuration was successful.
  success: Boolean!
}
# AWS Exocompute configuration in a region.
type AwsExocomputeGetConfigResponse {
  # Exocompute configuration UUID.
  configUuid: String!

  # Exocompute configuration region.
  region: AwsCloudAccountRegion!

  # VPC ID.
  vpcId: String!

  # Cluster security group ID.
  clusterSecurityGroupId: String!

  # Node security group ID.
  nodeSecurityGroupId: String!

  # Specifies whether the security groups are managed by Polaris.
  areSecurityGroupsPolarisManaged: Boolean!

  # First subnet.
  subnet1: AwsExocomputeSubnetType!

  # Second subnet.
  subnet2: AwsExocomputeSubnetType!

  # Exocompute configuration message.
  message: String!

  # Status of the latest Exocompute health check.
  healthCheckStatus: ExocomputeHealthCheckStatus!
}
# AWS exocompute subnet input.
input AwsExocomputeSubnetInputType {
  # AWS ID of subnet.
  subnetId: String!

  # Availability zone of the subnet.
  availabilityZone: String!
}
# AWS Exocompute subnet.
type AwsExocomputeSubnetType {
  # ID of the subnet.
  subnetId: String!

  # Availability zone in which the subnet resides.
  availabilityZone: String!
}
# AWS feature configurations in an AWS account.
type AwsFeatureConfig {
  # Account details.
  awsCloudAccount: AwsCloudAccount!

  # Feature detail.
  featureDetail: FeatureDetail!

  # Aws exocompute configurations.
  exocomputeConfigs: [AwsExocomputeGetConfigResponse!]!
}
# Immutability settings for aws cdm target.
type AwsImmutabilitySettingsType {
  # Number of days location is immutable.
  lockDurationDays: Int!
}
# Input to filter AWS EC2 instances based on RBS connection status.
input AwsInstanceCcOrCnpRbsConnectionStatusFilter {
  # Connection status of the Rubrik Backup Service (RBS) installed on the instance.
  status: CloudInstanceRbsConnectionStatus!
}
# AWS native account.
type AwsNativeAccount implements PolarisHierarchyObject , HierarchyObject {
  # Specifies the state of account in Rubrik environment like Refreshed, Disconnected, etc. An account can be in a single state at a time.
  status: AwsAccountStatus!

  # Last refresh time of the account, in UTC date-time format.
  lastRefreshedAt: DateTime

  # List of AWS region specifications associated with the account.
  regionSpecs: [AwsNativeRegionSpec!]!

  # Count of EC2 Instances in the AWS Native account.
  ec2InstanceCount: Int!

  # Count of EBS Volumes in the AWS Native account.
  ebsVolumeCount: Int!

  # Count of RDS Instances in the account.
  rdsInstanceCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!

  # List of all EC2 instances under this AWS Native account.
  awsNativeEc2Instances(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS EC2 instances.
    sortBy: AwsNativeEc2InstanceSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, ec2InstanceFilters: AwsNativeEc2InstanceFilters): AwsNativeEc2InstanceConnection!

  # List of all EBS Volumes under this AWS Native account.
  awsNativeEbsVolumes(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS EBS volumes.
    sortBy: AwsNativeEbsVolumeSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, ebsVolumeFilters: AwsNativeEbsVolumeFilters): AwsNativeEbsVolumeConnection!

  # List of all RDS Instances under this AWS Native account.
  awsNativeRdsInstances(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of AWS RDS instances.
    sortBy: AwsNativeRdsInstanceSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, rdsInstanceFilters: AwsNativeRdsInstanceFilters): AwsNativeRdsInstanceConnection!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Paginated list of AwsNativeAccount objects.
type AwsNativeAccountConnection {
  # List of AwsNativeAccount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [AwsNativeAccountEdge!]!

  # List of AwsNativeAccount objects.
  nodes: [AwsNativeAccount!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of AwsNativeAccount objects matching the request arguments.
  count: Int!
}
interface AwsNativeAccountDescendantType {
  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Wrapper around the AwsNativeAccount object. This wrapper is used for pagination.
type AwsNativeAccountEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual AwsNativeAccount object wrapped by this edge.
  node: AwsNativeAccount!
}
# Filter to return AWS objects which have account rubrik ID in the given list of account rubrik IDs.
input AwsNativeAccountFilter {
  # List of AWS account Rubrik IDs.
  accountIds: [String!]!
}
# Filters for list of AWS accounts.
input AwsNativeAccountFilters {
  # Filter by name substring.
  nameSubstringFilter: NameSubstringFilter

  # Filter by effective SLA Domain.
  effectiveSlaFilter: EffectiveSlaFilter
}
interface AwsNativeAccountLogicalChildType {
  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# The field type used to sort AWS accounts.
enum AwsNativeAccountSortFields {
  # Use EBS volume count for sorting.
  EBS_VOLUME_COUNT

  # Use EC2 instance count for sorting.
  EC2_INSTANCE_COUNT

  # Use AWS account SLA Domain for sorting.
  EFFECTIVE_SLA_DOMAIN

  # Use AWS account name for sorting.
  NAME
}
# Filter to return AWS EBS volumes which are attached to one of the EC2 instances in the given list of EC2 instance IDs.
input AwsNativeAttachedInstanceFilter {
  # List of EC2 instance IDs.
  ec2InstanceIds: [String!]!
}
# AWS native EBS volume.
type AwsNativeEbsVolume implements PolarisHierarchyObject , PolarisHierarchySnappable , HierarchyObject , AwsNativeAccountLogicalChildType , AwsNativeAccountDescendantType {
  # AWS Native ID of EBS volume.
  volumeNativeId: String!

  # Name of volume on AWS. Name is not necessarily unique for different volumes.
  volumeName: String!

  # AWS Native EBS volume type. Some examples are: g3, io2. This field cannot be null or empty string and will be mapped directly to available EBS volumes on cloud(AWS). For more information, see https://aws.amazon.com/ebs/volume-types.
  volumeType: String!

  # Size of volume in GiB.
  sizeInGiBs: Int!

  # Input/Output (IO) limit per second for volume.
  iops: Long!

  # Name of the region. Some examples are: US_EAST_1, AP_EAST_1. This field cannot be null or empty string and will be mapped directly to available regions for EBS volume on cloud(AWS). For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions.
  region: AwsNativeRegion!

  # Whether exocompute is configured for the region where the volume is.
  isExocomputeConfigured: Boolean!

  # Name of the Availability Zone (AZ). Some examples are: US_EAST_1, AP_EAST_1. This field cannot be null or empty string and will be mapped directly to available AZ for EC2 instance on cloud(AWS). For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones.
  availabilityZone: String!

  # List of tags associated with volume.
  tags: [Tag!]!

  # Whether the volume is relic.
  isRelic: Boolean!

  # Rubrik ID of Instance.
  awsAccountRubrikId: String!

  # List of EC2 instance details to which volume is attached.
  attachmentSpecs: [AttachmentSpecForEbsVolume!]!

  # Name for the AWS account.
  awsNativeAccountName: String!

  # Whether indexing is enabled for snapshots of volume.
  isIndexingEnabled: Boolean!

  # Whether the volume image is marketplace image.
  isMarketplace: Boolean!

  # The authorized operations on the object.
  authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!

  # AWS Native account associated with the EBS Volumes.
  awsNativeAccount: AwsNativeAccount!

  # EC2 Instances to which this volume is attached.
  attachedEc2Instances: [AwsNativeEc2Instance!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!

  # The list of snapshots taken for this workload.
  snapshotConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Sort Polaris snapshots by field.
    sortBy: PolarisSnapshotSortByEnum = Date,

    # Sort order.
    sortOrder: SortOrderEnum): PolarisSnapshotConnection

  # The list of snapshots taken for this workload.
  snapshotsOfSnappableConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String, snappableId: String!,

    # Filter for snapshot connection.
    snapshotFilter: [SnapshotQueryFilterInput!],

    # Sort order.
    sortOrder: SortOrderEnum, sortBy: SnapshotQuerySortByField,

    # Time range input.
    timeRange: TimeRangeInput,

    # Specifies whether to ignore the active protected object check.
    ignoreActiveSnappableCheck: Boolean): GenericSnapshotConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Group Polaris snapshots by field.
    groupBy: PolarisSnapshotGroupByEnum!): PolarisSnapshotGroupByConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByNewConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    snapshotFilter: [PolarisSnapshotFilterNewInput!]!,

    # Group Polaris snapshots by field.
    snapshotGroupBy: SnapshotGroupByTimeEnum!): PolarisSnapshotGroupByNewConnection

  # The most recent snapshot of this workload.
  newestSnapshot: PolarisSnapshot

  # The oldest snapshot of this workload.
  oldestSnapshot: PolarisSnapshot

  # The number of on-demand snapshots.
  onDemandSnapshotCount: Int!

  # The newest snapshot that is indexed and unexpired, and therefore restorable.
  newestIndexedSnapshot: PolarisSnapshot
}
# Paginated list of AwsNativeEbsVolume objects.
type AwsNativeEbsVolumeConnection {
  # List of AwsNativeEbsVolume objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [AwsNativeEbsVolumeEdge!]!

  # List of AwsNativeEbsVolume objects.
  nodes: [AwsNativeEbsVolume!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of AwsNativeEbsVolume objects matching the request arguments.
  count: Int!
}
# Wrapper around the AwsNativeEbsVolume object. This wrapper is used for pagination.
type AwsNativeEbsVolumeEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual AwsNativeEbsVolume object wrapped by this edge.
  node: AwsNativeEbsVolume!
}
# Filter to return AWS EBS volumes which have file recovery enabled.
input AwsNativeEbsVolumeFileRecoveryStatusFilter {
  # List of file recovery statuses.
  statuses: [AwsNativeFileRecoveryStatus!]!
}
# Filters for list of AWS EBS volumes.
input AwsNativeEbsVolumeFilters {
  # Filter by name or ID substring.
  nameOrIdSubstringFilter: AwsNativeEbsVolumeNameOrIdSubstringFilter

  # Filter by file recovery status.
  fileRecoveryStatusFilter: AwsNativeEbsVolumeFileRecoveryStatusFilter

  # Filter by EBS volume type.
  typeFilter: AwsNativeEbsVolumeTypeFilter

  # Filter by attached EC2 instance.
  attachedInstanceFilter: AwsNativeAttachedInstanceFilter

  # Filter by effective SLA Domain.
  effectiveSlaFilter: EffectiveSlaFilter

  # Filter by AWS account.
  accountFilter: AwsNativeAccountFilter

  # Filter by region.
  regionFilter: AwsNativeRegionFilter

  # Filter by relic status.
  relicFilter: RelicFilter

  # Filter by tags.
  tagFilter: AwsNativeTagFilter
}
# Filter to return AWS EBS volumes with a given substring in their name or instance ID.
input AwsNativeEbsVolumeNameOrIdSubstringFilter {
  # Name or ID substring.
  nameOrIdSubstring: String!
}
# The field type used to sort the EBS volumes.
enum AwsNativeEbsVolumeSortFields {
  # Use AWS account name for sorting.
  AWS_NATIVE_ACCOUNT_NAME

  # Use EBS volume ID for sorting.
  EBS_VOLUME_ID

  # Use EBS volume name for sorting.
  EBS_VOLUME_NAME

  # Use size of EBS volume for sorting.
  EBS_VOLUME_SIZE

  # Use type of EBS volume for sorting.
  EBS_VOLUME_TYPE

  # Use EBS volume SLA Domain for sorting.
  EFFECTIVE_SLA_DOMAIN
}
# AWS EBS volume types.
enum AwsNativeEbsVolumeType {
  # EBS volume type is gp2.
  GP2

  # EBS volume type is gp3.
  GP3

  # EBS volume type is io1.
  IO1

  # EBS volume type is io2.
  IO2

  # EBS volume type is not specified.
  NOT_SPECIFIED

  # EBS volume type is sc1.
  SC1

  # EBS volume type is st1.
  ST1

  # Storage type is standard.
  STANDARD

  # EBS volume type is unknown.
  UNKNOWN
}
# Filter to return AWS EBS volumes which have volume type in the given list of volume types.
input AwsNativeEbsVolumeTypeFilter {
  # List of EBS volume types.
  ebsVolumeTypes: [AwsNativeEbsVolumeType!]!
}
# AWS native EC2 instance.
type AwsNativeEc2Instance implements PolarisHierarchyObject , PolarisHierarchySnappable , HierarchyObject , AwsNativeAccountLogicalChildType , AwsNativeAccountDescendantType {
  # AWS Native ID of Instance.
  instanceNativeId: String!

  # Name of instance on AWS. Name is not necessarily unique for different instances.
  instanceName: String!

  # Public IP address for instance.
  publicIp: String!

  # Private IP address for instance.
  privateIp: String!

  # AWS Native EC2 instance type. Some examples are: t2.nano, m5.xlarge. This field cannot be null or empty string and will be mapped directly to available EC2 instance on cloud(AWS). For more information, see https://aws.amazon.com/ec2/instance-types.
  instanceType: String!

  # Name of the region. Some examples are: US_EAST_1, AP_EAST_1. This field cannot be null or empty string and will be mapped directly to available regions for EC2 instance on cloud(AWS). For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions.
  region: AwsNativeRegion!

  # Whether exocompute is configured for the region where the instance is.
  isExocomputeConfigured: Boolean!

  # Name of the Availability Zone (AZ). Some examples are: US_EAST_1, AP_EAST_1. This field cannot be null or empty string and will be mapped directly to available AZs for EC2 instance on cloud(AWS). For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones.
  availabilityZone: String!

  # ID of Virtual Private Cloud (VPC) associated with instance.
  vpcId: String!

  # Name of Virtual Private Cloud (VPC) associated with instance.
  vpcName: String!

  # List of tags associated with Instance.
  tags: [Tag!]!

  # Name of the Operating System (OS) for the Instance. Some examples are: Linux, Windows. This field cannot be null or empty string but can be Undefined in case it is not currently supported.List of supported OS: Linux, Windows.
  osType: OsTypeEnum!

  # Whether the instance is relic.
  isRelic: Boolean!

  # Rubrik ID of Instance.
  awsAccountRubrikId: String!

  # List of EBS volume details attached to the instance.
  attachmentSpecs: [AttachmentSpecForEc2Instance!]!

  # Name for the AWS Account.
  awsNativeAccountName: String!

  # Whether indexing is enabled for snapshots of instance.
  isIndexingEnabled: Boolean!

  # Whether the instance image is marketplace image.
  isMarketplace: Boolean!

  # Name of SSH key-pair for the Instance.
  sshKeyPairName: String!

  # The authorized operations on the object.
  authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!

  # AWS account of the EC2 instance.
  awsNativeAccount: AwsNativeAccount!

  # Attach an AWS Elastic Block Store (EBS) volume to your instance.
  attachedEbsVolumes: [AwsNativeEbsVolume!]!

  # Rubrik CDM host information for the AWS EC2 instance added as a host to the cluster. The value is Null when the virtual machine is not added as a host on any Rubrik cluster.
  hostInfo: PhysicalHost

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!

  # The list of snapshots taken for this workload.
  snapshotConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Sort Polaris snapshots by field.
    sortBy: PolarisSnapshotSortByEnum = Date,

    # Sort order.
    sortOrder: SortOrderEnum): PolarisSnapshotConnection

  # The list of snapshots taken for this workload.
  snapshotsOfSnappableConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String, snappableId: String!,

    # Filter for snapshot connection.
    snapshotFilter: [SnapshotQueryFilterInput!],

    # Sort order.
    sortOrder: SortOrderEnum, sortBy: SnapshotQuerySortByField,

    # Time range input.
    timeRange: TimeRangeInput,

    # Specifies whether to ignore the active protected object check.
    ignoreActiveSnappableCheck: Boolean): GenericSnapshotConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Group Polaris snapshots by field.
    groupBy: PolarisSnapshotGroupByEnum!): PolarisSnapshotGroupByConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByNewConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    snapshotFilter: [PolarisSnapshotFilterNewInput!]!,

    # Group Polaris snapshots by field.
    snapshotGroupBy: SnapshotGroupByTimeEnum!): PolarisSnapshotGroupByNewConnection

  # The most recent snapshot of this workload.
  newestSnapshot: PolarisSnapshot

  # The oldest snapshot of this workload.
  oldestSnapshot: PolarisSnapshot

  # The number of on-demand snapshots.
  onDemandSnapshotCount: Int!

  # The newest snapshot that is indexed and unexpired, and therefore restorable.
  newestIndexedSnapshot: PolarisSnapshot
}
# Paginated list of AwsNativeEc2Instance objects.
type AwsNativeEc2InstanceConnection {
  # List of AwsNativeEc2Instance objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [AwsNativeEc2InstanceEdge!]!

  # List of AwsNativeEc2Instance objects.
  nodes: [AwsNativeEc2Instance!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of AwsNativeEc2Instance objects matching the request arguments.
  count: Int!
}
# Wrapper around the AwsNativeEc2Instance object. This wrapper is used for pagination.
type AwsNativeEc2InstanceEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual AwsNativeEc2Instance object wrapped by this edge.
  node: AwsNativeEc2Instance!
}
# Filter to return AWS EC2 instances which have file recovery enabled.
input AwsNativeEc2InstanceFileRecoveryStatusFilter {
  # List of file recovery statuses.
  statuses: [AwsNativeFileRecoveryStatus!]!
}
# Filters for list of AWS EC2 instances.
input AwsNativeEc2InstanceFilters {
  # Filter by name or ID substring.
  nameOrIdSubstringFilter: AwsNativeEc2InstanceNameOrIdSubstringFilter

  # Filter by effective SLA Domain.
  effectiveSlaFilter: EffectiveSlaFilter

  # Filter by AWS account.
  accountFilter: AwsNativeAccountFilter

  # Filter by file recovery status.
  fileRecoveryStatusFilter: AwsNativeEc2InstanceFileRecoveryStatusFilter

  # Filter by region.
  regionFilter: AwsNativeRegionFilter

  # Filter by EC2 instance type.
  typeFilter: AwsNativeEc2InstanceTypeFilter

  # Filter by VPC.
  vpcFilter: AwsNativeVpcFilter

  # Filter by relic status.
  relicFilter: RelicFilter

  # Filter by tags.
  tagFilter: AwsNativeTagFilter

  # Filter by the protection status of the App.
  appProtectionStatusFilter: CloudNativeInstaceAppProtectionFilter

  # Filter by RBS connection status.
  rbsStatusFilter: AwsInstanceCcOrCnpRbsConnectionStatusFilter
}
# Filter to return AWS EC2 instances with a given substring in their name or instance ID.
input AwsNativeEc2InstanceNameOrIdSubstringFilter {
  # Name or ID substring.
  nameOrIdSubstring: String!
}
# The field type used to sort the EC2 instances.
enum AwsNativeEc2InstanceSortFields {
  # Use SLA Domain assignment for sorting.
  ASSIGNED_SLA_DOMAIN

  # Use AWS account name for sorting.
  AWS_NATIVE_ACCOUNT_NAME

  # Use VPC ID for sorting.
  AWS_VPC_ID

  # Use EC2 instance ID for sorting.
  EC2_INSTANCE_ID

  # Use EC2 instance name for sorting.
  EC2_INSTANCE_NAME

  # Use type of EC2 instance for sorting.
  EC2_INSTANCE_TYPE

  # Use EC2 instance SLA Domain for sorting.
  EFFECTIVE_SLA_DOMAIN
}
# Specific information for AWS EC2 snapshot created on Polaris.
type AwsNativeEc2InstanceSpecificSnapshot implements PolarisSpecificSnapshot {
  # Native ID of the EC2 snapshot.
  nativeId: String!

  # Native name of the EC2 snapshot.
  nativeName: String!

  # Consistency level of the EC2 snapshot.
  consistencyLevel: SnapshotServiceConsistencyLevel!

  # Instance type of the EC2 snapshot.
  instanceType: String!

  # AWS native account ID of the EC2 snapshot.
  awsNativeAccountId: String!

  # Region native ID of the EC2 snapshot.
  region: String!

  # Volume snapshots excluded from the EC2 snapshot.
  volumeSnapshotsToExclude: [String!]!

  # IAM instance profile ARN of the EC2 object at the time EC2 snapshot was taken.
  iamInstanceProfileArn: String!

  # List of key-value pairs that map device path to volume snapshot.
  devicePathToVolumeSnapshotIdMap: DevicePathToVolumeSnapshotIdMap!

  # ID of the snapshot.
  snapshotId: UUID!
}
# AWS EC2 instance types.
enum AwsNativeEc2InstanceType {
  # EC2 instance type is a1.2xlarge.
  A1_2XLARGE

  # EC2 instance type is a1.4xlarge.
  A1_4XLARGE

  # EC2 instance type is a1.large.
  A1_LARGE

  # EC2 instance type is a1.medium.
  A1_MEDIUM

  # EC2 instance type is a1.metal.
  A1_METAL

  # EC2 instance type is a1.xlarge.
  A1_XLARGE

  # EC2 instance type is c1.medium.
  C1_MEDIUM

  # EC2 instance type is c1.xlarge.
  C1_XLARGE

  # EC2 instance type is c3.2xlarge.
  C3_2XLARGE

  # EC2 instance type is c3.4xlarge.
  C3_4XLARGE

  # EC2 instance type is c3.8xlarge.
  C3_8XLARGE

  # EC2 instance type is c3.large.
  C3_LARGE

  # EC2 instance type is c3.xlarge.
  C3_XLARGE

  # EC2 instance type is c4.2xlarge.
  C4_2XLARGE

  # EC2 instance type is c4.4xlarge.
  C4_4XLARGE

  # EC2 instance type is c4.8xlarge.
  C4_8XLARGE

  # EC2 instance type is c4.large.
  C4_LARGE

  # EC2 instance type is c4.xlarge.
  C4_XLARGE

  # EC2 instance type is c5d.12xlarge.
  C5D_12XLARGE

  # EC2 instance type is c5d.18xlarge.
  C5D_18XLARGE

  # EC2 instance type is c5d.24xlarge.
  C5D_24XLARGE

  # EC2 instance type is c5d.2xlarge.
  C5D_2XLARGE

  # EC2 instance type is c5d.4xlarge.
  C5D_4XLARGE

  # EC2 instance type is c5d.9xlarge.
  C5D_9XLARGE

  # EC2 instance type is c5d.large.
  C5D_LARGE

  # EC2 instance type is c5d.metal.
  C5D_METAL

  # EC2 instance type is c5d.xlarge.
  C5D_XLARGE

  # EC2 instance type is c5n.18xlarge.
  C5N_18XLARGE

  # EC2 instance type is c5n.2xlarge.
  C5N_2XLARGE

  # EC2 instance type is c5n.4xlarge.
  C5N_4XLARGE

  # EC2 instance type is c5n.9xlarge.
  C5N_9XLARGE

  # EC2 instance type is c5n.large.
  C5N_LARGE

  # EC2 instance type is c5n.xlarge.
  C5N_XLARGE

  # EC2 instance type is c5.12xlarge.
  C5_12XLARGE

  # EC2 instance type is c5.18xlarge.
  C5_18XLARGE

  # EC2 instance type is c5.24xlarge.
  C5_24XLARGE

  # EC2 instance type is c5.2xlarge.
  C5_2XLARGE

  # EC2 instance type is c5.4xlarge.
  C5_4XLARGE

  # EC2 instance type is c5.9xlarge.
  C5_9XLARGE

  # EC2 instance type is c5.large.
  C5_LARGE

  # EC2 instance type is c5.metal.
  C5_METAL

  # EC2 instance type is c5.xlarge.
  C5_XLARGE

  # EC2 instance type is cc1.4xlarge.
  CC1_4XLARGE

  # EC2 instance type is cc2.8xlarge.
  CC2_8XLARGE

  # EC2 instance type is cg1.4xlarge.
  CG1_4XLARGE

  # EC2 instance type is cr1.8xlarge.
  CR1_8XLARGE

  # EC2 instance type is d2.2xlarge.
  D2_2XLARGE

  # EC2 instance type is d2.4xlarge.
  D2_4XLARGE

  # EC2 instance type is d2.8xlarge.
  D2_8XLARGE

  # EC2 instance type is d2.xlarge.
  D2_XLARGE

  # EC2 instance type is f1.16xlarge.
  F1_16XLARGE

  # EC2 instance type is f1.2xlarge.
  F1_2XLARGE

  # EC2 instance type is f1.4xlarge.
  F1_4XLARGE

  # EC2 instance type is g2.2xlarge.
  G2_2XLARGE

  # EC2 instance type is g2.8xlarge.
  G2_8XLARGE

  # EC2 instance type is g3s.xlarge.
  G3S_XLARGE

  # EC2 instance type is g3.16xlarge.
  G3_16XLARGE

  # EC2 instance type is g3.4xlarge.
  G3_4XLARGE

  # EC2 instance type is g3.8xlarge.
  G3_8XLARGE

  # EC2 instance type is g4dn.2xlarge.
  G4DN_12XLARGE

  # EC2 instance type is g4dn.2xlarge.
  G4DN_16XLARGE

  # EC2 instance type is g4dn.2xlarge.
  G4DN_2XLARGE

  # EC2 instance type is g4dn.2xlarge.
  G4DN_4XLARGE

  # EC2 instance type is g4dn.2xlarge.
  G4DN_8XLARGE

  # EC2 instance type is g4dn.2xlarge.
  G4DN_XLARGE

  # EC2 instance type is h1.16xlarge.
  H1_16XLARGE

  # EC2 instance type is h1.2xlarge.
  H1_2XLARGE

  # EC2 instance type is h1.4xlarge.
  H1_4XLARGE

  # EC2 instance type is h1.8xlarge.
  H1_8XLARGE

  # EC2 instance type is hI1.4xlarge.
  HI1_4XLARGE

  # EC2 instance type is hs1.8xlarge.
  HS1_8XLARGE

  # EC2 instance type is i2.2xlarge.
  I2_2XLARGE

  # EC2 instance type is i2.4xlarge.
  I2_4XLARGE

  # EC2 instance type is i2.8xlarge.
  I2_8XLARGE

  # EC2 instance type is i2.xlarge.
  I2_XLARGE

  # EC2 instance type is i3en.12xlarge.
  I3EN_12XLARGE

  # EC2 instance type is i3en.24xlarge.
  I3EN_24XLARGE

  # EC2 instance type is i3en.2xlarge.
  I3EN_2XLARGE

  # EC2 instance type is i3en.3xlarge.
  I3EN_3XLARGE

  # EC2 instance type is i3en.6xlarge.
  I3EN_6XLARGE

  # EC2 instance type is i3en.large.
  I3EN_LARGE

  # EC2 instance type is i3en.metal.
  I3EN_METAL

  # EC2 instance type is i3en.xlarge.
  I3EN_XLARGE

  # EC2 instance type is i3.16xlarge.
  I3_16XLARGE

  # EC2 instance type is i3.2xlarge.
  I3_2XLARGE

  # EC2 instance type is i3.4xlarge.
  I3_4XLARGE

  # EC2 instance type is i3.8xlarge.
  I3_8XLARGE

  # EC2 instance type is i3.large.
  I3_LARGE

  # EC2 instance type is i3.metal.
  I3_METAL

  # EC2 instance type is i3.xlarge.
  I3_XLARGE

  # EC2 instance type is inf1.24xlarge.
  INF1_24XLARGE

  # EC2 instance type is inf1.2xlarge.
  INF1_2XLARGE

  # EC2 instance type is inf1.6xlarge.
  INF1_6XLARGE

  # EC2 instance type is inf1.xlarge.
  INF1_XLARGE

  # EC2 instance type is m1.large.
  M1_LARGE

  # EC2 instance type is m1.medium.
  M1_MEDIUM

  # EC2 instance type is m1.small.
  M1_SMALL

  # EC2 instance type is m1.xlarge.
  M1_XLARGE

  # EC2 instance type is m2.2xlarge.
  M2_2XLARGE

  # EC2 instance type is m2.4xlarge.
  M2_4XLARGE

  # EC2 instance type is m2.xlarge.
  M2_XLARGE

  # EC2 instance type is m3.2xlarge.
  M3_2XLARGE

  # EC2 instance type is m3.large.
  M3_LARGE

  # EC2 instance type is m3.medium.
  M3_MEDIUM

  # EC2 instance type is m3.xlarge.
  M3_XLARGE

  # EC2 instance type is m4.10xlarge.
  M4_10XLARGE

  # EC2 instance type is m4.16xlarge.
  M4_16XLARGE

  # EC2 instance type is m4.2xlarge.
  M4_2XLARGE

  # EC2 instance type is m4.4xlarge.
  M4_4XLARGE

  # EC2 instance type is m4.large.
  M4_LARGE

  # EC2 instance type is m4.xlarge.
  M4_XLARGE

  # EC2 instance type is m5ad.12xlarge.
  M5AD_12XLARGE

  # EC2 instance type is m5ad.16xlarge.
  M5AD_16XLARGE

  # EC2 instance type is m5ad.24xlarge.
  M5AD_24XLARGE

  # EC2 instance type is m5ad.2xlarge.
  M5AD_2XLARGE

  # EC2 instance type is m5ad.4xlarge.
  M5AD_4XLARGE

  # EC2 instance type is m5ad.8xlarge.
  M5AD_8XLARGE

  # EC2 instance type is m5ad.large.
  M5AD_LARGE

  # EC2 instance type is m5ad.xlarge.
  M5AD_XLARGE

  # EC2 instance type is m5a.12xlarge.
  M5A_12XLARGE

  # EC2 instance type is m5a.16xlarge.
  M5A_16XLARGE

  # EC2 instance type is m5a.24xlarge.
  M5A_24XLARGE

  # EC2 instance type is m5a.2xlarge.
  M5A_2XLARGE

  # EC2 instance type is m5a.4xlarge.
  M5A_4XLARGE

  # EC2 instance type is m5a.8xlarge.
  M5A_8XLARGE

  # EC2 instance type is m5a.large.
  M5A_LARGE

  # EC2 instance type is m5a.xlarge.
  M5A_XLARGE

  # EC2 instance type is m5dn.12xlarge.
  M5DN_12XLARGE

  # EC2 instance type is m5dn.16xlarge.
  M5DN_16XLARGE

  # EC2 instance type is m5dn.24xlarge.
  M5DN_24XLARGE

  # EC2 instance type is m5dn.2xlarge.
  M5DN_2XLARGE

  # EC2 instance type is m5dn.4xlarge.
  M5DN_4XLARGE

  # EC2 instance type is m5dn.8xlarge.
  M5DN_8XLARGE

  # EC2 instance type is m5dn.large.
  M5DN_LARGE

  # EC2 instance type is m5dn.xlarge.
  M5DN_XLARGE

  # EC2 instance type is m5d.12xlarge.
  M5D_12XLARGE

  # EC2 instance type is m5d.16xlarge.
  M5D_16XLARGE

  # EC2 instance type is m5d.24xlarge.
  M5D_24XLARGE

  # EC2 instance type is m5d.2xlarge.
  M5D_2XLARGE

  # EC2 instance type is m5d.4xlarge.
  M5D_4XLARGE

  # EC2 instance type is m5d.8xlarge.
  M5D_8XLARGE

  # EC2 instance type is m5d.large.
  M5D_LARGE

  # EC2 instance type is m5d.metal.
  M5D_METAL

  # EC2 instance type is m5d.xlarge.
  M5D_XLARGE

  # EC2 instance type is m5n.12xlarge.
  M5N_12XLARGE

  # EC2 instance type is m5n.16xlarge.
  M5N_16XLARGE

  # EC2 instance type is m5n.24xlarge.
  M5N_24XLARGE

  # EC2 instance type is m5n.2xlarge.
  M5N_2XLARGE

  # EC2 instance type is m5n.4xlarge.
  M5N_4XLARGE

  # EC2 instance type is m5n.8xlarge.
  M5N_8XLARGE

  # EC2 instance type is m5n.large.
  M5N_LARGE

  # EC2 instance type is m5n.xlarge.
  M5N_XLARGE

  # EC2 instance type is m5.12xlarge.
  M5_12XLARGE

  # EC2 instance type is m5.16xlarge.
  M5_16XLARGE

  # EC2 instance type is m5.24xlarge.
  M5_24XLARGE

  # EC2 instance type is m5.2xlarge.
  M5_2XLARGE

  # EC2 instance type is m5.4xlarge.
  M5_4XLARGE

  # EC2 instance type is m5.8xlarge.
  M5_8XLARGE

  # EC2 instance type is m5.large.
  M5_LARGE

  # EC2 instance type is m5.metal.
  M5_METAL

  # EC2 instance type is m5.xlarge.
  M5_XLARGE

  # EC2 instance type is not specified.
  NOT_SPECIFIED

  # EC2 instance type is p2.16xlarge.
  P2_16XLARGE

  # EC2 instance type is p2.8xlarge.
  P2_8XLARGE

  # EC2 instance type is p2.xlarge.
  P2_XLARGE

  # EC2 instance type is p3dn.24xlarge.
  P3DN_24XLARGE

  # EC2 instance type is p3.16xlarge.
  P3_16XLARGE

  # EC2 instance type is p3.2xlarge.
  P3_2XLARGE

  # EC2 instance type is p3.8xlarge.
  P3_8XLARGE

  # EC2 instance type is r3.2xlarge.
  R3_2XLARGE

  # EC2 instance type is r3.4xlarge.
  R3_4XLARGE

  # EC2 instance type is r3.8xlarge.
  R3_8XLARGE

  # EC2 instance type is r3.large.
  R3_LARGE

  # EC2 instance type is r3.xlarge.
  R3_XLARGE

  # EC2 instance type is r4.16xlarge.
  R4_16XLARGE

  # EC2 instance type is r4.2xlarge.
  R4_2XLARGE

  # EC2 instance type is r4.4xlarge.
  R4_4XLARGE

  # EC2 instance type is r4.8xlarge.
  R4_8XLARGE

  # EC2 instance type is r4.large.
  R4_LARGE

  # EC2 instance type is r4.xlarge.
  R4_XLARGE

  # EC2 instance type is r5ad.12xlarge.
  R5AD_12XLARGE

  # EC2 instance type is r5ad.16xlarge.
  R5AD_16XLARGE

  # EC2 instance type is r5ad.24xlarge.
  R5AD_24XLARGE

  # EC2 instance type is r5ad.2xlarge.
  R5AD_2XLARGE

  # EC2 instance type is r5ad.4xlarge.
  R5AD_4XLARGE

  # EC2 instance type is r5ad.8xlarge.
  R5AD_8XLARGE

  # EC2 instance type is r5ad.large.
  R5AD_LARGE

  # EC2 instance type is r5ad.xlarge.
  R5AD_XLARGE

  # EC2 instance type is r5a.12xlarge.
  R5A_12XLARGE

  # EC2 instance type is r5a.16xlarge.
  R5A_16XLARGE

  # EC2 instance type is r5a.24xlarge.
  R5A_24XLARGE

  # EC2 instance type is r5a.2xlarge.
  R5A_2XLARGE

  # EC2 instance type is r5a.4xlarge.
  R5A_4XLARGE

  # EC2 instance type is r5a.8xlarge.
  R5A_8XLARGE

  # EC2 instance type is r5a.large.
  R5A_LARGE

  # EC2 instance type is r5a.xlarge.
  R5A_XLARGE

  # EC2 instance type is r5dn.12xlarge.
  R5DN_12XLARGE

  # EC2 instance type is r5dn.16xlarge.
  R5DN_16XLARGE

  # EC2 instance type is r5dn.24xlarge.
  R5DN_24XLARGE

  # EC2 instance type is r5dn.2xlarge.
  R5DN_2XLARGE

  # EC2 instance type is r5dn.4xlarge.
  R5DN_4XLARGE

  # EC2 instance type is r5dn.8xlarge.
  R5DN_8XLARGE

  # EC2 instance type is r5dn.large.
  R5DN_LARGE

  # EC2 instance type is r5dn.xlarge.
  R5DN_XLARGE

  # EC2 instance type is r5d.12xlarge.
  R5D_12XLARGE

  # EC2 instance type is r5d.16xlarge.
  R5D_16XLARGE

  # EC2 instance type is r5d.24xlarge.
  R5D_24XLARGE

  # EC2 instance type is r5d.2xlarge.
  R5D_2XLARGE

  # EC2 instance type is r5d.4xlarge.
  R5D_4XLARGE

  # EC2 instance type is r5d.8xlarge.
  R5D_8XLARGE

  # EC2 instance type is r5d.large.
  R5D_LARGE

  # EC2 instance type is r5d.metal.
  R5D_METAL

  # EC2 instance type is r5d.xlarge.
  R5D_XLARGE

  # EC2 instance type is r5n.12xlarge.
  R5N_12XLARGE

  # EC2 instance type is r5n.16xlarge.
  R5N_16XLARGE

  # EC2 instance type is r5n.24xlarge.
  R5N_24XLARGE

  # EC2 instance type is r5n.2xlarge.
  R5N_2XLARGE

  # EC2 instance type is r5n.4xlarge.
  R5N_4XLARGE

  # EC2 instance type is r5n.8xlarge.
  R5N_8XLARGE

  # EC2 instance type is r5n.large.
  R5N_LARGE

  # EC2 instance type is r5n.xlarge.
  R5N_XLARGE

  # EC2 instance type is r5.12xlarge.
  R5_12XLARGE

  # EC2 instance type is r5.16xlarge.
  R5_16XLARGE

  # EC2 instance type is r5.24xlarge.
  R5_24XLARGE

  # EC2 instance type is r5.2xlarge.
  R5_2XLARGE

  # EC2 instance type is r5.4xlarge.
  R5_4XLARGE

  # EC2 instance type is r5.8xlarge.
  R5_8XLARGE

  # EC2 instance type is r5.large.
  R5_LARGE

  # EC2 instance type is r5.metal.
  R5_METAL

  # EC2 instance type is r5.xlarge.
  R5_XLARGE

  # EC2 instance type is t1.micro.
  T1_MICRO

  # EC2 instance type is t2.2xlarge.
  T2_2XLARGE

  # EC2 instance type is t2.large.
  T2_LARGE

  # EC2 instance type is t2.medium.
  T2_MEDIUM

  # EC2 instance type is t2.micro.
  T2_MICRO

  # EC2 instance type is t2.nano.
  T2_NANO

  # EC2 instance type is t2.small.
  T2_SMALL

  # EC2 instance type is t2.xlarge.
  T2_XLARGE

  # EC2 instance type is t3a.2xlarge.
  T3A_2XLARGE

  # EC2 instance type is t3a.large.
  T3A_LARGE

  # EC2 instance type is t3a.medium.
  T3A_MEDIUM

  # EC2 instance type is t3a.micro.
  T3A_MICRO

  # EC2 instance type is t3a.nano.
  T3A_NANO

  # EC2 instance type is t3a.small.
  T3A_SMALL

  # EC2 instance type is t3a.xlarge.
  T3A_XLARGE

  # EC2 instance type is t3.2xlarge.
  T3_2XLARGE

  # EC2 instance type is t3.large.
  T3_LARGE

  # EC2 instance type is t3.medium.
  T3_MEDIUM

  # EC2 instance type is t3.micro.
  T3_MICRO

  # EC2 instance type is t3.nano.
  T3_NANO

  # EC2 instance type is t3.small.
  T3_SMALL

  # EC2 instance type is t3.xlarge.
  T3_XLARGE

  # EC2 instance type is unknown.
  UNKNOWN

  # EC2 instance type is u-12tb1.metal.
  U_12TB1_METAL

  # EC2 instance type is u-18tb1.metal.
  U_18TB1_METAL

  # EC2 instance type is u-24tb1.metal.
  U_24TB1_METAL

  # EC2 instance type is u-6tb1.metal.
  U_6TB1_METAL

  # EC2 instance type is u-9tb1.metal.
  U_9TB1_METAL

  # EC2 instance type is x1e.16xlarge.
  X1E_16XLARGE

  # EC2 instance type is x1e.2xlarge.
  X1E_2XLARGE

  # EC2 instance type is x1e.32xlarge.
  X1E_32XLARGE

  # EC2 instance type is x1e.4xlarge.
  X1E_4XLARGE

  # EC2 instance type is x1e.8xlarge.
  X1E_8XLARGE

  # EC2 instance type is x1e.xlarge.
  X1E_XLARGE

  # EC2 instance type is x1.16xlarge.
  X1_16XLARGE

  # EC2 instance type is x1.32xlarge.
  X1_32XLARGE

  # EC2 instance type is z1d.12xlarge.
  Z1D_12XLARGE

  # EC2 instance type is z1d.2xlarge.
  Z1D_2XLARGE

  # EC2 instance type is z1d.3xlarge.
  Z1D_3XLARGE

  # EC2 instance type is z1d.6xlarge.
  Z1D_6XLARGE

  # EC2 instance type is z1d.large.
  Z1D_LARGE

  # EC2 instance type is z1d.metal.
  Z1D_METAL

  # EC2 instance type is z1d.xlarge.
  Z1D_XLARGE
}
# Filter to return AWS EC2 instances which have instance type in the given list of instance types.
input AwsNativeEc2InstanceTypeFilter {
  # List of EC2 instance types.
  ec2InstanceTypes: [AwsNativeEc2InstanceType!]!
}
# State of AWS native file recovery.
enum AwsNativeFileRecoveryStatus {
  # AWS native file recovery is disabled.
  DISABLED

  # AWS native file recovery is enabled.
  ENABLED

  # State of AWS native file recovery is not specified.
  NOT_SPECIFIED
}
# AWS native protection features.
enum AwsNativeProtectionFeature {
  # AWS native protection feature is EC2.
  EC2

  # AWS native protection feature is RDS.
  RDS
}
# DB engine of an RDS instance.
enum AwsNativeRdsDbEngine {
  # DB engine is MariaDB.
  MARIADB

  # DB engine is MySQL.
  MYSQL

  # DB engine is Oracle EE.
  ORACLE_EE

  # DB engine is Oracle SE.
  ORACLE_SE

  # DB engine is Oracle SE1.
  ORACLE_SE1

  # DB engine is Oracle SE2.
  ORACLE_SE2

  # DB engine is PostgreSQL.
  POSTGRES

  # DB engine is SQL Server EE.
  SQLSERVER_EE

  # DB engine is SQL Server EX.
  SQLSERVER_EX

  # DB engine is SQL Server SE.
  SQLSERVER_SE

  # DB engine is SQL Server Web.
  SQLSERVER_WEB

  # DB engine is unknown.
  UNKNOWN
}
# Filter to return AWS RDS instances which have database engine in the given list of database engines.
input AwsNativeRdsDbEngineFilter {
  # List of database engines.
  dbEngines: [AwsNativeRdsDbEngine!]!
}
# DB class of an RDS instance.
enum AwsNativeRdsDbInstanceClass {
  # DB class is db.m1.large.
  DB_M1_LARGE

  # DB class is db.m1.medium.
  DB_M1_MEDIUM

  # DB class is db.m1.small.
  DB_M1_SMALL

  # DB class is db.m1.xlarge.
  DB_M1_XLARGE

  # DB class is db.m2.2xlarge.
  DB_M2_2XLARGE

  # DB class is db.m2.4xlarge.
  DB_M2_4XLARGE

  # DB class is db.m2.xlarge.
  DB_M2_XLARGE

  # DB class is db.m3.2xlarge.
  DB_M3_2XLARGE

  # DB class is db.m3.large.
  DB_M3_LARGE

  # DB class is db.m3.medium.
  DB_M3_MEDIUM

  # DB class is db.m3.xlarge.
  DB_M3_XLARGE

  # DB class is db.m4.10xlarge.
  DB_M4_10XLARGE

  # DB class is db.m4.16xlarge.
  DB_M4_16XLARGE

  # DB class is db.m4.2xlarge.
  DB_M4_2XLARGE

  # DB class is db.m4.4xlarge.
  DB_M4_4XLARGE

  # DB class is db.m4.large.
  DB_M4_LARGE

  # DB class is db.m4.xlarge.
  DB_M4_XLARGE

  # DB class is db.m5d.12xlarge.
  DB_M5D_12XLARGE

  # DB class is db.m5d.16xlarge.
  DB_M5D_16XLARGE

  # DB class is db.m5d.24xlarge.
  DB_M5D_24XLARGE

  # DB class is db.m5d.2xlarge.
  DB_M5D_2XLARGE

  # DB class is db.m5d.4xlarge.
  DB_M5D_4XLARGE

  # DB class is db.m5d.8xlarge.
  DB_M5D_8XLARGE

  # DB class is db.m5d.large.
  DB_M5D_LARGE

  # DB class is db.m5d.xlarge.
  DB_M5D_XLARGE

  # DB class is db.m5.12xlarge.
  DB_M5_12XLARGE

  # DB class is db.m5.16xlarge.
  DB_M5_16XLARGE

  # DB class is db.m5.24xlarge.
  DB_M5_24XLARGE

  # DB class is db.m5.2xlarge.
  DB_M5_2XLARGE

  # DB class is db.m5.4xlarge.
  DB_M5_4XLARGE

  # DB class is db.m5.8xlarge.
  DB_M5_8XLARGE

  # DB class is db.m5.large.
  DB_M5_LARGE

  # DB class is db.m5.xlarge.
  DB_M5_XLARGE

  # DB class is db.m6gd.12xlarge.
  DB_M6GD_12XLARGE

  # DB class is db.m6gd.16xlarge.
  DB_M6GD_16XLARGE

  # DB class is db.m6gd.2xlarge.
  DB_M6GD_2XLARGE

  # DB class is db.m6gd.4xlarge.
  DB_M6GD_4XLARGE

  # DB class is db.m6gd.8xlarge.
  DB_M6GD_8XLARGE

  # DB class is db.m6gd.large.
  DB_M6GD_LARGE

  # DB class is db.m6gd.xlarge.
  DB_M6GD_XLARGE

  # DB class is db.m6g.12xlarge.
  DB_M6G_12XLARGE

  # DB class is db.m6g.16xlarge.
  DB_M6G_16XLARGE

  # DB class is db.m6g.2xlarge.
  DB_M6G_2XLARGE

  # DB class is db.m6g.4xlarge.
  DB_M6G_4XLARGE

  # DB class is db.m6g.8xlarge.
  DB_M6G_8XLARGE

  # DB class is db.m6g.large.
  DB_M6G_LARGE

  # DB class is db.m6g.xlarge.
  DB_M6G_XLARGE

  # DB class is db.r3.2xlarge.
  DB_R3_2XLARGE

  # DB class is db.r3.4xlarge.
  DB_R3_4XLARGE

  # DB class is db.r3.8xlarge.
  DB_R3_8XLARGE

  # DB class is db.r3.large.
  DB_R3_LARGE

  # DB class is db.r3.xlarge.
  DB_R3_XLARGE

  # DB class is db.r4.12xlarge.
  DB_R4_12XLARGE

  # DB class is db.r4.16xlarge.
  DB_R4_16XLARGE

  # DB class is db.r4.2xlarge.
  DB_R4_2XLARGE

  # DB class is db.r4.4xlarge.
  DB_R4_4XLARGE

  # DB class is db.r4.8xlarge.
  DB_R4_8XLARGE

  # DB class is db.r4.large.
  DB_R4_LARGE

  # DB class is db.r4.xlarge.
  DB_R4_XLARGE

  # DB class is db.r5b.12xlarge.
  DB_R5B_12XLARGE

  # DB class is db.r5b.16xlarge.
  DB_R5B_16XLARGE

  # DB class is db.r5b.24xlarge.
  DB_R5B_24XLARGE

  # DB class is db.r5b.2xlarge.
  DB_R5B_2XLARGE

  # DB class is db.r5b.4xlarge.
  DB_R5B_4XLARGE

  # DB class is db.r5b.8xlarge.
  DB_R5B_8XLARGE

  # DB class is db.r5b.large.
  DB_R5B_LARGE

  # DB class is db.r5b.xlarge.
  DB_R5B_XLARGE

  # DB class is db.r5d.12xlarge.
  DB_R5D_12XLARGE

  # DB class is db.r5d.16xlarge.
  DB_R5D_16XLARGE

  # DB class is db.r5d.24xlarge.
  DB_R5D_24XLARGE

  # DB class is db.r5d.2xlarge.
  DB_R5D_2XLARGE

  # DB class is db.r5d.4xlarge.
  DB_R5D_4XLARGE

  # DB class is db.r5d.8xlarge.
  DB_R5D_8XLARGE

  # DB class is db.r5d.large.
  DB_R5D_LARGE

  # DB class is db.r5d.xlarge.
  DB_R5D_XLARGE

  # DB class is db.r5.12xlarge.
  DB_R5_12XLARGE

  # DB class is db.r5.16xlarge.
  DB_R5_16XLARGE

  # DB class is db.r5.24xlarge.
  DB_R5_24XLARGE

  # DB class is db.r5.2xlarge.
  DB_R5_2XLARGE

  # DB class is db.r5.4xlarge.
  DB_R5_4XLARGE

  # DB class is db.r5.8xlarge.
  DB_R5_8XLARGE

  # DB class is db.r5.large.
  DB_R5_LARGE

  # DB class is db.r5.xlarge.
  DB_R5_XLARGE

  # DB class is db.r6g.12xlarge.
  DB_R6G_12XLARGE

  # DB class is db.r6g.16xlarge.
  DB_R6G_16XLARGE

  # DB class is db.r6g.2xlarge.
  DB_R6G_2XLARGE

  # DB class is db.r6g.4xlarge.
  DB_R6G_4XLARGE

  # DB class is db.r6g.8xlarge.
  DB_R6G_8XLARGE

  # DB class is db.r6g.large.
  DB_R6G_LARGE

  # DB class is db.r6g.xlarge.
  DB_R6G_XLARGE

  # DB class is db.t2.2xlarge.
  DB_T2_2XLARGE

  # DB class is db.t2.large.
  DB_T2_LARGE

  # DB class is db.t2.medium.
  DB_T2_MEDIUM

  # DB class is db.t2.micro.
  DB_T2_MICRO

  # DB class is db.t2.small.
  DB_T2_SMALL

  # DB class is db.t2.xlarge.
  DB_T2_XLARGE

  # DB class is db.t3.2xlarge.
  DB_T3_2XLARGE

  # DB class is db.t3.large.
  DB_T3_LARGE

  # DB class is db.t3.medium.
  DB_T3_MEDIUM

  # DB class is db.t3.micro.
  DB_T3_MICRO

  # DB class is db.t3.small.
  DB_T3_SMALL

  # DB class is db.t3.xlarge.
  DB_T3_XLARGE

  # DB class is db.t4g.2xlarge.
  DB_T4G_2XLARGE

  # DB class is db.t4g.large.
  DB_T4G_LARGE

  # DB class is db.t4g.medium.
  DB_T4G_MEDIUM

  # DB class is db.t4g.micro.
  DB_T4G_MICRO

  # DB class is db.t4g.small.
  DB_T4G_SMALL

  # DB class is db.t4g.xlarge.
  DB_T4G_XLARGE

  # DB class is db.x1e.16xlarge.
  DB_X1E_16XLARGE

  # DB class is db.x1e.2xlarge.
  DB_X1E_2XLARGE

  # DB class is db.x1e.32xlarge.
  DB_X1E_32XLARGE

  # DB class is db.x1e.4xlarge.
  DB_X1E_4XLARGE

  # DB class is db.x1e.8xlarge.
  DB_X1E_8XLARGE

  # DB class is db.x1e.xlarge.
  DB_X1E_XLARGE

  # DB class is db.x1.16xlarge.
  DB_X1_16XLARGE

  # DB class is db.x1.32xlarge.
  DB_X1_32XLARGE

  # DB class is db.x2g.12xlarge.
  DB_X2G_12XLARGE

  # DB class is db.x2g.16xlarge.
  DB_X2G_16XLARGE

  # DB class is db.x2g.2xlarge.
  DB_X2G_2XLARGE

  # DB class is db.x2g.4xlarge.
  DB_X2G_4XLARGE

  # DB class is db.x2g.8xlarge.
  DB_X2G_8XLARGE

  # DB class is db.x2g.large.
  DB_X2G_LARGE

  # DB class is db.x2g.medium.
  DB_X2G_MEDIUM

  # DB class is db.x2g.xlarge.
  DB_X2G_XLARGE

  # DB class is db.z1d.12xlarge.
  DB_Z1D_12XLARGE

  # DB class is db.z1d.2xlarge.
  DB_Z1D_2XLARGE

  # DB class is db.z1d.4xlarge.
  DB_Z1D_4XLARGE

  # DB class is db.z1d.6xlarge.
  DB_Z1D_6XLARGE

  # DB class is db.z1d.large.
  DB_Z1D_LARGE

  # DB class is db.z1d.xlarge.
  DB_Z1D_XLARGE

  # DB class is unknown.
  UNKNOWN
}
# Filter to return AWS RDS instances which have database instance class in the given list of database instance classes.
input AwsNativeRdsDbInstanceClassFilter {
  # List of database instance classes.
  dbInstanceClasses: [AwsNativeRdsDbInstanceClass!]!
}
# AWS native RDS instance.
type AwsNativeRdsInstance implements PolarisHierarchyObject , PolarisHierarchySnappable , HierarchyObject , AwsNativeAccountLogicalChildType , AwsNativeAccountDescendantType {
  # Name of RDS Instance.
  dbInstanceName: String!

  # Resource identifier of RDS Instance.
  dbiResourceId: String!

  # AWS region of RDS Instance.
  region: AwsNativeRegion!

  # List of tags associated with RDS Instance.
  tags: [Tag!]!

  # Specifies whether the RDS Instance is a relic.
  isRelic: Boolean!

  # Rubrik Identifier for account associated with RDS Instance.
  awsAccountRubrikId: String!

  # Class type of RDS Instance.
  dbInstanceClass: AwsNativeRdsDbInstanceClass!

  # Name of Availability Zone(AZ) associated with RDS Instance.
  primaryAvailabilityZone: String!

  # Identifies if the RDS Instance is part of multiple Availability Zones.
  isMultiAz: Boolean!

  # Allocated size of RDS Instance in GiB.
  allocatedStorageInGibi: Long!

  # Engine being used for RDS Instance.
  dbEngine: AwsNativeRdsDbEngine!

  # Identifier of VPC associated with RDS Instance.
  vpcId: String!

  # Name of VPC associated with RDS Instance.
  vpcName: String!

  # Maintenance window of RDS Instance.
  maintenanceWindow: String!

  # Name of the source RDS instance if this instance is a read replica. This field is not applicable for primary RDS instances.
  readReplicaSourceName: String!

  # The authorized operations on the object.
  authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!

  # AWS account of the Amazon Relational Database Service (RDS) instance.
  awsNativeAccount: AwsNativeAccount!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!

  # The list of snapshots taken for this workload.
  snapshotConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Sort Polaris snapshots by field.
    sortBy: PolarisSnapshotSortByEnum = Date,

    # Sort order.
    sortOrder: SortOrderEnum): PolarisSnapshotConnection

  # The list of snapshots taken for this workload.
  snapshotsOfSnappableConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String, snappableId: String!,

    # Filter for snapshot connection.
    snapshotFilter: [SnapshotQueryFilterInput!],

    # Sort order.
    sortOrder: SortOrderEnum, sortBy: SnapshotQuerySortByField,

    # Time range input.
    timeRange: TimeRangeInput,

    # Specifies whether to ignore the active protected object check.
    ignoreActiveSnappableCheck: Boolean): GenericSnapshotConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Group Polaris snapshots by field.
    groupBy: PolarisSnapshotGroupByEnum!): PolarisSnapshotGroupByConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByNewConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    snapshotFilter: [PolarisSnapshotFilterNewInput!]!,

    # Group Polaris snapshots by field.
    snapshotGroupBy: SnapshotGroupByTimeEnum!): PolarisSnapshotGroupByNewConnection

  # The most recent snapshot of this workload.
  newestSnapshot: PolarisSnapshot

  # The oldest snapshot of this workload.
  oldestSnapshot: PolarisSnapshot

  # The number of on-demand snapshots.
  onDemandSnapshotCount: Int!

  # The newest snapshot that is indexed and unexpired, and therefore restorable.
  newestIndexedSnapshot: PolarisSnapshot
}
# Paginated list of AwsNativeRdsInstance objects.
type AwsNativeRdsInstanceConnection {
  # List of AwsNativeRdsInstance objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [AwsNativeRdsInstanceEdge!]!

  # List of AwsNativeRdsInstance objects.
  nodes: [AwsNativeRdsInstance!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of AwsNativeRdsInstance objects matching the request arguments.
  count: Int!
}
# Wrapper around the AwsNativeRdsInstance object. This wrapper is used for pagination.
type AwsNativeRdsInstanceEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual AwsNativeRdsInstance object wrapped by this edge.
  node: AwsNativeRdsInstance!
}
# Filters for list of AWS RDS instances.
input AwsNativeRdsInstanceFilters {
  # Filter by name substring.
  nameSubstringFilter: NameSubstringFilter

  # Filter by effective SLA Domain.
  effectiveSlaFilter: EffectiveSlaFilter

  # Filter by AWS account.
  accountFilter: AwsNativeAccountFilter

  # Filter by VPC.
  vpcFilter: AwsNativeVpcFilter

  # Filter by relic status.
  relicFilter: RelicFilter

  # Filter by tags.
  tagFilter: AwsNativeTagFilter

  # Filter by region.
  regionFilter: AwsNativeRegionFilter

  # Filter by database engine.
  dbEngineFilter: AwsNativeRdsDbEngineFilter

  # Filter by database instance class.
  dbInstanceClassFilter: AwsNativeRdsDbInstanceClassFilter
}
# The field type used to sort the RDS instances.
enum AwsNativeRdsInstanceSortFields {
  # Use SLA Domain assignment for sorting.
  ASSIGNED_SLA_DOMAIN

  # Use AWS account name for sorting.
  AWS_NATIVE_ACCOUNT_NAME

  # Use DB engine of RDS instance for sorting.
  AWS_NATIVE_RDS_DB_ENGINE

  # Use DB class of RDS instance for sorting.
  AWS_NATIVE_RDS_DB_INSTANCE_CLASS

  # Use VPC ID for sorting.
  AWS_VPC_ID

  # Use RDS instance SLA Domain for sorting.
  EFFECTIVE_SLA_DOMAIN

  # Use RDS instance name for sorting.
  NAME
}
# The Point-in-Time (PiT) restore window of the RDS Instance.
type AwsNativeRdsPointInTimeRestoreWindow {
  # The earliest time to which RDS Instance can be restored.
  earliestTime: DateTime

  # The latest time to which RDS Instance can be restored.
  latestTime: DateTime
}
# The storage type of an RDS instance.
enum AwsNativeRdsStorageType {
  # Storage type is gp2.
  GP2

  # Storage type is io1.
  IO1

  # Storage type is not specified.
  NOT_SPECIFIED

  # Storage type is standard.
  STANDARD

  # Storage type is unknown.
  UNKNOWN
}
# AWS native regions.
enum AwsNativeRegion {
  # AWS native Africa (Cape Town) region.
  AF_SOUTH_1

  # AWS native Asia Pacific (Hong Kong) region.
  AP_EAST_1

  # AWS native Asia Pacific (Tokyo) region.
  AP_NORTHEAST_1

  # AWS native Asia Pacific (Seoul) region.
  AP_NORTHEAST_2

  # AWS native Asia Pacific (Singapore) region.
  AP_SOUTHEAST_1

  # AWS native Asia Pacific (Sydney) region.
  AP_SOUTHEAST_2

  # AWS native Asia Pacific (Mumbai) region.
  AP_SOUTH_1

  # AWS native Canada (Central) region.
  CA_CENTRAL_1

  # AWS native China (Ningxia) region.
  CN_NORTHWEST_1

  # AWS native China (Beijing) region.
  CN_NORTH_1

  # AWS native EU (Frankfurt) region.
  EU_CENTRAL_1

  # AWS native EU (Stockholm) region.
  EU_NORTH_1

  # AWS native EU (Milan) region.
  EU_SOUTH_1

  # AWS native EU (Ireland) region.
  EU_WEST_1

  # AWS native EU (London) region.
  EU_WEST_2

  # AWS native EU (Paris) region.
  EU_WEST_3

  # AWS native Middle East (Bahrain) region.
  ME_SOUTH_1

  # AWS native region is not specified.
  NOT_SPECIFIED

  # AWS native South America (Sao Paulo) region.
  SA_EAST_1

  # AWS native US East (N. Virginia) region.
  US_EAST_1

  # AWS native US East (Ohio) region.
  US_EAST_2

  # AWS Gov native US East 1 (N. Virginia) region.
  US_GOV_EAST_1

  # AWS Gov native US West 1 (N. California) region.
  US_GOV_WEST_1

  # AWS LCK native US East region.
  US_ISOB_EAST_1

  # AWS DCA native US East region.
  US_ISO_EAST_1

  # AWS DCA native US West region.
  US_ISO_WEST_1

  # AWS native US West (N. California) region.
  US_WEST_1

  # AWS native US West (Oregon) region.
  US_WEST_2
}
# Filter to return AWS objects which have region in the given list of regions.
input AwsNativeRegionFilter {
  # List of regions.
  regions: [AwsNativeRegion!]!
}
# AWS native regions for replication.
enum AwsNativeRegionForReplication {
  # AWS native for replication Africa (Cape Town) region.
  AF_SOUTH_1

  # AWS native for replication Asia Pacific (Hong Kong) region.
  AP_EAST_1

  # AWS native for replication Asia Pacific (Tokyo) region.
  AP_NORTHEAST_1

  # AWS native for replication Asia Pacific (Seoul) region.
  AP_NORTHEAST_2

  # AWS native for replication Asia Pacific (Singapore) region.
  AP_SOUTHEAST_1

  # AWS native for replication Asia Pacific (Sydney) region.
  AP_SOUTHEAST_2

  # AWS native for replication Asia Pacific (Mumbai) region.
  AP_SOUTH_1

  # AWS native for replication Canada (Central) region.
  CA_CENTRAL_1

  # AWS native for replication China (Ningxia) region.
  CN_NORTHWEST_1

  # AWS native for replication China (Beijing) region.
  CN_NORTH_1

  # AWS native for replication EU (Frankfurt) region.
  EU_CENTRAL_1

  # AWS native for replication EU (Stockholm) region.
  EU_NORTH_1

  # AWS native for replication EU (Milan) region.
  EU_SOUTH_1

  # AWS native for replication EU (Ireland) region.
  EU_WEST_1

  # AWS native for replication EU (London) region.
  EU_WEST_2

  # AWS native for replication EU (Paris) region.
  EU_WEST_3

  # AWS native for replication Middle East (Bahrain) region.
  ME_SOUTH_1

  # AWS native for replication region is not defined.
  NOT_DEFINED

  # AWS native for replication South America (Sao Paulo) region.
  SA_EAST_1

  # AWS native for replication region is the source region.
  SOURCE_REGION

  # AWS native for replication US East (N. Virginia) region.
  US_EAST_1

  # AWS native for replication US East (Ohio) region.
  US_EAST_2

  # AWS Gov native for replication US East 1 (N. Virginia) region.
  US_GOV_EAST_1

  # AWS Gov native for replication US West 1 (N. California) region.
  US_GOV_WEST_1

  # AWS LCK native for replication US East region.
  US_ISOB_EAST_1

  # AWS DCA native for replication US East region.
  US_ISO_EAST_1

  # AWS DCA native for replication US West region.
  US_ISO_WEST_1

  # AWS native for replication US West (N. California) region.
  US_WEST_1

  # AWS native for replication US West (Oregon) region.
  US_WEST_2
}
# List of AWS region specifications associated with an AWS account.
type AwsNativeRegionSpec {
  # Name of the AWS region.
  region: AwsNativeRegion!

  # A boolean specifying whether exocompute is configured in the region or not.
  isExocomputeConfigured: Boolean!
}
# Represents a subnet in AWS.
type AwsNativeSubnet {
  # ID of the subnet.
  id: String!

  # Name of the subnet.
  name: String!

  # Availability Zone corresponding to the subnet.
  availabilityZone: String!
}
# Filter to return AWS objects which have at least one tag in the given list of tags.
input AwsNativeTagFilter {
  # Tag filter parameters.
  tagFilterParams: [TagFilterParams!]!
}
# Filter to return AWS EC2 instances which have VPC ID in the given list of VPC IDs.
input AwsNativeVpcFilter {
  # Virtual Private Cloud (VPC) IDs to filter.
  vpcIds: [String!]!
}
# The SLA Domain configuration for AWS RDS instances.
type AwsRdsConfig {
  # Specifies the duration for which the logs will be retained. This duration determines the earliest time to which a Point-in-Time recovery can be performed on the associated RDS instances.
  logRetention: Duration
}
# Regions for AWS.
enum AwsRegion {
  # AWS Africa (Cape Town) region.
  AF_SOUTH_1

  # AWS Asia Pacific (Hong Kong) region.
  AP_EAST_1

  # AWS Asia Pacific (Tokyo) region.
  AP_NORTHEAST_1

  # AWS Asia Pacific (Seoul) region.
  AP_NORTHEAST_2

  # AWS Asia Pacific (Seoul) region.
  AP_NORTHEAST_3

  # AWS Asia Pacific (Singapore) region.
  AP_SOUTHEAST_1

  # AWS Asia Pacific (Sydney) region.
  AP_SOUTHEAST_2

  # AWS Asia Pacific (Mumbai) region.
  AP_SOUTH_1

  # AWS Canada (Central) region.
  CA_CENTRAL_1

  # AWS China (Ningxia) region.
  CN_NORTHWEST_1

  # AWS China (Beijing) region.
  CN_NORTH_1

  # AWS EU (Frankfurt) region.
  EU_CENTRAL_1

  # AWS EU (Milan) region.
  EU_SOUTH_1

  # AWS EU (Ireland) region.
  EU_WEST_1

  # AWS EU (London) region.
  EU_WEST_2

  # AWS EU (Paris) region.
  EU_WEST_3

  # AWS Middle East (Bahrain) region.
  ME_SOUTH_1

  # AWS South America (Sao Paulo) region.
  SA_EAST_1

  # AWS region is unknown.
  UNKNOWN_AWS_REGION

  # AWS US East (N. Virginia) region.
  US_EAST_1

  # AWS US East (Ohio) region.
  US_EAST_2

  # AWS Cloud for Government US East 1 (North Virginia) region.
  US_GOV_EAST_1

  # AWS Cloud for Government US West 1 (North California) region.
  US_GOV_WEST_1

  # AWS US West (N. California) region.
  US_WEST_1

  # AWS US West (Oregon) region.
  US_WEST_2
}
# AWS Replication target.
type AwsReplicationTarget {
  # AWS account ID.
  accountId: String!

  # AWS account name.
  accountName: String!
  region: AwsNativeRegionForReplication!
}
# AWS retrieval tier.
enum AwsRetrievalTier {
  # Bulk AWS retrieval tier.
  BULK_TIER

  # Expedited AWS retrieval tier.
  EXPEDITED_TIER

  # Standard AWS retrieval tier.
  STANDARD_TIER
}
# AWS role based Account specific info.
type AwsRoleBasedAccount implements CloudAccount {
  awsSpecificInfo: AwsCloudAccountWithFeatures!

  # The ID of this Cloud Account.
  cloudAccountId: String!

  # The name of this Cloud Account.
  name: String!

  # The description of this Cloud Account.
  description: String

  # The type of this Cloud Provider.
  cloudProvider: CloudAccountType!

  # The connection status of this Cloud Account.
  connectionStatus: ConnectionStatusType!
}
# A Security group in AWS realm.
type AwsSecurityGroup {
  # ID of the AWS security group.
  id: String!

  # Name of the AWS security group.
  name: String!
}
# Storage class for AWS type location.
enum AwsStorageClassTypeEnum {
  # One Zone-IA AWS storage class.
  ONEZONE_IA

  # Standard AWS storage class.
  STANDARD

  # Standard-IA AWS storage class.
  STANDARD_IA

  # Unknown AWS storage class.
  UNKNOWN_STORAGE_CLASS
}
# A Subnet in AWS realm.
type AwsSubnet {
  # ID of the subnet.
  id: String!

  # Name of the subnet.
  name: String!

  # Availability zone in which the subnet resides.
  availabilityZone: String!
}
# Specific info for AWS Target Template.
type AwsTargetTemplate implements TargetTemplate {
  bucketPrefix: String!
  region: AwsRegion!
  storageClass: AwsStorageClassTypeEnum!
  computeSettings: AwsComputeSettings
  proxySettings: ProxySettings
  encryptionType: TargetEncryptionTypeEnum!
  kmsMasterKeyId: String
  isConsolidationEnabled: Boolean!
  cloudNativeLocTemplateType: CloudNativeLocTemplateType!
  bucketTags: [TagObject!]!
  cloudAccount: CloudAccount!

  # The type of this Target.
  targetType: TargetTypeEnum!
}
# A Virtual Private Cloud (VPC) in AWS realm.
type AwsVpc {
  # ID for the VPC.
  id: String!

  # Name of the VPC.
  name: String!

  # List of subnets associated with the VPC.
  subnets: [AwsSubnet!]!

  # List of security groups associated with the VPC.
  securityGroups: [AwsSecurityGroup!]!
}
# Azure Account specific info.
type AzureAccount implements CloudAccount {
  # The native ID of the subscription.
  subscriptionId: String!

  # The native ID of the tenant of the subscription.
  tenantId: String!

  # The ID of this Cloud Account.
  cloudAccountId: String!

  # The name of this Cloud Account.
  name: String!

  # The description of this Cloud Account.
  description: String

  # The type of this Cloud Provider.
  cloudProvider: CloudAccountType!

  # The connection status of this Cloud Account.
  connectionStatus: ConnectionStatusType!
}
# Azure Cloud Account Feature details.
type AzureCloudAccountFeatureDetail {
  # Cloud Account feature. A feature refers to a Polaris cloud protection feature that Rubrik provides. For example: VM and Disk Protection, Storage, Exocompute, etc.
  feature: CloudAccountFeature!

  # Specifies the state of an Azure cloud account in Rubrik environment. For example, Refreshed, Disconnected, etc. A cloud account can only be in one state at a time.
  status: CloudAccountStatus!

  # Azure regions.
  regions: [AzureCloudAccountRegion!]!

  # User assigned managed identity for encryption feature. It is null for features other than Cloud Native Archival Encryption.
  userAssignedManagedIdentity: AzureUserAssignedManagedIdentity

  # Persistent storage configured for the feature. It is null for features other than Azure SQL DB and Azure SQL MI.
  persistentStorage: PersistentStorage

  # Resource group for the feature.
  resourceGroup: AzureResourceGroup!
}
# Configuration consisting of role permissions and feature policy version required for Azure subscription setup. Features refer to the Polaris features that the customer wants to be enabled on the cloud account.
type AzureCloudAccountPermissionConfigResponse {
  # Policy permission version to be used on Polaris for adding a subscription.
  permissionVersion: Int!

  # List of permissions to be applied on the role created in Azure for a subscription.
  rolePermissions: [AzureCloudAccountRolePermission!]!
}
# Azure cloud account region Enum.
enum AzureCloudAccountRegion {
  # Azure Cloud account region is Australia Central.
  AUSTRALIACENTRAL

  # Azure Cloud account region is Australia Central 2.
  AUSTRALIACENTRAL2

  # Azure Cloud account region is Australia East.
  AUSTRALIAEAST

  # Azure Cloud account region is Australia Southeast.
  AUSTRALIASOUTHEAST

  # Azure Cloud account region is Brazil South.
  BRAZILSOUTH

  # Azure Cloud account region is Canada Central.
  CANADACENTRAL

  # Azure Cloud account region is Canada East.
  CANADAEAST

  # Azure Cloud account region is Central India.
  CENTRALINDIA

  # Azure Cloud account region is Central US.
  CENTRALUS

  # Azure Cloud account region is China East.
  CHINAEAST

  # Azure Cloud account region is China East 2.
  CHINAEAST2

  # Azure Cloud account region is China North.
  CHINANORTH

  # Azure Cloud account region is China North 2.
  CHINANORTH2

  # Azure Cloud account region is East Asia.
  EASTASIA

  # Azure Cloud account region is East US.
  EASTUS

  # Azure Cloud account region is East US 2.
  EASTUS2

  # Azure Cloud account region is France Central.
  FRANCECENTRAL

  # Azure Cloud account region is France South.
  FRANCESOUTH

  # Azure Cloud account region is Germany North.
  GERMANYNORTH

  # Azure Cloud account region is Germany West Central.
  GERMANYWESTCENTRAL

  # Azure Cloud account region is Japan East.
  JAPANEAST

  # Azure Cloud account region is Japan West.
  JAPANWEST

  # Azure Cloud account region is Korea Central.
  KOREACENTRAL

  # Azure Cloud account region is Korea South.
  KOREASOUTH

  # Azure Cloud account region is North Central US.
  NORTHCENTRALUS

  # Azure Cloud account region is North Europe.
  NORTHEUROPE

  # Azure Cloud account region is Norway East.
  NORWAYEAST

  # Azure Cloud account region is Norway West.
  NORWAYWEST

  # Azure Cloud account region is South Africa North.
  SOUTHAFRICANORTH

  # Azure Cloud account region is South Africa West.
  SOUTHAFRICAWEST

  # Azure Cloud account region is South Central US.
  SOUTHCENTRALUS

  # Azure Cloud account region is South East Asia.
  SOUTHEASTASIA

  # Azure Cloud account region is South India.
  SOUTHINDIA

  # Azure Cloud account region is Switzerland North.
  SWITZERLANDNORTH

  # Azure Cloud account region is Switzerland West.
  SWITZERLANDWEST

  # Azure Cloud account region is UAE Central.
  UAECENTRAL

  # Azure Cloud account region is UAE North.
  UAENORTH

  # Azure Cloud account region is UK South.
  UKSOUTH

  # Azure Cloud account region is UK West.
  UKWEST

  # Azure Cloud account region is Unknown.
  UNKNOWN_AZURE_REGION

  # Azure Cloud account region is US Gov Arizona.
  USGOVARIZONA

  # Azure Cloud account region is US Gov Texas.
  USGOVTEXAS

  # Azure Cloud account region is US Gov Virginia.
  USGOVVIRGINIA

  # Azure Cloud account region is West Central US.
  WESTCENTRALUS

  # Azure Cloud account region is West Europe.
  WESTEUROPE

  # Azure Cloud account region is West India.
  WESTINDIA

  # Azure Cloud account region is West US.
  WESTUS

  # Azure Cloud account region is West US 2.
  WESTUS2

  # Azure Cloud account region is West US 3.
  WESTUS3
}
# Azure Permission type with included and excluded actions.
type AzureCloudAccountRolePermission {
  # Actions which should be allowed on the Azure role for the subscription.
  includedActions: [String!]!

  # Actions which should be explicitly disallowed on the Azure role for the subscription.
  excludedActions: [String!]!

  # Data actions which should be allowed on the Azure role for the subscription.
  includedDataActions: [String!]!

  # Data actions which should be explicitly disallowed on the Azure role for the subscription.
  excludedDataActions: [String!]!
}
# Azure Cloud Account Subscription for a given feature.
type AzureCloudAccountSubscription {
  # Subscription UUID as specified in Azure.
  nativeId: String!

  # Subscription name as specified in Azure.
  name: String!

  # Specifies whether the requester has appropriate permissions on this subscription.
  isAuthorized: Boolean!

  # Cloud account ID of the subscription.
  customerSubscriptionId: String!

  # Rubrik ID of the Azure tenant in which this subscription is present.
  customerTenantId: String!
}
# Azure Cloud Account Subscription details for a given feature.
type AzureCloudAccountSubscriptionDetail {
  # Rubrik ID of the Azure Subscription.
  id: String!

  # Subscription UUID as specified in Azure.
  nativeId: String!

  # Subscription name as specified in Azure.
  name: String!

  # One of the enabled features on this subscription.
  featureDetail: AzureCloudAccountFeatureDetail
}
# Input required to update the Azure subscription.
input AzureCloudAccountSubscriptionInput {
  # Rubrik ID of the Azure subscription to be updated.
  id: String = ""

  # Name or subscription alias to identify the Azure subscription to be updated.
  name: String = ""
}
# Azure Tenant with details of subscriptions that are configured for a given feature.
type AzureCloudAccountTenant {
  # Rubrik ID of the Azure Tenant.
  azureCloudAccountTenantRubrikId: String!

  # Domain Name of the Azure Tenant.
  domainName: String!

  # Count of subscriptions added to the Rubrik ecosystem for this Azure Tenant.
  subscriptionCount: Int!

  # Subscriptions added to the Rubrik ecosystem for this Azure Tenant.
  subscriptions: [AzureCloudAccountSubscriptionDetail!]!

  # Client ID of the application configured for authentication of the Azure tenant.
  clientId: String!

  # Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud.
  cloudType: AzureCloudType!
}
# Azure Cloud Account Tenant with details of exocompute configured for subscriptions for a given feature.
type AzureCloudAccountTenantWithExoConfigs {
  # Azure Active Directory (AD) domain corresponding to subscription.
  domainName: String!

  # Number of subscriptions for the tenant.
  subscriptionCount: Int!

  # Client ID of azure application for the tenant.
  clientId: String!

  # Type of Azure Tenant. Can be Azure Public Cloud or Azure China Cloud.
  cloudType: AzureCloudType!

  # Details of subscriptions for the tenant.
  subscriptions: [AzureSubscriptionWithExoConfigs!]!
}
# Azure native archival specific fields for Azure Target Template.
type AzureCloudNativeTargetCompanion {
  # Template type of the storage settings. Must be either SOURCE_REGION or SPECIFIC_REGION.
  cloudNativeLocTemplateType: CloudNativeLocTemplateType!

  # Tags for the Storage Account.
  storageAccountTags: [TagObject!]!

  # Region for the Storage Account. All the storage accounts created are General Purpose V2 Storage Account. GPV2 accounts are supported only in certain regions. List of Supported Regions: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#redundancy-in-the-primary-region.
  storageAccountRegion: AzureRegion!

  # Storage Tier for the Storage Account. Only Cool, Hot storage tier are supported for now. More Info: https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers.
  storageTier: AzureStorageTier!

  # Redundancy type for the Storage Account. Some examples are: LRS, ZRS, GRS etc. More Info: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy.
  redundancy: AzureRedundancy!

  # Native ID of the Azure subscription.
  subscriptionNativeId: String!

  # List of configured customer managed keys per region.
  cmkInfo: [AzureCmk!]!
}
# Azure cloud type.
enum AzureCloudType {
  # Azure China Cloud.
  AZURECHINACLOUD

  # Azure public Cloud.
  AZUREPUBLICCLOUD

  # Azure Gov Cloud.
  AZUREUSGOVERNMENTCLOUD
}
# Customer managed key vault and key information for a region.
type AzureCmk {
  # Name of the key vault.
  keyVaultName: String!

  # Name of the customer managed key.
  keyName: String!

  # Region of the key vault.
  region: AzureRegion!
}
# Compute setting for Azure Target.
type AzureComputeSettings {
  appId: String!
  region: AzureRegion!
  generalPurposeStorageName: String!
  generalPurposeStorageContainer: String!
  resourceGroup: String!
  virtualNetworkId: String!
  subnetId: String!
  securityGroupId: String!
  computeProxySettings: ProxySettings
}
# Azure exocompute configuration to add.
input AzureExocomputeAddConfigInputType {
  # The region for which the configuration is specified.
  region: AzureCloudAccountRegion!

  # Subnet native ID where exocompute should be launched.
  subnetNativeId: String!

  # Specifies if this configuration is managed by Polaris.
  isPolarisManaged: Boolean!
}
# Exocompute configurations details.
type AzureExocomputeConfigDetails {
  # ID for exocompute configuration.
  configUuid: String!

  # Region in which exocompute is configured. It will be in the format like EASTUS.
  region: AzureCloudAccountRegion!

  # Native ID of subnet coresponding to exocompute. This will be the subnet provided during setting up exocompute.
  subnetNativeId: String!

  # Whether exocompute is polaris managed or not.
  isPolarisManaged: Boolean!

  # Error message received while creating Exocompute configuration.
  message: String!

  # Status of the latest Exocompute health check.
  healthCheckStatus: ExocomputeHealthCheckStatus!
}
# Contains validation information, such as blockers or errors encountered in validating the Exocompute configuration.
type AzureExocomputeConfigValidationInfo {
  # Specifies the Exocompute configuration which needs validation.
  config: AzureExocomputeRegionConfig

  # Specifies whether the configuration has blocking security rules in its associated network security group attached to the subnet for running AKS cluster in the specific region. For more details, visit https://docs.microsoft.com/en-us/azure/aks/limit-egress-traffic#required-outbound-network-rules-and-fqdns-for-aks-clusters.
  hasBlockedSecurityRules: Boolean!

  # Specifies whether the configuration has the corresponding subnet address range overlap with Azure restricted address ranges. For more details, visit https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni#prerequisites.
  hasRestrictedAddressRangeOverlap: Boolean!

  # Specifies whether the the subnet specified in configuration is delegated. For more details, visit https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni#prerequisites.
  isSubnetDelegated: Boolean!

  # Error received while validating Exocompute configuration.
  errorMessage: String!
}
# Azure Exocompute configurations in an Azure subscription.
type AzureExocomputeConfigsInAccount {
  # Account details.
  azureCloudAccount: AzureCloudAccountSubscriptionDetail!

  # Feature details.
  featureDetails: AzureCloudAccountFeatureDetail!

  # List of regions for which exocompute can be configured.
  exocomputeEligibleRegions: [AzureCloudAccountRegion!]!

  # Azure exocompute configurations.
  configs: [AzureExocomputeGetConfigResponse!]!
}
# Azure Exocompute configuration.
type AzureExocomputeGetConfigResponse {
  # Unique ID of the Exocompute configuration.
  configUuid: String!

  # Azure region for the cloud account in which exocompute is configured.
  region: AzureCloudAccountRegion!

  # Native ID of the subnet which is configured for usage in this region.
  subnetNativeId: String!

  # Specifies whether Exocompute is managed by Polaris or not.
  isPolarisManaged: Boolean!

  # Specifies the error message received if any.
  message: String!

  # Status of the latest Exocompute health check.
  healthCheckStatus: ExocomputeHealthCheckStatus!
}
# Represents an Azure Exocompute Configuration for a specific region. The Azure Exocompute Configuration includes the subnet native ID to be used for launching an Azure Kubernetes Service (AKS) Cluster in a specific region.
type AzureExocomputeRegionConfig {
  # Azure region for the cloud account in which exocompute is configured.
  region: AzureCloudAccountRegion!

  # Native ID of the subnet which is configured for usage in this region.
  subnetNativeId: String!

  # Specifies whether Exocompute is managed by Polaris or not.
  isPolarisManaged: Boolean!
}
# Immutability settings for azure cdm target.
type AzureImmutabilitySettingsType {
  # Number of days location is immutable.
  lockDurationDays: Int!
}
# Mapped Azure subscription for launching Exocompute.
type AzureMappedExocomputeSubscription {
  # Cloud account ID of the Azure subscription.
  id: String!

  # Native ID of the Azure subscription.
  nativeId: String!

  # Name of the Azure subscription.
  name: String!
}
# Azure VM attached disks snapshot.
type AzureNativeAttachedDiskSpecificSnapshot {
  # Name of the attached disk.
  diskName: String!

  # Resource group name of the attached disk.
  diskResourceGroupName: String!

  # Native ID of the attached disk snapshot.
  snapshotNativeId: String!

  # Disk Storage Tier of the attached disk.
  diskStorageTier: String!

  # Specifies whether the attached disk is an OS disk or not.
  isOsDisk: Boolean!

  # Logical Unit Number(LUN) of the attached disk.
  lun: Int!

  # Source Disk Unique Native ID of the attached disk.
  sourceDiskUniqueNativeId: String!
}
# Filter to return Azure disks which are attached to one of the virtual machines in the given list of virtual machine IDs.
input AzureNativeAttachedVmFilter {
  # List of virtual machine IDs.
  virtualMachineIds: [String!]!
}
# An Azure availability set. An availability set is a logical grouping of VMs to facilitate redundancy and availability. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/availability-set-overview.
type AzureNativeAvailabilitySet {
  # Name of the availability set.
  name: String!

  # Native ID of the availability set.
  nativeId: String!
}
# Filters for listing Azure resource groups.
input AzureNativeCommonResourceGroupFilters {
  # Filter by name substring.
  nameSubstringFilter: NameSubstringFilter

  # Filter by subscription.
  subscriptionFilter: AzureNativeCommonRgSubscriptionFilter

  # Filter by region.
  regionFilter: AzureNativeRegionFilter

  # Filter by effective SLA Domain.
  effectiveSlaFilter: AzureNativeRgSlaFilter
}
# The field type used to sort the resource groups.
enum AzureNativeCommonResourceGroupSortFields {
  # Use region name for sorting.
  AZURE_REGION

  # Use managed disk SLA Domain for sorting.
  AZURE_RG_DISK_EFFECTIVE_SLA

  # Use SQL Database SLA for sorting.
  AZURE_RG_SQL_DATABASE_DB_EFFECTIVE_SLA

  # Use Managed Instance Database SLA Domain for sorting.
  AZURE_RG_SQL_MANAGED_INSTANCE_DB_EFFECTIVE_SLA

  # Use subscription name for sorting.
  AZURE_RG_SUBSCRIPTION_NAME

  # Use virtual machine SLA Domain for sorting.
  AZURE_RG_VM_EFFECTIVE_SLA

  # Use resource group name for sorting.
  NAME
}
# Filters Azure resource groups that belong to the subscriptions identified by the list of Rubrik subscription IDs provided.
input AzureNativeCommonRgSubscriptionFilter {
  # List of Rubrik subscription IDs.
  subscriptionIds: [String!]!
}
# Filter to decide whether to get disks with a configured exocompute.
input AzureNativeDiskExocomputeConnectedFilter {
  # Specifies whether to only get snappables whose regions have exocompute configured.
  isConnected: Boolean!
}
# Filter to return Azure disks which have file indexing enabled.
input AzureNativeDiskFileIndexingFilter {
  # The list of status values to filter for.
  statuses: [AzureNativeFileIndexingStatus!]!
}
# Filters for list of Azure disks.
input AzureNativeDiskFilters {
  # Filter by disk name.
  nameSubstringFilter: NameSubstringFilter

  # Filter by effective SLA Domain of disks.
  effectiveSlaFilter: EffectiveSlaFilter

  # Filter by disk resource group name.
  resourceGroupFilter: AzureNativeDiskResourceGroupFilter

  # Filter by subscription.
  subscriptionFilter: AzureNativeDiskSubscriptionFilter

  # Filter by disk region.
  regionFilter: AzureNativeRegionFilter

  # Filter by disk type.
  diskTypeFilter: AzureNativeDiskTypeFilter

  # Filter by attached Azure Virtual Machine.
  attachedVmFilter: AzureNativeAttachedVmFilter

  # Filter by disk relic status.
  relicFilter: RelicFilter

  # Filter by disk tags.
  tagFilter: AzureNativeTagFilter

  # Filter by Exocompute connection status in the disk region.
  exocomputeConnectedFilter: AzureNativeDiskExocomputeConnectedFilter

  # Filter disks where file indexing is enabled.
  fileIndexingFilter: AzureNativeDiskFileIndexingFilter
}
# Filter to return Azure disks which have resource group name in the given list of resource group names.
input AzureNativeDiskResourceGroupFilter {
  # Filter by list of resource group names.
  resourceGroupNames: [String!]!
}
# The field type used to sort the managed disks.
enum AzureNativeDiskSortFields {
  # Use SLA Domain assignment for sorting.
  ASSIGNED_SLA_DOMAIN

  # Use common resource group name for sorting.
  AZURE_DISK_CRG_NAME

  # Use subscription name from common resource group for sorting.
  AZURE_DISK_CRG_SUBSCRIPTION_NAME

  # Use disk size for sorting.
  AZURE_DISK_SIZE

  # Use disk type for sorting.
  AZURE_DISK_TYPE

  # Use region name for sorting.
  AZURE_REGION

  # Use managed disk SLA Domain for sorting.
  EFFECTIVE_SLA_DOMAIN

  # Use managed disk name for sorting.
  NAME
}
# Filter to return Azure disks which have rubrik subscription ID in the given list of rubrik subscription IDs.
input AzureNativeDiskSubscriptionFilter {
  # List of subscription IDs.
  subscriptionIds: [String!]!
}
# Filter to return Azure virtual machine which have VM size in the given list of VM sizes.
input AzureNativeDiskTypeFilter {
  # List of disk types.
  diskTypes: [String!]!
}
# List of disk types available for use in an Azure availability zone. Not all disk types are supported in all the regions. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types.
type AzureNativeExportCompatibleDiskTypes {
  # Availabity zone of the disk.
  availabilityZone: String!

  # Types of the disk.
  diskTypes: [AzureNativeManagedDiskType!]!
}
# The virtual machine (VM) sizes for an Azure availability zone. Not all VM sizes are supported in all the regions. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes.
type AzureNativeExportCompatibleVmSizes {
  # Availability zone of the virtual machine (VM).
  availabilityZone: String!

  # Sizes of the virtual machines (VMs). For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes.
  vmSizes: [String!]!
}
# File indexing status.
enum AzureNativeFileIndexingStatus {
  # File indexing is not enabled.
  DISABLED

  # File indexing is enabled.
  ENABLED

  # File indexing status is not specified.
  NOT_SPECIFIED
}
# An Azure Native Managed Disk that refers to the block storage designed to be used with Azure Virtual Machines. Some examples are: ultra disks, premium solid-state drives (SSD), standard SSDs, and standard hard disk drives (HDD). For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/managed-disks-overview.
type AzureNativeManagedDisk implements PolarisHierarchyObject , PolarisHierarchySnappable , HierarchyObject {
  # Azure region where the Managed Disk is located.
  region: AzureNativeRegion!

  # List of tags associated with the Managed Disk.
  tags: [AzureTag!]!

  # Specifies whether the Managed Disk is a relic. When the value is true, the Managed Disk is a relic. A managed disk is a relic when it is unprotected or deleted, but the previously taken snapshots of the VM continue to exist within the Rubrik ecosystem.
  isRelic: Boolean!

  # Type of the Operating System (OS) installed on the Managed Disk.
  osType: AzureNativeVmOsType!

  # Specifies whether Azure Disk Encryption (ADE) is enabled on the Managed Disk or not. When the value is true, ADE is enabled.
  isAdeEnabled: Boolean!

  # Size of the Managed Disk in gigabytes (GiB).
  diskSizeGib: Int!

  # Storage tier of the Managed Disk.
  diskStorageTier: AzureNativeManagedDiskType!

  # Number of Input/Output operations Per Second (IOPS) allowed for the Managed Disk.
  diskIopsReadWrite: Long!

  # Bandwidth allowed for the Managed Disk, in millions of bytes per second (MBps).
  diskMbpsReadWrite: Long!

  # Availability Zone associated with the Managed Disk.
  availabilityZone: String!

  # Attachment Specifications are properties of the Managed Disk,  like the ID of the virtual machine (VM) that is associated with the Managed Disk.
  attachmentSpecs: [AttachmentSpecsForManagedDisk!]!

  # Native ID of the Managed Disk.
  diskNativeId: String!

  # Specifies whether exocompute is configured for the region in which the Managed Disk exists or not. When the value is true, exocompute can be used to perform tasks like file indexing.
  isExocomputeConfigured: Boolean!

  # Specifies whether file indexing is enabled for this Managed Disk or not. When file indexing is enabled, Rubrik can scan through the file structure inside the managed disk in a protected environment where only the meta data like folder structure, file names, and file sizes will be readable by Rubrik.
  isFileIndexingEnabled: Boolean!

  # The authorized operations on the object.
  authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!

  # Resource Group of the Azure Native Managed Disk.
  resourceGroup: AzureNativeResourceGroup!

  # All Virtual Machines (VMs) attached to the Managed Disk.
  allAttachedAzureNativeVirtualMachines: [AzureNativeVirtualMachine!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!

  # The list of snapshots taken for this workload.
  snapshotConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Sort Polaris snapshots by field.
    sortBy: PolarisSnapshotSortByEnum = Date,

    # Sort order.
    sortOrder: SortOrderEnum): PolarisSnapshotConnection

  # The list of snapshots taken for this workload.
  snapshotsOfSnappableConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String, snappableId: String!,

    # Filter for snapshot connection.
    snapshotFilter: [SnapshotQueryFilterInput!],

    # Sort order.
    sortOrder: SortOrderEnum, sortBy: SnapshotQuerySortByField,

    # Time range input.
    timeRange: TimeRangeInput,

    # Specifies whether to ignore the active protected object check.
    ignoreActiveSnappableCheck: Boolean): GenericSnapshotConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Group Polaris snapshots by field.
    groupBy: PolarisSnapshotGroupByEnum!): PolarisSnapshotGroupByConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByNewConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    snapshotFilter: [PolarisSnapshotFilterNewInput!]!,

    # Group Polaris snapshots by field.
    snapshotGroupBy: SnapshotGroupByTimeEnum!): PolarisSnapshotGroupByNewConnection

  # The most recent snapshot of this workload.
  newestSnapshot: PolarisSnapshot

  # The oldest snapshot of this workload.
  oldestSnapshot: PolarisSnapshot

  # The number of on-demand snapshots.
  onDemandSnapshotCount: Int!

  # The newest snapshot that is indexed and unexpired, and therefore restorable.
  newestIndexedSnapshot: PolarisSnapshot
}
# Paginated list of AzureNativeManagedDisk objects.
type AzureNativeManagedDiskConnection {
  # List of AzureNativeManagedDisk objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [AzureNativeManagedDiskEdge!]!

  # List of AzureNativeManagedDisk objects.
  nodes: [AzureNativeManagedDisk!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of AzureNativeManagedDisk objects matching the request arguments.
  count: Int!
}
# Wrapper around the AzureNativeManagedDisk object. This wrapper is used for pagination.
type AzureNativeManagedDiskEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual AzureNativeManagedDisk object wrapped by this edge.
  node: AzureNativeManagedDisk!
}
# Azure Managed Disk types.
enum AzureNativeManagedDiskType {
  # Azure Managed Disk type is not specified.
  NOT_SPECIFIED

  # Azure Managed Disk type is Premium LRS.
  PREMIUM_LRS

  # Azure Managed Disk type is Standard SSD LRS.
  STANDARDSSD_LRS

  # Azure Managed Disk type is Standard LRS.
  STANDARD_LRS

  # Azure Managed Disk type is Ultra SSD LRS.
  ULTRASSD_LRS

  # Azure Managed Disk type is unknown.
  UNKNOWN
}
# The type of Azure Native feature Polaris supports.
enum AzureNativeProtectionFeature {
  # Protection on Azure SQL Databases.
  SQL_DB

  # Protection on Azure Native Managed Instances.
  SQL_MI

  # Protection on Azure Native Virtual Machines.
  VM
}
# Azure native regions.
enum AzureNativeRegion {
  # Azure native region is Australia Central.
  AUSTRALIA_CENTRAL

  # Azure native region is Australia Central 2.
  AUSTRALIA_CENTRAL2

  # Azure native region is Australia East.
  AUSTRALIA_EAST

  # Azure native region is Australia Southeast.
  AUSTRALIA_SOUTHEAST

  # Azure native region is Brazil South.
  BRAZIL_SOUTH

  # Azure native region is Canada Central.
  CANADA_CENTRAL

  # Azure native region is Canada East.
  CANADA_EAST

  # Azure native region is Central India.
  CENTRAL_INDIA

  # Azure native region is Central US.
  CENTRAL_US

  # Azure native region is China East.
  CHINA_EAST

  # Azure native region is China East 2.
  CHINA_EAST2

  # Azure native region is China North.
  CHINA_NORTH

  # Azure native region is China North 2.
  CHINA_NORTH2

  # Azure native region is East Asia.
  EAST_ASIA

  # Azure native region is East US.
  EAST_US

  # Azure native region is East US 2.
  EAST_US2

  # Azure native region is France Central.
  FRANCE_CENTRAL

  # Azure native region is France South.
  FRANCE_SOUTH

  # Azure native region is Germany North.
  GERMANY_NORTH

  # Azure native region is Germany West Central.
  GERMANY_WEST_CENTRAL

  # Azure native region is Japan East.
  JAPAN_EAST

  # Azure native region is Japan West.
  JAPAN_WEST

  # Azure native region is Korea Central.
  KOREA_CENTRAL

  # Azure native region is Korea South.
  KOREA_SOUTH

  # Azure native region is North Central US.
  NORTH_CENTRAL_US

  # Azure native region is North Europe.
  NORTH_EUROPE

  # Azure native region is Norway East.
  NORWAY_EAST

  # Azure native region is Norway West.
  NORWAY_WEST

  # Azure native region is not specified.
  NOT_SPECIFIED

  # Azure native region is Southeast Asia.
  SOUTHEAST_ASIA

  # Azure native region is South Africa North.
  SOUTH_AFRICA_NORTH

  # Azure native region is South Africa West.
  SOUTH_AFRICA_WEST

  # Azure native region is South Central US.
  SOUTH_CENTRAL_US

  # Azure native region is South India.
  SOUTH_INDIA

  # Azure native region is Switzerland North.
  SWITZERLAND_NORTH

  # Azure native region is Switzerland West.
  SWITZERLAND_WEST

  # Azure native region is UAE Central.
  UAE_CENTRAL

  # Azure native region is UAE North.
  UAE_NORTH

  # Azure native region is UK South.
  UK_SOUTH

  # Azure native region is UK West.
  UK_WEST

  # Azure native region is US Gov Arizona.
  US_GOV_ARIZONA

  # Azure native region is US Gov Texas.
  US_GOV_TEXAS

  # Azure native region is US Gov Virginia.
  US_GOV_VIRGINIA

  # Azure native region is West Central US.
  WEST_CENTRAL_US

  # Azure native region is West Europe.
  WEST_EUROPE

  # Azure native region is West India.
  WEST_INDIA

  # Azure native region is West US.
  WEST_US

  # Azure native region is West US 2.
  WEST_US2

  # Azure native region is West US 3.
  WEST_US3
}
# Filter to return Azure virtual machine which have region in the given list of regions.
input AzureNativeRegionFilter {
  # List of regions to filter by.
  regions: [AzureNativeRegion!]!
}
# Azure native regions for replication.
enum AzureNativeRegionForReplication {
  # Azure native region for replication is Australia Central.
  AUSTRALIA_CENTRAL

  # Azure native region for replication is Australia Central 2.
  AUSTRALIA_CENTRAL2

  # Azure native region for replication is Australia East.
  AUSTRALIA_EAST

  # Azure native region for replication is Australia Southeast.
  AUSTRALIA_SOUTHEAST

  # Azure native region for replication is Brazil South.
  BRAZIL_SOUTH

  # Azure native region for replication is Canada Central.
  CANADA_CENTRAL

  # Azure native region for replication is Canada East.
  CANADA_EAST

  # Azure native region for replication is Central India.
  CENTRAL_INDIA

  # Azure native region for replication is Central US.
  CENTRAL_US

  # Azure native region for replication is China East.
  CHINA_EAST

  # Azure native region for replication is China East 2.
  CHINA_EAST2

  # Azure native region for replication is China North.
  CHINA_NORTH

  # Azure native region for replication is China North 2.
  CHINA_NORTH2

  # Azure native region for replication is East Asia.
  EAST_ASIA

  # Azure native region for replication is East US.
  EAST_US

  # Azure native region for replication is East US 2.
  EAST_US2

  # Azure native region for replication is France Central.
  FRANCE_CENTRAL

  # Azure native region for replication is France South.
  FRANCE_SOUTH

  # Azure native region for replication is Germany North.
  GERMANY_NORTH

  # Azure native region for replication is Germany West Central.
  GERMANY_WEST_CENTRAL

  # Azure native region for replication is Japan East.
  JAPAN_EAST

  # Azure native region for replication is Japan West.
  JAPAN_WEST

  # Azure native region for replication is Korea Central.
  KOREA_CENTRAL

  # Azure native region for replication is Korea South.
  KOREA_SOUTH

  # Azure native region for replication is North Central US.
  NORTH_CENTRAL_US

  # Azure native region for replication is North Europe.
  NORTH_EUROPE

  # Azure native region for replication is Norway East.
  NORWAY_EAST

  # Azure native region for replication is Norway West.
  NORWAY_WEST

  # Azure native region for replication is not defined.
  NOT_DEFINED

  # Azure native region for replication is the source region.
  SOURCE_REGION

  # Azure native region for replication is Southeast Asia.
  SOUTHEAST_ASIA

  # Azure native region for replication is South Africa North.
  SOUTH_AFRICA_NORTH

  # Azure native region for replication is South Africa West.
  SOUTH_AFRICA_WEST

  # Azure native region for replication is South Central US.
  SOUTH_CENTRAL_US

  # Azure native region for replication is South India.
  SOUTH_INDIA

  # Azure native region for replication is Switzerland North.
  SWITZERLAND_NORTH

  # Azure native region for replication is Switzerland West.
  SWITZERLAND_WEST

  # Azure native region for replication is UAE Central.
  UAE_CENTRAL

  # Azure native region for replication is UAE North.
  UAE_NORTH

  # Azure native region for replication is UK South.
  UK_SOUTH

  # Azure native region for replication is UK West.
  UK_WEST

  # Azure native region for replication is US Gov Arizona.
  US_GOV_ARIZONA

  # Azure native region for replication is US Gov Texas.
  US_GOV_TEXAS

  # Azure native region for replication is US Gov Virginia.
  US_GOV_VIRGINIA

  # Azure native region for replication is West Central US.
  WEST_CENTRAL_US

  # Azure native region for replication is West Europe.
  WEST_EUROPE

  # Azure native region for replication is West India.
  WEST_INDIA

  # Azure native region for replication is West US.
  WEST_US

  # Azure native region for replication is West US 2.
  WEST_US2

  # Azure native region for replication is West US 3.
  WEST_US3
}
# Azure region specification.
type AzureNativeRegionSpec {
  # Name of the Azure region.
  region: AzureNativeRegion!

  # Specifies whether Exocompute is configured in the region or not.
  isExocomputeConfigured: Boolean!
}
# An Azure Native Resource Group. Refers to a collection of resources in which multiple Azure services can reside.
type AzureNativeResourceGroup implements PolarisHierarchyObject , HierarchyObject {
  # Rubrik ID of the Azure Native Resource Group.
  azureSubscriptionRubrikId: UUID!

  # Count of Virtual Machines (VMs) in the Resource Group.
  vmsCount: Int!

  # Count of disks in the Resource Group.
  disksCount: Int!

  # Deprecated, use protectedObjectTypeToSla instead. Rubrik Service Level Agreement (SLA) assigned to the Virtual Machines (VMs) in the Resource Group.
  vmSla: AzureNativeResourceGroupSlaAssignment!

  # Deprecated, use protectedObjectTypeToSla instead. Rubrik Service Level Agreement (SLA) assigned to the disks in the Resource Group.
  diskSla: AzureNativeResourceGroupSlaAssignment!

  # Azure region associated with the Resource Group.
  region: AzureNativeRegion!

  # List of tags associated with the Resource Group.
  tags: [AzureTag!]!

  # A list of mappings between protected object types and SLA Domains.
  protectedObjectTypeToSla: [ProtectedObjectTypeToSla!]!

  # Count of Azure SQL databases in the Resource Group.
  azureSqlDatabaseCount: Int!

  # Count of Azure SQL Managed Instance databases in the Resource Group.
  azureSqlManagedInstanceDbCount: Int!

  # A list of mappings between object types and details about the backup setup.
  snappableTypeToBackupSetupSpecs: [SnappableTypeToBackupSetupSpecs!]!

  # The authorized operations on the object.
  authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!

  # Azure Native Subscription of the Resource Group.
  subscription: AzureNativeSubscription!

  # Paginated ist of Azure Virtual Machines (VMs) in the Resource Group.
  azureNativeVirtualMachines(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for list of Azure virtual machines.
    sortBy: AzureNativeVirtualMachineSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, virtualMachineFilters: AzureNativeVirtualMachineFilters): AzureNativeVirtualMachineConnection!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Paginated list of AzureNativeResourceGroup objects.
type AzureNativeResourceGroupConnection {
  # List of AzureNativeResourceGroup objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [AzureNativeResourceGroupEdge!]!

  # List of AzureNativeResourceGroup objects.
  nodes: [AzureNativeResourceGroup!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of AzureNativeResourceGroup objects matching the request arguments.
  count: Int!
}
# Wrapper around the AzureNativeResourceGroup object. This wrapper is used for pagination.
type AzureNativeResourceGroupEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual AzureNativeResourceGroup object wrapped by this edge.
  node: AzureNativeResourceGroup!
}
# SLA Domain assignment type for the Azure resource group.
type AzureNativeResourceGroupSlaAssignment {
  # SLA Domain.
  slaAssignment: SlaAssignmentTypeEnum!

  # Effective SLA Domain.
  effectiveSlaDomain: GlobalSlaReply!

  # Configured SLA domain.
  configuredSlaDomain: GlobalSlaReply!
}
# Returns Azure resource groups containing objects that are protected by the SLA domains identified by the specified SLA IDs.
input AzureNativeRgSlaFilter {
  # List of SLA Domain IDs.
  effectiveSlaIds: [String!]!
}
# An Azure security group. Security groups enable you to configure network security as a natural extension of an application's structure, allowing you to group virtual machines and define network security policies based on those groups. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/application-security-groups.
type AzureNativeSecurityGroup {
  # Name of the resource group associated with the security group.
  resourceGroupName: String!

  # Name of the security group.
  name: String!

  # Native ID of the security group.
  nativeId: String!
}
# Azure storage account.
type AzureNativeStorageAccount {
  # Azure ID of the storage account.
  id: String!

  # Name of the storage account.
  name: String!

  # Region where the storage account is located.
  region: AzureNativeRegion!

  # Name of the resource group where storage account is located.
  resourceGroupName: String!

  # Tags attached to the storage account.
  tags: [AzureTag!]!
}
# An Azure subnet. Subnets allow you to choose IP address range of your choice. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/network-overview#virtual-network-and-subnets.
type AzureNativeSubnet {
  # Name of the subnet.
  name: String!

  # Native ID of the subnet.
  nativeId: String!

  # List of subnet IP address prefixes in CIDR notation. The list can contain both IPv4 and IPv6 addresses. The list cannot be empty.
  addressPrefixes: [String!]!

  # Virtual Network (VNet) associated with the subnet.
  vnet: AzureNativeVirtualNetwork!
}
# An Azure Native Subscription. Refers to the logical entity that provides entitlement to deploy and consume Azure resources.
type AzureNativeSubscription implements PolarisHierarchyObject , HierarchyObject {
  # Native ID of the subscription.
  azureSubscriptionNativeId: String!

  # Tenant ID associated with the subscription.
  tenantId: String!

  # Status of the subscription at a given time. Some examples are: added, deleted, refreshed. For more information, see https://docs.microsoft.com/en-us/azure/cost-management-billing/manage/subscription-states.
  azureSubscriptionStatus: AzureSubscriptionStatus!

  # Last refresh time of the subscription, in UTC date-time format.
  lastRefreshedAt: DateTime

  # List of Azure region specifications associated with the subscription.
  regionSpecs: [AzureNativeRegionSpec!]!

  # Count of virtual machines (VMs) in the subscription.
  vmsCount: Int!

  # Count of managed disks in the subscription.
  disksCount: Int!

  # Count of Azure SQL databases in the subscription.
  azureSqlDatabaseDbCount: Int!

  # Count of Azure SQL Managed Instance databases in the subscription.
  azureSqlManagedInstanceDbCount: Int!

  # Type of Azure cloud, for example, Azure Public Cloud and Azure China Cloud.
  azureCloudType: AzureCloudType!

  # Details of features enabled for the subscription.
  enabledFeatures: [AzureNativeSubscriptionEnabledFeature!]!

  # A list of mappings between object types and details about the backup setup.
  snappableTypeToBackupSetupSpecs: [SnappableTypeToBackupSetupSpecs!]!

  # Cloud account ID associated with the subscription.
  accountConnectionId: String!

  # The authorized operations on the object.
  authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!

  # Paginated list of all Azure Resource Groups in the subscription.
  azureNativeResourceGroups(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort fields for listing Azure resource groups.
    sortBy: AzureNativeCommonResourceGroupSortFields,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder,

    # Filters for listing Azure resource groups
    commonResourceGroupFilters: AzureNativeCommonResourceGroupFilters): AzureNativeResourceGroupConnection!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Paginated list of AzureNativeSubscription objects.
type AzureNativeSubscriptionConnection {
  # List of AzureNativeSubscription objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [AzureNativeSubscriptionEdge!]!

  # List of AzureNativeSubscription objects.
  nodes: [AzureNativeSubscription!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of AzureNativeSubscription objects matching the request arguments.
  count: Int!
}
# Wrapper around the AzureNativeSubscription object. This wrapper is used for pagination.
type AzureNativeSubscriptionEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual AzureNativeSubscription object wrapped by this edge.
  node: AzureNativeSubscription!
}
# Details of a feature enabled in Azure Native Subscription.
type AzureNativeSubscriptionEnabledFeature {
  # Name of the feature enabled for the Azure Subscription.
  featureName: AzureNativeProtectionFeature!

  # Status of the feature at a given time. Some examples are: added, deleted, refreshed.
  status: AzureSubscriptionStatus!

  # Time, in UTC date-time format, when the feature was last refreshed.
  lastRefreshedAt: DateTime
}
# Filters for list of Azure subscriptions.
input AzureNativeSubscriptionFilters {
  # Filter by substring of subscription name.
  nameSubstringFilter: NameSubstringFilter

  # Filter by effective SLA Domain.
  effectiveSlaFilter: EffectiveSlaFilter
}
# The field type used to sort the subscriptions.
enum AzureNativeSubscriptionSortFields {
  # Use SLA Domain assignment for sorting.
  ASSIGNED_SLA_DOMAIN

  # Use disk count for sorting.
  AZURE_SUBSCRIPTION_DISKCOUNT

  # Use virtual machine count for sorting.
  AZURE_SUBSCRIPTION_VMCOUNT

  # Use tenant ID for sorting.
  AZURE_TENANT_ID

  # Use subscription SLA Domain for sorting.
  EFFECTIVE_SLA_DOMAIN

  # Use subscription name for sorting.
  NAME
}
# Filter to return Azure objects which have at least one tag in the given list of tags.
input AzureNativeTagFilter {
  # Filter by tag.
  tagFilterParams: [TagFilterParams!]!
}
# An Azure Native Virtual Machine that refers to the Azure infrastructure as a service (IaaS) used to deploy persistent VMs. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/.
type AzureNativeVirtualMachine implements PolarisHierarchyObject , PolarisHierarchySnappable , HierarchyObject {
  # Azure region where the virtual machine (VM) is located.
  region: AzureNativeRegion!

  # Name of the Virtual Machine (VM).
  vmName: String!

  # Size type of the virtual machine (VM). For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes-general.
  sizeType: String!

  # Name of the Virtual Network (VNet) associated with the virtual machine (VM).
  vnetName: String!

  # Name of the subnet associated with the virtual machine (VM).
  subnetName: String!

  # Specifies whether the virtual machine (VM) is a relic or not. A VM is a relic when it is unprotected or deleted, but the previously taken snapshots of the VM continue to exist within the Rubrik ecosystem.
  isRelic: Boolean!

  # List of tags associated with the virtual machine (VM).
  tags: [AzureTag!]!

  # Sequence of attachment specs for the virtual machine (VM).
  attachmentSpecs: [AttachmentSpecsForVirtualMachine!]!

  # Specifies whether Azure Disk Encryption (ADE) exists on the virtual machine (VM) or not.
  isAdeEnabled: Boolean!

  # Type of the Operating System (OS) installed on the virtual machine (VM).
  osType: AzureNativeVmOsType!

  # Availability Zone associated with the virtual machine (VM).
  availabilityZone: String!

  # Native ID of the the virtual machine (VM).
  virtuaMachineNativeId: String!

  # Specifies whether pre-script or post-script framework is enabled on the the virtual machine (VM) or not. When true, it facilitates application-consistent backups.
  isPreOrPostScriptEnabled: Boolean!

  # Application Consistent Specifications of the virtual machine (VM).
  vmAppConsistentSpecs: VmAppConsistentSpecsInternal

  # Specifies whether application consistent snapshots are enabled for this virtual machine (VM) or not. When enabled, Rubrik informs the Azure applications before taking snapshots, so apps can prepare. During the preparation phrase, Rubrik waits for the IO to be frozen and then the snapshot is taken. Once snapshot is taken, IO is unfreezed and the apps resume normal operation.
  isAppConsistencyEnabled: Boolean!

  # Native ID of the availability set associated with the virtual machine (VM).
  availabilitySetNativeId: String!

  # Specifies whether accelerated networking is enabled on the virtual machine (VM) or not. Accelerated Networking improves the network performance on the VM. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-networking.
  isAcceleratedNetworkingEnabled: Boolean!

  # Specifies whether exocompute is configured for the region in which the virtual machine (VM) exists, or not. When the value is true, exocompute can be used to perform tasks like file indexing.
  isExocomputeConfigured: Boolean!

  # Specifies whether file indexing is enabled for this virtual machine (VM) or not. When enabled, Rubrik can scan through the file structure inside the VM in a protected environment where only the meta data like folder structure, file names, and file sizes will be readable by Rubrik.
  isFileIndexingEnabled: Boolean!

  # Private IP address of the virtual machine.
  privateIp: String!

  # The authorized operations on the object.
  authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!

  # Resource Group of the Azure Virtual Machine (VM).
  resourceGroup: AzureNativeResourceGroup!

  # List of Managed Disks attached to the Azure Virtual Machine (VM).
  attachedManagedDisks: [AzureNativeManagedDisk!]!

  # Rubrik CDM host information for the Azure Virtual Machine added as a host to the cluster. The value is Null when the virtual machine is not added as a host on any Rubrik cluster.
  hostInfo: PhysicalHost

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!

  # The list of snapshots taken for this workload.
  snapshotConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Sort Polaris snapshots by field.
    sortBy: PolarisSnapshotSortByEnum = Date,

    # Sort order.
    sortOrder: SortOrderEnum): PolarisSnapshotConnection

  # The list of snapshots taken for this workload.
  snapshotsOfSnappableConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String, snappableId: String!,

    # Filter for snapshot connection.
    snapshotFilter: [SnapshotQueryFilterInput!],

    # Sort order.
    sortOrder: SortOrderEnum, sortBy: SnapshotQuerySortByField,

    # Time range input.
    timeRange: TimeRangeInput,

    # Specifies whether to ignore the active protected object check.
    ignoreActiveSnappableCheck: Boolean): GenericSnapshotConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Group Polaris snapshots by field.
    groupBy: PolarisSnapshotGroupByEnum!): PolarisSnapshotGroupByConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByNewConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    snapshotFilter: [PolarisSnapshotFilterNewInput!]!,

    # Group Polaris snapshots by field.
    snapshotGroupBy: SnapshotGroupByTimeEnum!): PolarisSnapshotGroupByNewConnection

  # The most recent snapshot of this workload.
  newestSnapshot: PolarisSnapshot

  # The oldest snapshot of this workload.
  oldestSnapshot: PolarisSnapshot

  # The number of on-demand snapshots.
  onDemandSnapshotCount: Int!

  # The newest snapshot that is indexed and unexpired, and therefore restorable.
  newestIndexedSnapshot: PolarisSnapshot
}
# Paginated list of AzureNativeVirtualMachine objects.
type AzureNativeVirtualMachineConnection {
  # List of AzureNativeVirtualMachine objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [AzureNativeVirtualMachineEdge!]!

  # List of AzureNativeVirtualMachine objects.
  nodes: [AzureNativeVirtualMachine!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of AzureNativeVirtualMachine objects matching the request arguments.
  count: Int!
}
# Wrapper around the AzureNativeVirtualMachine object. This wrapper is used for pagination.
type AzureNativeVirtualMachineEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual AzureNativeVirtualMachine object wrapped by this edge.
  node: AzureNativeVirtualMachine!
}
# Filters for list of Azure virtual machines.
input AzureNativeVirtualMachineFilters {
  # Filter by name substring.
  nameSubstringFilter: NameSubstringFilter

  # Filter by effective SLA Domain.
  effectiveSlaFilter: EffectiveSlaFilter

  # Filter by resource group.
  resourceGroupFilter: AzureNativeVmResourceGroupFilter

  # Filter by subscription.
  subscriptionFilter: AzureNativeVmSubscriptionFilter

  # Filter by region.
  regionFilter: AzureNativeRegionFilter

  # Filter by virtual machine sizes.
  vmSizeFilter: AzureNativeVmSizeFilter

  # Filter by VNet.
  vnetFilter: AzureNativeVnetFilter

  # Filter by relics.
  relicFilter: RelicFilter

  # Filter by tag.
  tagFilter: AzureNativeTagFilter

  # Filter by configured Exocompute.
  exocomputeConnectedFilter: AzureNativeVmExocomputeConnectedFilter

  # Filter by file indexing status.
  fileIndexingFilter: AzureNativeVmFileIndexingFilter

  # Filter by the protection status of the App.
  appProtectionStatusFilter: CloudNativeInstaceAppProtectionFilter

  # Filter by RBS connection status.
  rbsStatusFilter: AzureVmCcOrCnpRbsConnectionStatusFilter
}
# The field type used to sort the virtual machines.
enum AzureNativeVirtualMachineSortFields {
  # Use SLA Domain assignment for sorting.
  ASSIGNED_SLA_DOMAIN

  # Use region name for sorting.
  AZURE_REGION

  # Use subnet name for sorting.
  AZURE_SUBNET_NAME

  # Use common resource group name for sorting.
  AZURE_VM_CRG_NAME

  # Use subscription name from common resource group for sorting.
  AZURE_VM_CRG_SUBSCRIPTION_NAME

  # Use virtual machine size for sorting.
  AZURE_VM_SIZE

  # Use VNet name for sorting.
  AZURE_VNET_NAME

  # Use virtual machine SLA Domain for sorting.
  EFFECTIVE_SLA_DOMAIN

  # Use virtual machine name for sorting.
  NAME
}
# An Azure virtual network (VNet). VNet enables secure communication with other VNets, the internet, and on-premise networks. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview.
type AzureNativeVirtualNetwork {
  # Name of the resource group associated with the Virtual Network (VNet).
  resourceGroupName: String!

  # Name of the Virtual Network (VNet).
  name: String!
}
# Filter to decide whether to get VMs with a configured exocompute.
input AzureNativeVmExocomputeConnectedFilter {
  # Specifies whether to only get snappables whose regions have exocompute configured.
  isConnected: Boolean!
}
# Filter to return Azure VMs which have file indexing enabled.
input AzureNativeVmFileIndexingFilter {
  # The list of status values to filter for.
  statuses: [AzureNativeFileIndexingStatus!]!
}
# OS type of an Azure virtual machine.
enum AzureNativeVmOsType {
  # The OS type is Linux.
  LINUX

  # The OS type is unknown.
  UNKNOWN

  # The OS type is Windows.
  WINDOWS
}
# Filter by resource group name.
input AzureNativeVmResourceGroupFilter {
  # List of resource group names.
  resourceGroupNames: [String!]!
}
# Filter by virtual machine size.
input AzureNativeVmSizeFilter {
  # List of virtual machine sizes.
  vmSizes: [String!]!
}
# Azure VM-specific snapshot information.
type AzureNativeVmSpecificSnapshot implements PolarisSpecificSnapshot {
  # OS disk snapshot attached to the Azure VM.
  osDiskSnapshot: AzureNativeAttachedDiskSpecificSnapshot

  # List of data disk snapshots attached to the Azure VM.
  dataDiskSnapshots: [AzureNativeAttachedDiskSpecificSnapshot!]!

  # ID of the snapshot.
  snapshotId: UUID!
}
# Filter by subscription ID.
input AzureNativeVmSubscriptionFilter {
  # List of subscription IDs.
  subscriptionIds: [String!]!
}
# Filter by VNet name.
input AzureNativeVnetFilter {
  # List of names of VNet.
  vnetNames: [String!]!
}
# The resource for which OAuth access is requested.
enum AzureOauthResource {
  # Azure Resource Manager.
  AZURE_RESOURCE_MANAGER

  # Azure SQL resources.
  AZURE_SQL
}
# Redundancy value for the azure resource. For more information, see https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy.
enum AzureRedundancy {
  # Geo-redundant storage.
  GRS

  # Geo-zone-redundant storage.
  GZRS

  # Locally redundant storage.
  LRS

  # Read access Geo-redundant storage.
  RA_GRS

  # Read Access Geo-zone-redundant storage.
  RA_GZRS
  UNKNOWN_AZURE_REDUNDANCY

  # Zone-redundant storage.
  ZRS
}
# Regions for Azure.
enum AzureRegion {
  # Azure region is East Asia.
  ASIA_EAST

  # Azure region is Southeast Asia.
  ASIA_SOUTHEAST

  # Azure region is Australia Central.
  AUSTRALIA_CENTRAL

  # Azure region is Australia Central 2.
  AUSTRALIA_CENTRAL2

  # Azure region is Australia East.
  AUSTRALIA_EAST

  # Azure region is Australia Southeast.
  AUSTRALIA_SOUTHEAST

  # Azure region is Brazil South.
  BRAZIL_SOUTH

  # Azure region is Canada Central.
  CANADA_CENTRAL

  # Azure region is Canada East.
  CANADA_EAST

  # Azure region is China East.
  CHINA_EAST

  # Azure region is China East 2.
  CHINA_EAST2

  # Azure region is China North.
  CHINA_NORTH

  # Azure region is North Europe.
  EUROPE_NORTH

  # Azure region is West Europe.
  EUROPE_WEST

  # Azure region is France Central.
  FRANCE_CENTRAL

  # Azure region is France South.
  FRANCE_SOUTH

  # Azure region is Germany Central.
  GERMANY_CENTRAL

  # Azure region is Germany Northeast.
  GERMANY_NORTHEAST

  # Azure region is Germany West Central.
  GERMANY_WEST_CENTRAL

  # Azure region is US Gov Arizona.
  GOV_US_ARIZONA

  # Azure region is US DoD Central.
  GOV_US_DOD_CENTRAL

  # Azure region is US DoD East.
  GOV_US_DOD_EAST

  # Azure region is US Gov Texas.
  GOV_US_TEXAS

  # Azure region is US Gov Virginia.
  GOV_US_VIRGINIA

  # Azure region is Central India.
  INDIA_CENTRAL

  # Azure region is South India.
  INDIA_SOUTH

  # Azure region is West India.
  INDIA_WEST

  # Azure region is Japan East.
  JAPAN_EAST

  # Azure region is Japan West.
  JAPAN_WEST

  # Azure region is Korea Central.
  KOREA_CENTRAL

  # Azure region is Korea South.
  KOREA_SOUTH

  # Azure region is Norway East.
  NORWAY_EAST

  # Azure region is Norway West.
  NORWAY_WEST

  # Azure region is South Africa North.
  SOUTH_AFRICA_NORTH

  # Azure region is South Africa West.
  SOUTH_AFRICA_WEST

  # Azure region is Switzerland North.
  SWITZERLAND_NORTH

  # Azure region is Switzerland West.
  SWITZERLAND_WEST

  # Azure region is UAE Central.
  UAE_CENTRAL

  # Azure region is UAE North.
  UAE_NORTH

  # Azure region is UK South.
  UK_SOUTH

  # Azure region is UK West.
  UK_WEST

  # Azure region is unknown.
  UNKNOWN_AZURE_REGION

  # Azure region is Central US.
  US_CENTRAL

  # Azure region is East US.
  US_EAST

  # Azure region is East US 2.
  US_EAST2

  # Azure region is North Central US.
  US_NORTH_CENTRAL

  # Azure region is South Central US.
  US_SOUTH_CENTRAL

  # Azure region is West US.
  US_WEST

  # Azure region is West US 2.
  US_WEST2

  # Azure region is West Central US.
  US_WEST_CENTRAL

  # Azure region is West US 3.
  WEST_US3
}
type AzureReplicationTarget {
  subscriptionId: String!
  subscriptionName: String!
  region: AzureNativeRegionForReplication!
}
# Azure resource group.
type AzureResourceGroup {
  # The native ID of the resource group.
  nativeId: String!

  # The name of the resource group.
  name: String!

  # The region name of the resource group. Example: AustraliaEast.
  region: AzureNativeRegion!

  # The tags present in the resource group.
  tags: [AzureTag!]!
}
type AzureRoleBasedAccount implements CloudAccount {
  # The subscription info with feature details.
  subscriptionWithFeatures: AzureSubscriptionWithFeaturesType!

  # The ID of this Cloud Account.
  cloudAccountId: String!

  # The name of this Cloud Account.
  name: String!

  # The description of this Cloud Account.
  description: String

  # The type of this Cloud Provider.
  cloudProvider: CloudAccountType!

  # The connection status of this Cloud Account.
  connectionStatus: ConnectionStatusType!
}
# The type of snapshot to be used in export or restore jobs.
enum AzureSnapshotType {
  # Use the archived snapshot.
  ARCHIVED

  # Use the replicated snapshot.
  REPLICATED

  # Use the source snapshot.
  SOURCE
}
# SLA Domain configuration for Azure SQL Database DB object.
type AzureSqlDatabaseDbConfig {
  # Specifies the number of days for which the Azure SQL Database DB logs will be retained. Number of days can range from 1 to 35.
  logRetentionInDays: Int!
}
# SLA Domain configuration for Azure SQL Managed Instance DB object.
type AzureSqlManagedInstanceDbConfig {
  # Specifies the number of days for which the Azure SQL Managed Instance DB logs will be retained. Number of days can range from 1 to 35.
  logRetentionInDays: Int!
}
# Storage Tier for the storage accounts/containers. For more information, see https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers.
enum AzureStorageTier {
  # Optimized for storing data that is rarely accessed.
  ARCHIVE

  # Optimized for storing data that is accessed frequently.
  COOL

  # Optimized for storing data that is infrequently accessed.
  HOT
  UNKNOWN_STORAGE_TIER
}
# Input required to add the Azure subscription.
input AzureSubscriptionInput {
  # The native subscription ID of the Azure subscription.
  nativeId: String!

  # Name or subscription alias to identify the Azure subscription.
  name: String!
}
# Missing permissions on the Azure Subscription.
type AzureSubscriptionMissingPermissions {
  # Native ID of the Azure Subscription.
  subscriptionNativeId: String!

  # List of missing permissions on the Azure Subscription.
  missingPermissions: [String!]!
}
# Status of an Azure subscription.
enum AzureSubscriptionStatus {
  # The Azure subscription has been added.
  ADDED

  # The Azure subscription has been deleted.
  DELETED

  # The Azure subscription is in the process of getting deleted.
  DELETING

  # The deletion of the Azure subscription has failed.
  DELETION_FAILED

  # The Azure subscription has been refreshed.
  REFRESHED

  # The Azure subscription is refreshing.
  REFRESHING

  # The Azure subscription has failed to refresh.
  REFRESH_FAILED
}
# Azure Cloud Account Subscription with exocompute configurations for feature configured.
type AzureSubscriptionWithExoConfigs {
  # Rubrik ID for Azure subscription.
  azureSubscriptionRubrikId: String!

  # Native ID for Azure subscription.
  azureSubscriptionNativeId: String!

  # Name of Azure subscription.
  subscriptionName: String!

  # Feature details of subscription.
  featureDetail: AzureCloudAccountFeatureDetail!

  # Mapped Exocompute subscription for launching Exocompute.
  mappedExocomputeSubscription: AzureMappedExocomputeSubscription

  # Exocompute configurations available through mapped subscription.
  exocomputeConfigs: [AzureExocomputeConfigDetails!]!
}
# Azure subscription with features.
type AzureSubscriptionWithFeaturesType {
  # Azure subscription cloud account ID.
  id: String!

  # Azure subscription native ID.
  nativeId: String!

  # Azure subscription native name.
  name: String!

  # Azure tenant ID.
  customerTenantId: String!

  # Feature details for the cloud account.
  featureDetails: [AzureCloudAccountFeatureDetail!]!
}
# Azure Tag.
type AzureTag {
  # Key of the Azure tag.
  key: String!

  # Value of the Azure tag.
  value: String!
}
# Specific info for Azure Target Template.
type AzureTargetTemplate implements TargetTemplate {
  storageAccountName: String!
  containerNamePrefix: String!
  instanceType: InstanceTypeEnum!
  computeSettings: AzureComputeSettings
  proxySettings: ProxySettings
  isConsolidationEnabled: Boolean!
  cloudNativeCompanion: AzureCloudNativeTargetCompanion
  cloudAccount: CloudAccount!

  # The type of this Target.
  targetType: TargetTypeEnum!
}
# Azure user-assigned Managed Identity details.
type AzureUserAssignedManagedIdentity {
  # Name of the managed identity.
  name: String!

  # Native ID of the managed identity.
  nativeId: String!

  # ID of the service principal object associated with the managed identity.
  principalId: String!
}
# Input to filter Azure Virtual Machines based on RBS connection status.
input AzureVmCcOrCnpRbsConnectionStatusFilter {
  # Connection status of the Rubrik Backup Service (RBS) installed on the instance.
  status: CloudInstanceRbsConnectionStatus!
}
type BackupWindow {
  durationInHours: Int!
  startTimeAttributes: StartTimeAttributes
}
type BasicSnapshotSchedule {
  frequency: Int!
  retention: Int!
  retentionUnit: RetentionUnitEnum!
}
type BatchAsyncJobStatus {
  # List of map of Rubrik object ID to Job ID for object if pre validation succeeds for object. If pre validation failed, detials will be present in error field.
  jobIds: [AsyncJobStatusJobId!]!

  # List of map of Rubrik object ID to error message for those object for which pre validation failed.
  errors: [AsyncJobStatusJobError!]!
}
type BidirectionalReplicationSpec {
  replicationSpec1: UnidirectionalReplicationSpec
  replicationSpec2: UnidirectionalReplicationSpec
}
# The `Boolean` scalar type represents `true` or `false`.
scalar Boolean
# Cascading archival spec info.
type CascadingArchivalSpec {
  # Threshold after which the snapshot will be archived.
  archivalThreshold: Duration

  # Archival tiering specification.
  archivalTieringSpec: ArchivalTieringSpec

  # Frequencies that are associated with this cascaded archival location.
  frequency: [RetentionUnitEnum!]!

  # Archival location for snapshot on target.
  archivalLocation: Target
}
# Status of Job.
enum CcpJobStatus {
  # Bootstrapping cluster.
  BOOTSTRAPPING

  # Completed successfully.
  COMPLETED

  # Failed.
  FAILED

  # Initializing.
  INITIALIZING

  # Invalid status.
  INVALID

  # Node connection verify.
  NODE_CONNECTION_VERIFICATION

  # Node creation.
  NODE_CREATE

  # Node information retrieval.
  NODE_INFO_EXTRACTION

  # Rotate token.
  ROTATE_TOKEN
}
# Type of cluster job.
enum CcpJobType {
  # Add a node to cluster.
  ADD_NODE

  # Create cluster job.
  CLUSTER_CREATE

  # Delete cluster job.
  CLUSTER_DELETE

  # Remove node from cluster.
  REMOVE_NODE
}
# Cloud vendor provider.
enum CcpVendorType {
  # AWS.
  AWS

  # Azure.
  AZURE

  # GCP.
  GCP
}
# Metadata for a single cluster job.
type CcprovisionInfo {
  # Cloud vendor provider.
  vendor: CcpVendorType!

  # Current job status.
  jobStatus: CcpJobStatus!

  # Progress of job in percent.
  progress: Int!

  # Type of running job.
  jobType: CcpJobType!

  # Cloud cluster configuration.
  marshaledConfig: String!
}
type CdmClusterStatus {
  # Rubrik cluster upgrade status. The value reflects the status of the Rubrik cluster at the various stages involved in an upgrade, for example, pre-check, download, upgrade scheduling, and rollback of the upgrade.
  status: CdmClusterStatusTypeEnum!

  # Rubrik cluster status message.
  message: String

  # Status of the Rubrik cluster upgrade process including information about the tasks that have been completed and tasks that are pending or ongoing.
  statusInfo: CdmClusterStatusInfo
}
type CdmClusterStatusInfo {
  # A list of upgrade states that are completed.
  finishedStates: String

  # A list of upgrade states that are pending.
  pendingStates: String

  # The upgrade task running at the time of the query.
  currentTask: String

  # The upgrade state running at the time of the query.
  currentState: String

  # Overall upgrade progress percentage.
  overallProgress: String

  # Progress percentage of the current upgrade state.
  currentStateProgress: String

  # Total number of nodes in the Rubrik cluster.
  totalNodes: String

  # Number of nodes where rolling upgrade is complete.
  completedNodes: String

  # Node going through rolling upgrade currently.
  currentNode: String

  # Upgrade state of the node going through the rolling upgrade currently.
  currentNodeState: String

  # Download package version.
  downloadVersion: String

  # Download progress.
  downloadProgress: String

  # Time, in seconds, remaining for the download to complete.
  downloadRemainingTimeEstimateInSeconds: String

  # Status of the download job.
  downloadJobStatus: String
}
enum CdmClusterStatusTypeEnum {
  Disconnected
  DownloadPackageFailed
  DownloadingPackage
  FailedToInitiateUpgrade
  OnOldRelease
  PrechecksFailureError
  PrechecksFailureWarning
  PrechecksRunning
  ReadyForDownload
  ReadyForUpgrade
  ResumingUpgrade
  RollbackFailed
  RollingBackUpgrade
  Stable
  StableWithUpgradeInfo
  Unknown
  UpgradeFailed
  UpgradeRecommended
  UpgradeScheduled
  UpgradeScheduledWithWarning
  Upgrading
}
# A Rubrik CDM Managed Hierarchy object.
interface CdmHierarchyObject {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
type CdmHostVolume {
  clusterUuid: String!
  cdmId: String!
  mountPoints: [String!]!
  fileSystemType: String
  size: Long

  # Host volume's ID.
  volumeId: String!

  # ID of the volume group to which this volume belongs.
  volumeGroupId: String
}
# Specific info for AWS target created on Cdm.
type CdmManagedAwsTarget implements Target {
  # Id of the AWS location.
  id: String!

  # Region of the AWS location.
  region: AwsRegion!

  # Immutability info of Aws location.
  immutabilitySettings: AwsImmutabilitySettingsType

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific info for Azure target created on Cdm.
type CdmManagedAzureTarget implements Target {
  # ID of the Azure location.
  id: String!

  # Specifies whether Azure archival tiering is supported or not.
  isAzureTieringSupported: Boolean

  # Instance type of the Azure location.
  instanceType: InstanceTypeEnum!

  # Immutability info of Azure location.
  immutabilitySettings: AzureImmutabilitySettingsType

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific info for Gcp target created on Cdm.
type CdmManagedGcpTarget implements Target {
  # Id of the GCP location.
  id: String!

  # Region of the GCP location.
  region: GcpRegionEnum!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific info for Nfs target created on Cdm.
type CdmManagedNfsTarget implements Target {
  # Id of the Nfs location.
  id: String!

  # Host of the Nfs location.
  host: String!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific info for S3Compatible created on Cdm.
type CdmManagedS3CompatibleTarget implements Target {
  # Id of the S3Compatible location.
  id: String!

  # Host of the S3Compatible location.
  endpoint: String!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# The node details of a Rubrik CDM cluster.
type CdmNodeDetail {
  # Rubrik cluster node ID.
  nodeId: String!

  # Rubrik cluster UUID.
  clusterId: UUID!

  # Data IP address of the Rubrik cluster node.
  dataIpAddress: String!

  # IPMI IP address of the Rubrik cluster node. Not available for virtual or cloud cluster nodes.
  ipmiIpAddress: String
}
# Target-specific information created and synchronized from a Rubrik CDM cluster.
type CdmTarget implements Target {
  id: String!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
type CdmUpgradeInfo {
  # The cluster UUID.
  clusterUuid: UUID!

  # Version of the Rubrik cluster.
  version: String!

  # Downloaded version of tarball.
  downloadedVersion: String

  # Cluster job status.
  clusterJobStatus: ClusterJobStatusTypeEnum

  # Upgrade state machine status.
  stateMachineStatus: String

  # The time at which the state machine was last updated..
  stateMachineStatusAt: DateTime

  # Scheduled-Upgrade timestamp.
  scheduleUpgradeAt: DateTime

  # Scheduled-Upgrade mode.
  scheduleUpgradeMode: String

  # Scheduled-Upgrade action.
  scheduleUpgradeAction: String

  # Current running state progress percentage.
  currentStateProgress: Float

  # Overall upgrade progress.
  overallProgress: Float

  # The time at which the upgrade started.
  upgradeStartAt: DateTime

  # The time at which the upgrade ended.
  upgradeEndAt: DateTime

  # The version of the cluster before the upgrade.
  previousVersion: String

  # Version status of the Rubrik cluster.
  versionStatus: VersionStatusTypeEnum

  # Recommended upgrade version of the Rubrik cluster.
  upgradeRecommendationInfo: UpgradeRecommendationInfo

  # Pending states of upgrade.
  pendingStates: String

  # Finished states of upgrade.
  finishedStates: String

  # Status of the Rubrik cluster.
  clusterStatus: CdmClusterStatus

  # You are authorized to perform operations on the Rubrik cluster.
  authorizedOperations: AuthorizedOperations!

  # The upgrade event series ID.
  upgradeEventSeriesId: String

  # Time taken by the last upgrade.
  lastUpgradeDuration: UpgradeDurationReply
}
# Cloud Account (AWS, Azure etc.) information.
interface CloudAccount {
  # The ID of this Cloud Account.
  cloudAccountId: String!

  # The name of this Cloud Account.
  name: String!

  # The description of this Cloud Account.
  description: String

  # The type of this Cloud Provider.
  cloudProvider: CloudAccountType!

  # The connection status of this Cloud Account.
  connectionStatus: ConnectionStatusType!
}
# Actions that can be performed on a cloud account.
enum CloudAccountAction {
  # Create a cloud account.
  CREATE

  # Delete a cloud account.
  DELETE

  # Update child accounts of a cloud account.
  UPDATE_CHILD_ACCOUNTS

  # Update permissions of a cloud account.
  UPDATE_PERMISSIONS

  # Update regions in a cloud account.
  UPDATE_REGIONS
}
# Cloud account features.
enum CloudAccountFeature {
  # All cloud account features.
  ALL

  # Cloud account feature is App Flows.
  APP_FLOWS

  # Cloud account feature is Archival.
  ARCHIVAL

  # Cloud account feature is Azure SQL DB Protection.
  AZURE_SQL_DB_PROTECTION

  # Cloud account feature is Azure SQL MI Protection.
  AZURE_SQL_MI_PROTECTION

  # Cloud account feature is Cloud Accounts.
  CLOUDACCOUNTS

  # Cloud account feature is Cloud Native Archival.
  CLOUD_NATIVE_ARCHIVAL

  # Cloud account feature is Cloud Native Archival Encryption.
  CLOUD_NATIVE_ARCHIVAL_ENCRYPTION

  # Cloud account feature is Cloud Native Protection.
  CLOUD_NATIVE_PROTECTION

  # Cloud account feature is Exocompute.
  EXOCOMPUTE

  # Cloud account feature is GCP Shared VPC Host.
  GCP_SHARED_VPC_HOST

  # Cloud account feature is RDS Protection.
  RDS_PROTECTION

  # Cloud account feature is Servers and Apps.
  SERVERS_AND_APPS
}
# Cloud account statuses.
enum CloudAccountStatus {
  # Cloud account is connected.
  CONNECTED

  # Cloud account is connecting.
  CONNECTING

  # Cloud account is disabled.
  DISABLED

  # Cloud account is disconnected.
  DISCONNECTED

  # Cloud account requires additional permissions.
  MISSING_PERMISSIONS
}
# Cloud account type.
enum CloudAccountType {
  # Cloud account type is AWS.
  CLOUD_ACCOUNT_AWS

  # Cloud account type is role-based AWS.
  CLOUD_ACCOUNT_AWS_ROLE_BASED

  # Cloud account type is Azure.
  CLOUD_ACCOUNT_AZURE

  # Cloud account type is role-based Azure.
  CLOUD_ACCOUNT_AZURE_ROLE_BASED

  # Cloud account type is GCP.
  CLOUD_ACCOUNT_GCP

  # Cloud account type is unknown.
  UNKNOWN_CLOUD_ACCOUNT
}
# RBS Connection Status.
enum CloudInstanceRbsConnectionStatus {
  # RBS Agent on the host is connected.
  CONNECTED

  # RBS Agent on the host is disconnected.
  DISCONNECTED

  # RBS Agent connection status unknown.
  NA
}
# Filter cloud instances based on whether they have been added as hosts to a Rubrik Cluster.
input CloudNativeInstaceAppProtectionFilter {
  # Boolean value to filter cloud instances added as hosts to a Rubrik Cluster.
  isProtectionSetup: Boolean!
}
# The archival location template types.
enum CloudNativeLocTemplateType {
  # Cloud native location type is invalid.
  INVALID

  # Specfies that the target archival location should be in the same region as that of source snappable.
  SOURCE_REGION

  # Specifies that target archival location should be in a specified region irrespective of the region of the source snappables.
  SPECIFIC_REGION
}
# Cloud-native Rubrik Backup Service(RBS) status.
enum CloudNativeRbaStatusType {
  # Cloud native RBS status is Not Registered.
  NOT_REGISTERED

  # Cloud native RBS status is Registered.
  REGISTERED

  # Cloud native RBS status is Unavailable.
  UNAVAILABLE
}
# Cloud provider.
enum CloudProvider {
  # Cloud provider is AWS.
  AWS

  # Cloud provider is Azure.
  AZURE
}
# Cloud provider type.
enum CloudVendor {
  # Cloud provider is AWS.
  AWS

  # Cloud provider is Azure.
  AZURE

  # Cloud provider is GCP.
  GCP
}
# A Rubrik CDM Cluster.
type Cluster {
  # The cluster uuid.
  id: UUID!

  # The cluster name.
  name: String!

  # The cluster's default address.
  defaultAddress: String

  # System status of the cluster. For Mosaic clusters and Rubrik clusters running CDM versions earlier than 5.0, this value is null.
  systemStatus: ClusterSystemStatus

  # Pause status of the cluster.
  pauseStatus: ClusterPauseStatus

  # Human readable message explaining the systemStatus.
  systemStatusMessage: String

  # List of affected nodes in the cluster.
  systemStatusAffectedNodes: [ClusterNode!]

  # The time the cluster was registered.
  registrationTime: DateTime!

  # The time the cluster was last connected.
  lastConnectionTime: DateTime

  # The cluster product type (e.g., CDM, DATOS, etc.).
  productType: ClusterProductEnum

  # The software version.
  version: String

  # Whether or not the cluster is encrypted.
  encryptionEnabled: Boolean!

  # The number of days remaining before the system fills up.
  estimatedRunway: Long!

  # The total number of snapshots.
  snapshotCount: Long!

  # The cluster type.
  type: ClusterTypeEnum!

  # The cluster status.
  status: ClusterStatus!

  # The cluster state.
  state: clusterState!

  # Whether or not the cluster is healthy.
  isHealthy: Boolean! @deprecated(reason: "Use systemStatus instead.")

  # The cluster's location.
  geoLocation: GeoLocation

  # The cluster's timezone.
  timezone: String

  # The cluster's global manager connectivity status.
  globalManagerConnectivityStatus: GlobalManagerConnectivity

  # Whether the global manager connectivity is healthy.
  passesConnectivityCheck: Boolean

  # When the global manager connectivity was last updated.
  connectivityLastUpdated: DateTime

  # The cluster's archival locations.
  archivalLocations: [ArchivalLocation!]!

  # The cluster's replication sources.
  replicationSources: [ReplicationSource!]!

  # The cluster's replication targets.
  replicationTargets: [ReplicationTarget!]!

  # The most recent metric of a cluster.
  metric: ClusterMetric

  # The metric time series of a cluster.
  metricTimeSeries(
    # Time range input.
    timeRange: TimeRangeInput, unit: TimeUnitEnum!): [metricTimeSeries!]!

  # This field contains information about the various jobs that sync data from the CDM cluster to Polaris.
  polarisSyncStatus: PolarisSyncStatus!

  # The cluster's activity series.
  activitySeriesConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort activity series by field.
    sortBy: ActivitySeriesSortByEnum = LastUpdated, filters: ActivitySeriesFilterInput): ActivitySeriesConnection!

  # The cluster's snappables.
  snappableConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Filter protected objects by input.
    filter: SnappableFilterInput): SnappableConnection!

  # The cluster nodes.
  clusterNodeConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Rubrik Cluster node filter.
    filter: ClusterNodeFilterInput): ClusterNodeConnection!

  # The CDM cluster node details.
  cdmClusterNodeDetails: [CdmNodeDetail!]!

  # The node-level performance statistics of a Rubrik cluster.
  clusterNodeStats(
    # Rubrik cluster node ID.
    cdmClusterNodeID: String,

    # Time range input.
    timeRange: TimeRangeInput): [ClusterNodeStats!]!

  # The cluster disks.
  clusterDiskConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Rubrik Cluster disk filter.
    filter: ClusterDiskFilterInput): ClusterDiskConnection!

  # Lambda configuration.
  lambdaConfig: GetLambdaConfigReply

  # Lambda feature history.
  lambdaFeatureHistory: LambdaFeatureHistory

  # Sonar previewer configuration.
  datagovPreviewerConfig: PreviewerClusterConfig!

  # Metadata pull scheduler.
  metadataPullScheduler: JobsReply

  # Cluster upgrade information.
  cdmUpgradeInfo: CdmUpgradeInfo

  # Job status of a create cluster operation.
  ccprovisionInfo: CcprovisionInfo

  # Cloud information for this cluster.
  cloudInfo: ClusterCloudInfoReply

  # Operations that the user is authorized to perform on the Rubrik cluster.
  authorizedOperations: AuthorizedOperations!

  # Total number of protected NoSql workloads.
  noSqlSnappableCount: Int!
}
type ClusterArchivalSpec {
  archivalLocationName: String!
  archivalLocationId: String!
  threshold: Int!
  thresholdUnit: RetentionUnitEnum!
  archivalTieringSpec: ArchivalTieringSpec

  # Archives all snapshots taken with the specified frequency.
  frequencies: [RetentionUnitEnum!]!
}
# Cloud information for a cloud cluster.
type ClusterCloudInfoReply {
  # Cloud vendor name.
  vendor: CcpVendorType!

  # User-friendly name for the cloud region.
  region: String!

  # ID for the cloud region.
  regionId: String!

  # Customer cloud account name.
  cloudAccount: String!
}
type ClusterDisk {
  status: ClusterDiskStatus!
  isEncrypted: Boolean!
  diskType: ClusterDiskType!
  nodeId: String
  capacityBytes: Long!
  path: String!
  unallocatedBytes: Long
  usableBytes: Long
  clusterId: UUID!

  # LED status of the disk, where true means ON and false is OFF.
  ledStatus: Boolean

  # Disk serial ID.
  serial: String
  id: String!
}
# Paginated list of ClusterDisk objects.
type ClusterDiskConnection {
  # List of ClusterDisk objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [ClusterDiskEdge!]!

  # List of ClusterDisk objects.
  nodes: [ClusterDisk!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of ClusterDisk objects matching the request arguments.
  count: Int!
}
# Wrapper around the ClusterDisk object. This wrapper is used for pagination.
type ClusterDiskEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual ClusterDisk object wrapped by this edge.
  node: ClusterDisk!
}
# Filters for the list of Rubrik cluster disks.
input ClusterDiskFilterInput {
  # The type of the Rubrik cluster disk.
  type: ClusterDiskType

  # The status of the Rubrik cluster disk.
  status: ClusterDiskStatus

  # The Rubrik cluster node ID.
  nodeId: String
}
# Enum representing the cluster's knowledge of a disk state.
enum ClusterDiskStatus {
  # Mounted disk.
  ACTIVE

  # Mounted disk continuously failing health checks.
  FAILED

  # Self encrypting disk in locked state (only for appliances supporting hardware encryption).
  LOCKED

  # Disk present in node table but not on the node.
  MISSING

  # Disk needs replacement. The disk is still readable but SDFS will drain the data gradually in the background.
  PRE_REMOVAL

  # Disk needs software repair (e.g, fsck) and is not writable.
  PRE_REPAIR

  # Disk finished draininig. User can unplug the disk.
  READY_TO_REMOVE

  # Disk explicitly removed from the cluster.
  REMOVED

  # Disk is under repair (e.g., fsck) and is not available. The expectation is that the disk will become available soon but is not guaranteed. Both read and write operations will not be allowed in this status.
  REPAIR

  # Disk with no ext4 partitions.
  UNFORMATTED

  # Unused.
  UNKNOWN
}
enum ClusterDiskType {
  FLASH
  HDD
  UNKNOWN
}
# Cluster interface CIDR map.
type ClusterInfCidrs {
  clusterName: String!
  clusterId: String!
  interfaceCidr: [InterfaceCidr!]!
}
enum ClusterJobStatusTypeEnum {
  DownloadPackageFailed
  DownloadingPackage
  FailedToInitiateUpgrade
  PreCheckFailureError
  PreCheckFailureWarning
  ReadyForDownload
  ReadyForUpgrade
  ResumingUpgrade
  RollbackFailed
  RollingBackUpgrade
  Unknown
  UpToDate
  UpgradeFailed
  Upgrading
}
type ClusterMetric {
  availableCapacity: Long!
  usedCapacity: Long!
  totalCapacity: Long!
  snapshotCapacity: Long!
  liveMountCapacity: Long!
  miscellaneousCapacity: Long!
  ingestedSnapshotStorage: Long!
  physicalSnapshotStorage: Long!

  # Ingested bytes for archived snapshots.
  ingestedArchivalStorage: Long!

  # Physical bytes for archived snapshots.
  physicalArchivalStorage: Long!
  lastUpdateTime: DateTime!
}
union ClusterMetricGroupByInfo = TimeRangeWithUnit
type ClusterNode {
  brikId: String!
  status: ClusterNodeStatus
  ipAddress: String
  needsInspection: Boolean

  # CPU cores count of the Rubrik cluster node.
  cpuCores: Int

  # RAM of the Rubrik cluster node, in bytes.
  ram: Long
  clusterId: UUID!

  # Network speed of the Rubrik cluster node.
  networkSpeed: String

  # Hostname of the Rubrik cluster node.
  hostname: String

  # Rear view position of the Rubrik cluster node.
  position: ClusterNodePosition
  id: String!

  # Network interface of a Rubrik cluster node.
  interfaceCidrs: [ClusterNodeInterfaceCidr!]

  # Hardware health status of a Rubrik cluster node. The value is null when hardware health status is not available.
  hardwareHealth: [HealthPolicyStatus!]
}
# Paginated list of ClusterNode objects.
type ClusterNodeConnection {
  # List of ClusterNode objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [ClusterNodeEdge!]!

  # List of ClusterNode objects.
  nodes: [ClusterNode!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of ClusterNode objects matching the request arguments.
  count: Int!
}
# Wrapper around the ClusterNode object. This wrapper is used for pagination.
type ClusterNodeEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual ClusterNode object wrapped by this edge.
  node: ClusterNode!
}
# Filters for the list of Rubrik cluster node.
input ClusterNodeFilterInput {
  # The status of the Rubrik cluster node.
  status: ClusterNodeStatus

  # The Rubrik cluster node ID.
  nodeId: String
}
# Network interface of a Rubrik cluster node.
type ClusterNodeInterfaceCidr {
  # Name of the interface.
  interfaceName: String!

  # CIDR address for the interface.
  cidr: String!
}
# Represents the position of the node in a Rubrik chassis.
enum ClusterNodePosition {
  # Left bottom node in the Rubrik chassis.
  LEFT_BOTTOM

  # Left top node in the Rubrik chassis.
  LEFT_TOP

  # Right bottom node in the Rubrik chassis.
  RIGHT_BOTTOM

  # Right top node in the Rubrik chassis.
  RIGHT_TOP
}
# The node-level performance statistics of a Rubrik cluster.
type ClusterNodeStats {
  # CPU utilization of the node.
  cpuStat: Long!

  # Data received over the network, in bytes per second.
  networkBytesReceived: Long!

  # Data transmitted over the network, in bytes per second.
  networkBytesTransmitted: Long!

  # Input/output read operations per second.
  iopsReadsPerSecond: Long!

  # Input/output write operations per second.
  iopsWritesPerSecond: Long!

  # Read Input/output throughput, in bytes per second.
  readThroughputBytesPerSecond: Long!

  # Write Input/output throughput, in bytes per second.
  writeThroughputBytesPerSecond: Long!

  # Time at which the performance metrics were retrieved.
  time: DateTime!

  # Rubrik cluster UUID.
  clusterId: UUID!

  # Rubrik cluster node ID.
  nodeId: String!
}
# Represents the status of the node in a Rubrik cluster.
enum ClusterNodeStatus {
  # Node is unhealthy.
  BAD

  # Node is being bootstrapped with the Rubrik cluster. This state precedes the OK state and the node services will not be functional until the node transitions to status OK.
  BOOTSTRAPPING

  # Node is joining the cluster.
  JOINING

  # Node is down for maintenance.
  MAINTENANCE

  # Node is healthy and normal operation is expected.
  OK

  # Node is being taken down for maintenance. After all sanity checks, the node status will change to MAINTENANCE state.
  PRE_MAINTENANCE

  # Node has been removed from the cluster.
  REMOVED

  # Node status is not known.
  UNKNOWN

  # Node is being upgraded. The node will not accept any new jobs and the upgrade operation will begin after existing jobs are completed.
  UPGRADE
}
# Pause Status of the cluster.
enum ClusterPauseStatus {
  # Cluster not paused.
  NOT_PAUSED

  # Cluster paused.
  PAUSED

  # Unknown Status.
  UNKNOWN
}
enum ClusterProductEnum {
  CDM
  DATOS
  POLARIS
}
enum ClusterRemovalState {
  DATA_DELETING
  DISCONNECTING
  FAILED
  REGISTERED
  UNREGISTERED
  WAITING_FOR_DATA_DELETION
}
type ClusterSlaDomain implements SlaDomain {
  name: String!
  version: String
  fid: String!
  snapshotSchedule: SnapshotSchedule
  baseFrequency: Duration
  localRetentionLimit: Duration
  archivalSpec: ClusterArchivalSpec

  # List of archival specifications for SLA Domain.
  archivalSpecs: [ClusterArchivalSpec!]!
  replicationSpec: ReplicationSpec
  replicationSpecsV2: [ReplicationSpecV2!]!
  firstFullBackupWindows: [BackupWindow!]!
  backupWindows: [BackupWindow!]!
  polarisManagedId: String
  protectedObjectCount: Int!

  # SLA Domain upgrade information.
  upgradeInfo: SlaUpgradeInfo

  # Specifies if this SLA Domain is Retention Locked or not.
  isRetentionLockedSla: Boolean!

  # The object-specific configurations of the SLA Domain.
  objectSpecificConfigs: ObjectSpecificConfigs
  cluster: Cluster
  id: String!
  cdmId: String!
}
enum ClusterStatus {
  Connected
  Disconnected
  Initializing
}
# Cluster system status.
enum ClusterSystemStatus {
  # Several nodes are experiencing failures.
  FATAL

  # All nodes are functioning normally.
  OK

  # Some nodes are experiencing failures.
  WARNING
}
enum ClusterTypeEnum {
  Cloud
  ExoCompute
  OnPrem
  Polaris
  Robo
  Unknown
}
# Available cold storage class options for tiering.
enum ColdStorageClass {
  # Glacier cold storage class for AWS.
  AWS_GLACIER

  # GDA cold storage class for AWS.
  AWS_GLACIER_DEEP_ARCHIVE

  # Archive cold storage tier for Azure.
  AZURE_ARCHIVE
  COLD_STORAGE_CLASS_UNKNOWN
}
# Filter cluster data.
input CommonClusterFilterInput {
  id: [UUID!]
  type: [ClusterTypeEnum!]
}
# Input for completing authentication of the Azure Cloud Accounts.
input CompleteAzureCloudAccountOauthInput {
  # Session ID of the current OAuth session.
  sessionId: String!

  # Domain name of the Azure Tenant.
  tenantDomainName: String!

  # Authorization code received after the OAuth consent flow. For more information, see https://auth0.com/docs/flows/authorization-code-flow.
  authorizationCode: String!

  # Redirect URL used in the OAuth flow.
  redirectUrl: String!

  # Features enabled on the Azure Cloud Account.
  features: [CloudAccountFeature!]!

  # Client ID of the application. The appID is empty if the tenant uses a Rubrik app or a custom app.
  appId: String

  # Client secret key of the application. The appSecretKey is empty if the tenant uses a Rubrik app or a custom app.
  appSecretKey: String

  # Specifies whether to skip permission checks of Azure subscriptions required for addition.
  shouldSkipPermissionChecks: Boolean!

  # Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud.
  azureCloudType: AzureCloudType = AZUREPUBLICCLOUD

  # The resource that requires OAuth access.
  resource: AzureOauthResource = AZURE_RESOURCE_MANAGER

  # Ensures that only basic OAuth is performed. The session will be stored in Rubrik, however, no additional information (such as list of subscriptions) is returned.
  performBasicOauth: Boolean = false
}
# Response of the operation to complete Azure Cloud Account OAuth.
type CompleteAzureCloudAccountOauthReply {
  # Specifies whether the OAuth authentication was completed successfully. When true, it means the authentication was successful.
  isSuccess: Boolean!

  # Subscriptions for which the OAuth user has read permission on Azure.
  subscriptions: [AzureCloudAccountSubscription!]!
}
enum ComplianceStatusEnum {
  Empty
  InCompliance
  NotApplicable
  NotAvailable
  Null
  OutOfCompliance
  Unprotected
}
# The connection status type enum.
enum ConnectionStatusType {
  # The connection has been connected.
  CONNECTED

  # The connection has been disconnected.
  DISCONNECTED
}
# Input to create AWS exocompute configurations.
input CreateAwsExocomputeConfigsInput {
  # Rubrik ID for cloud account.
  cloudAccountId: UUID!

  # List of exocompute configurations for the cloud account.
  configs: [AwsExocomputeConfigInput!]!

  # Specifies whether to start Exocompute health check.
  triggerHealthCheck: Boolean = false
}
# AWS Exocompute Configs Create Response.
type CreateAwsExocomputeConfigsReply {
  # List of exocompute configurations.
  configs: [AwsExocomputeGetConfigResponse!]!
}
type DailySnapshotSchedule {
  basicSchedule: BasicSnapshotSchedule
}
type DataLocation {
  id: String!
  createDate: DateTime!
  isActive: Boolean!
  isArchived: Boolean!
  type: LocationTypeEnum!
  clusterUuid: UUID!

  # The name of the data location.
  name: String!
}
# DateTime.
scalar DateTime
enum DayOfMonth {
  FIFTEENTH
  FIRST_DAY
  LAST_DAY
}
enum DayOfQuarter {
  FIRST_DAY
  LAST_DAY
}
# Specifies the day of the week.
enum DayOfWeek {
  # Indicates Friday.
  FRIDAY

  # Indicates Monday.
  MONDAY

  # Indicates Saturday.
  SATURDAY

  # Indicates Sunday.
  SUNDAY

  # Indicates Thursday.
  THURSDAY

  # Indicates Tuesday.
  TUESDAY

  # Indicates Wednesday.
  WEDNESDAY
}
type DayOfWeekOpt {
  day: DayOfWeek!
}
enum DayOfYear {
  FIRST_DAY
  LAST_DAY
}
# The SLA Domain configuration for Db2 database.
type Db2Config {
  # Frequency value for incremental backup of Db2 databases.
  incrementalFrequency: Duration

  # Specifies the number of days for which the Db2 database logs will be retained.
  logRetention: Duration

  # Frequency value for differential backup of Db2 databases.
  differentialFrequency: Duration
}
interface Db2InstanceDescendantType {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
interface Db2InstancePhysicalChildType {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Represents a DB parameter group in AWS.
type DbParameterGroup {
  # Name of the DB parameter group.
  name: String!

  # Family name of the DB parameter group.
  family: String!

  # Amazon Resource Name (ARN) of the DB parameter group.
  arn: String!
}
# Input to delete AWS exocompute configurations.
input DeleteAwsExocomputeConfigsInput {
  # IDs of exocompute configurations to be deleted.
  configIdsToBeDeleted: [UUID!]!
}
# AWS Exocompute Configs Delete Response.
type DeleteAwsExocomputeConfigsReply {
  # Deletion status for exocompute configurations.
  deletionStatus: [AwsExocomputeConfigsDeletionStatusType!]!
}
# Input for deleting Exocompute configurations for an Azure Cloud Account.
input DeleteAzureCloudAccountExocomputeConfigurationsInput {
  # Rubrik IDs of the cloud accounts to be deleted.
  cloudAccountIds: [UUID!]!
}
# Response of the operation to delete Exocompute Configuration from the Azure Cloud Account.
type DeleteAzureCloudAccountExocomputeConfigurationsReply {
  # IDs of the Azure Cloud Accounts that were deleted successfully.
  deletionSuccessIds: [String!]!

  # IDs of the Azure Cloud Accounts that could not be deleted.
  deletionFailedIds: [String!]!
}
# Input for deleting an Azure Cloud Account.
input DeleteAzureCloudAccountInput {
  # Session ID of the current OAuth session.
  sessionId: String!

  # Features enabled on the Azure Cloud Account.
  features: [CloudAccountFeature!]!

  # Rubrik IDs of the subscriptions to be deleted.
  azureSubscriptionRubrikIds: [UUID!]!
}
# Response of the operation to delete Azure Cloud Account.
type DeleteAzureCloudAccountReply {
  # Status of the operation to delete Azure Cloud Account.
  status: [DeleteAzureCloudAccountStatus!]!
}
# Status of the operation to delete Azure Cloud Account.
type DeleteAzureCloudAccountStatus {
  # Native ID of the Azure Subscription.
  azureSubscriptionNativeId: String!

  # Specifies whether the deletion of Azure Cloud Account was successful. When true, the deletion was successful.
  isSuccess: Boolean!

  # Error received during deletion of Azure Cloud Account.
  error: String!
}
# Input for deleting an Azure Cloud Account without OAuth.
input DeleteAzureCloudAccountWithoutOauthInput {
  # Features enabled on the Azure Cloud Account.
  features: [CloudAccountFeature!]!

  # Rubrik IDs of the subscriptions to be deleted.
  azureSubscriptionRubrikIds: [UUID!]!
}
# Response of the operation to delete Azure Cloud Account without OAuth.
type DeleteAzureCloudAccountWithoutOauthReply {
  # Status of the operation to delete Azure Cloud Account.
  status: [DeleteAzureCloudAccountStatus!]!
}
# DevicePathToVolumeSnapshotId type to take key value input.
type DevicePathToVolumeSnapshotId {
  # Key representing device path.
  key: String!

  # Value representing volume snapshot ID.
  value: String!
}
# DevicePathToVolumeSnapshotIdMap type to take map input.
type DevicePathToVolumeSnapshotIdMap {
  # List of key-value pairs that map device path to volume snapshot.
  devicePathToVolumeSnapshotIdList: [DevicePathToVolumeSnapshotId!]!
}
# Information about the archival location.
type DlsArchivalLocation {
  # ID of the archival location.
  id: UUID!

  # Name of the archival location.
  name: String!
}
type Duration {
  duration: Int!
  unit: RetentionUnitEnum!
}
# Filter to return objects with an effective SLA Domain ID that matches one of the specified SLA Domain IDs.
input EffectiveSlaFilter {
  effectiveSlaIds: [String!]!
}
# An Event Digest.
type EventDigest {
  # Account related to the event digest.
  account: String!

  # ID of the event digest.
  digestId: Int!

  # Name of the event digest.
  digestName: String!

  # Frequency, in hours, with which the event digests are sent.
  frequency: Int!

  # Specifies whether to send the event digest immediately.
  isImmediate: Boolean!

  # Event digest configuration.
  eventDigestConfigJson: String!

  # User ID of the recipient.
  recipientUserId: String!

  # Specifies whether to include audits in the event digest.
  includeAudits: Boolean!

  # Specifies whether to include events in the event digest.
  includeEvents: Boolean!
}
# Input to mark volumes to be excluded for EC2 snapshot.
input ExcludeAwsNativeEbsVolumesFromSnapshotInput {
  # Rubrik ID of EC2 instance.
  awsNativeEc2InstanceId: UUID!

  # List of maps of Rubrik IDs to excluded status of volumes.
  volumeIdExclusions: [VolumeIdExclusion!]!
}
# Inputs to trigger Exclusion of Azure Native Managed Disk From Snapshot.
input ExcludeAzureNativeManagedDisksFromSnapshotInput {
  # Rubrik ID of the virtual machine (VM).
  virtualMachineRubrikId: UUID!

  # A list that specifies which disks are excluded from snapshots of the virtual machine.
  managedDiskExclusions: [ManagedDiskExclusion!]!
}
# Details of an existing user.
type ExistingUser {
  # ID of the user.
  id: String!

  # Specifies whether the user is an org admin.
  isOrgAdmin: Boolean!

  # Specifies user details.
  user: User!
}
# Describes the Exocompute health check status.
type ExocomputeHealthCheckStatus {
  # Status of the health check.
  status: ExocomputeHealthCheckStatusValue!

  # Time of last update for the health check status.
  lastUpdatedAt: DateTime

  # ID for the health check status job.
  taskchainId: String!

  # Reason for the health check failure.
  failureReason: String!
}
# Status values for Exocompute health check.
enum ExocomputeHealthCheckStatusValue {
  # Exocompute is healthy.
  HEALTHY

  # Health check job failed to determine the Exocompute health status.
  JOB_UNSUCCESSFUL

  # Exocompute is not healthy.
  UNHEALTHY

  # Health check status is unknown.
  UNKNOWN

  # Health check is in progress.
  VERIFYING
}
# Feature specific details for a cloud account.
type FeatureDetail {
  # Feature enum.
  feature: CloudAccountFeature!

  # Role ARN for feature. This field has a non-empty value only for CFT-based accounts.
  roleArn: String!

  # Stack ARN for feature. This field has a non-empty value only for CFT-based accounts.
  stackArn: String!

  # Feature status for a cloud account.
  status: CloudAccountStatus!

  # AWS regions. The list will be non-empty for cloud accounts on AWS GovCloud and commercial clouds.
  awsRegions: [AwsCloudAccountRegion!]!

  # User ARN for feature. This field has a non-empty value only for accounts with an IAM user credential provider.
  userArn: String

  # IAM user access key for feature. This field has a non-empty value only for accounts with an IAM user credential provider.
  accessKey: String

  # Details for authentication server-based cloud accounts. This field is only applicable to the accounts in AWS DCA and LCK regions.
  authServerDetail: AwsAuthServerDetail
}
enum FieldEnum {
  ALL
  IS_COMPLETE
  IS_CORRUPTED
  IS_DELETED_FROM_SOURCE
  IS_EXPIRED
  IS_HINT_SET
  IS_INDEXED
  IS_INDEX_MERGED
  IS_ON_DEMAND
  IS_REPLICA
  IS_SKIPPED_FOR_REPLICATION
  TIME_RANGE_WITH_OFFSET
}
# A set of parameters to filter objects.
input Filter {
  field: HierarchyFilterField = IS_ARCHIVED
  texts: [String!] = []
  tagFilterParams: [TagFilterParams!] = []
  objectTypeFilterParams: [ManagedObjectType!] = []
  awsNativeProtectionFeatureNames: [AwsNativeProtectionFeature!] = []
  isNegative: Boolean = false
  isSlowSearchEnabled: Boolean = false
  azureNativeProtectionFeatureNames: [AzureNativeProtectionFeature!] = []
  unmanagedObjectAvailabilityFilter: [UnmanagedObjectAvailabilityFilter!] = []
}
# Input to process and finalize deletion of AWS cloud account.
input FinalizeAwsCloudAccountDeletionInput {
  # Rubrik ID of account to be deleted.
  cloudAccountId: UUID!

  # Protection feature to be deleted for the cloud account.
  feature: CloudAccountFeature!
}
# Process delete of aws cloud account.
type FinalizeAwsCloudAccountDeletionReply {
  # Contains success response message.
  message: String
}
# Input to finalize set up of an AWS cloud account.
input FinalizeAwsCloudAccountProtectionInput {
  # Action to be performed with cloud account.
  action: CloudAccountAction!

  # List of features for native protection of cloud account.
  features: [CloudAccountFeature!]!

  # Admin account, required for bulk upload.
  awsAdminAccount: AwsCloudAccountInput

  # List of AWS accounts.
  awsChildAccounts: [AwsCloudAccountInput!]!

  # List of AWS regions for the cloud account.
  awsRegions: [AwsCloudAccountRegion!]

  # Name of the CloudFormation stack to be created.
  stackName: String

  # Stackset name of the CloudFormation stack to be created.
  stackSetName: String

  # External ID of the IAM role trust policy for the cloud account.
  externalId: String!

  # List of feature types to be protected for the cloud account.
  featureVersion: [AwsCloudAccountFeatureVersionInput!]!
}
# Response for the operation to finalize protection for AWS cloud accounts.
type FinalizeAwsCloudAccountProtectionReply {
  # Contains success response message.
  message: String

  # Contains success response message.
  awsChildAccounts: [AwsCloudAccount!]!
}
# The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
scalar Float
# Regions for GCP.
enum GcpRegionEnum {
  # GCP region is Asia.
  ASIA

  # GCP region is Asia 1.
  ASIA1

  # GCP region is Asia East 1.
  ASIA_EAST1

  # GCP region is Asia East 2.
  ASIA_EAST2

  # GCP region is Asia North East 1.
  ASIA_NORTHEAST1

  # GCP region is Asia North East 2.
  ASIA_NORTHEAST2

  # GCP region is Asia North East 3.
  ASIA_NORTHEAST3

  # GCP region is Asia South 1.
  ASIA_SOUTH1

  # GCP region is Asia South East 1.
  ASIA_SOUTHEAST1

  # GCP region is Asia South East 2.
  ASIA_SOUTHEAST2

  # GCP region is Australia South East 1.
  AUSTRALIA_SOUTHEAST1

  # GCP region is Europe.
  EU

  # GCP region is Europe 4.
  EUR4

  # GCP region is Europe North 1.
  EUROPE_NORTH1

  # GCP region is Europe West 1.
  EUROPE_WEST1

  # GCP region is Europe West 2.
  EUROPE_WEST2

  # GCP region is Europe West 3.
  EUROPE_WEST3

  # GCP region is Europe West 4.
  EUROPE_WEST4

  # GCP region is Europe West 6.
  EUROPE_WEST6

  # GCP region is North America 4.
  NAM4

  # GCP region is North America North East 1.
  NORTHAMERICA_NORTHEAST1

  # GCP region is South America East 1.
  SOUTHAMERICA_EAST1

  # GCP region is Unknown.
  UNKNOWN_GCP_REGION

  # GCP region is US.
  US

  # GCP region is US Central 1.
  USCENTRAL1

  # GCP region is US East 1.
  USEAST1

  # GCP region is US East 4.
  USEAST4

  # GCP region is US West 1.
  USWEST1

  # GCP region is US West 2.
  USWEST2

  # GCP region is US West 3.
  US_WEST3

  # GCP region is US West 4.
  US_WEST4
}
# Storage class for GCP type location.
enum GcpStorageClassTypeEnum {
  # Coldline GCP storage class.
  COLDLINE_GCP

  # Durable reduced availability GCP storage class.
  DURABLE_REDUCED_AVAILABILITY_GCP

  # Nearline GCP storage class.
  NEARLINE_GCP

  # Standard GCP storage class.
  STANDARD_GCP

  # Unknown GCP storage class.
  UNKNOWN_STORAGE_CLASS_GCP
}
# A generic snapshot type.
interface GenericSnapshot {
  # The ID of the snapshot.
  id: UUID!

  # The date of the snapshot.
  date: DateTime!

  # Specifies whether or not the snapshot is corrupted.
  isCorrupted: Boolean!

  # Specifies whether or not the snapshot is indexed.
  isIndexed: Boolean!

  # Specifies whether or not the snapshot is unindexable.
  isUnindexable: Boolean!

  # The number of indexing attempts for the snapshot.
  indexingAttempts: Long!

  # The expirationDate of the snapshot.
  expirationDate: DateTime

  # Specifies whether or not the snapshot is expired.
  isExpired: Boolean!

  # Specifies whether the snapshot is an on-demand snapshot.
  isOnDemandSnapshot: Boolean!

  # The snappableId of the snapshot.
  snappableId: String!
}
# Paginated list of GenericSnapshot objects.
type GenericSnapshotConnection {
  # List of GenericSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [GenericSnapshotEdge!]!

  # List of GenericSnapshot objects.
  nodes: [GenericSnapshot!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of GenericSnapshot objects matching the request arguments.
  count: Int!
}
# Wrapper around the GenericSnapshot object. This wrapper is used for pagination.
type GenericSnapshotEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual GenericSnapshot object wrapped by this edge.
  node: GenericSnapshot!
}
type GeoLocation {
  address: String!
  latitude: Float!
  longitude: Float!
}
# Lambda configuration details of the Rubrik cluster.
type GetLambdaConfigReply {
  accountId: String!
  clusterId: String!
  enableAutomaticFmdUpload: Boolean!
  enableFmdUploadForAllResources: Boolean!
  defaultDiffFmdUploadPrefix: String!
  maxSnapshotsToUploadAutomatically: Int!
}
# Global manager connectivity status.
type GlobalManagerConnectivity {
  # URLs pinged to check connectivity.
  urls: [GlobalManagerUrl!]!
}
# URLs pinged to check connectivity.
type GlobalManagerUrl {
  # URL pinged to check connectivity.
  url: String!

  # Whether or not the URL check has passed.
  isReachable: Boolean!
}
# Metadata for rendering an SLA Domain.
type GlobalSlaReply implements SlaDomain {
  id: String!
  name: String!
  version: String
  description: String!
  protectedObjectCount: Int!
  uiColor: String!
  snapshotSchedule: SnapshotSchedule
  localRetentionLimit: Duration
  archivalSpec: ArchivalSpec
  archivalSpecs: [ArchivalSpec!]!
  replicationSpec: ReplicationSpec
  replicationSpecsV2: [ReplicationSpecV2!]!
  snapshotScheduleLastUpdatedAt: DateTime
  baseFrequency: Duration
  isArchived: Boolean!
  stateVersion: Long!
  firstFullBackupWindows: [BackupWindow!]!
  backupWindows: [BackupWindow!]!
  clusterToSyncStatusMap: [PolarisSlaSyncStatus!]!
  logConfig: LogConfigResult
  objectSpecificConfigs: ObjectSpecificConfigs
  objectTypes: [SLAObjectTypeEnum!]!
  clusterUuid: String!
  isDefault: Boolean!

  # SLA Domain upgrade information.
  upgradeInfo: SlaUpgradeInfo

  # Information about Rubrik clusters where this SLA Domain is paused.
  pausedClustersInfo: PausedClustersInfo

  # Specifies if this SLA Domain is retention-locked or not.
  isRetentionLockedSla: Boolean!
}
# The guest operating system.
enum GuestOsTypeEnum {
  # Linux operating system.
  Linux

  # Unknown guest operating system type.
  Unknown

  # Windows operating system.
  Windows
}
# Health-check status.
type HealthPolicyStatus {
  # Name of the policy used for the hardware component health check.
  policyName: String!

  # Result of the hardware health check.
  isHealthy: Boolean!

  # Output from the hardware health-check policy.
  message: String!
}
enum HierarchyFilterField {
  # Filter AWS EC2 instances based on RBS connection status.
  AWS_INSTANCE_CC_OR_CNP_RBS_CONNECTION_STATUS

  # Filter AWS native accounts based on the features enabled for them.
  AWS_NATIVE_ACCOUNT_ENABLED_FEATURE

  # Filter by AWS account ID.
  AWS_NATIVE_ACCOUNT_ID

  # ID of the AWS native EC2 instance (Rubrik ID), applicable for filtering
  # EBS volumes with their EC2 instance IDs. Applicable only if the object
  # type is AwsNativeEbsVolume.
  AWS_NATIVE_EC2_INSTANCE_ID

  # Filter by RDS Instace DB Engine.
  AWS_NATIVE_RDS_DB_ENGINE

  # Filter by RDS Instance DB Instance Class.
  AWS_NATIVE_RDS_DB_INSTANCE_CLASS

  # Filter by AWSAccount.aws_region_spec.region, EC2Instance.region, and
  # EBSVolume.region.
  AWS_REGION

  # Filter by aws_native_tags.
  AWS_TAG

  # Filter by VPC ID.
  AWS_VPC_ID

  # Filter Azure disks by ID of the attached virtual machine.
  AZURE_DISK_ATTACHED_VM

  # Filter Azure disks by common resource group name.
  AZURE_DISK_CRG_NAME

  # Filter Azure disks on subscription ID of common resource group.
  AZURE_DISK_CRG_SUBSCRIPTION_ID

  # Filter Azure disks on Disk size.
  AZURE_DISK_SIZE

  # Filter Azure disks by subscription ID.
  # todo (SPARK-88655): remove usage of VMRG and DiskRG
  AZURE_DISK_SUBSCRIPTION_ID

  # Filter Azure disks on Disk type.
  AZURE_DISK_TYPE

  # Filters Azure disks whose regions have a \"CONNECTED\" exocompute.
  AZURE_NATIVE_DISK_EXOCOMPUTE_CONNECTED

  # Filter by the \"indexing status\" of Azure disks.
  AZURE_NATIVE_DISK_INDEXING_STATUS

  # Filter Azure native subscriptions based on the features enabled for them.
  AZURE_NATIVE_SUBSCRIPTION_ENABLED_FEATURE

  # Filters Azure virtual machines whose regions have a \"CONNECTED\" exocompute.
  AZURE_NATIVE_VM_EXOCOMPUTE_CONNECTED

  # Filter by the \"indexing status\" of Azure VMs.
  AZURE_NATIVE_VM_INDEXING_STATUS

  # Filter by AzureSubscription.region_spec.region, AzureResourceGroup.region,
  # AzureVm.Region and AzureDisk.region.
  AZURE_REGION

  # Filter Azure resource groups by disk SLA or virtual machine SLA.
  AZURE_RG_DISK_OR_VM_SLA

  # Filter Azure Resource Groups by SLAs of given workload types.
  # SLAs need to be passed as "texts" and workload types need to be
  # passed as "object_type_filter_params".
  # Note: When using this filter for more than two types of workloads,
  # test the performance for large data sizes because internally the operation performs
  # some heavy joins to filter the results.
  AZURE_RG_SNAPPABLE_TYPES_SLA

  # Filter Azure resource groups on subscription ID.
  AZURE_RG_SUBSCRIPTION_ID

  # Filter Azure SQL Databases on resource group name.
  AZURE_SQL_DB_RG_NAME

  # Filter Azure SQL Database Servers on resource group name.
  AZURE_SQL_DB_SERVER_RG_NAME

  # Filter Azure SQL Database Servers on subscription ID.
  AZURE_SQL_DB_SERVER_SUBSCRIPTION_ID

  # Filter Azure SQL Databases on subscription ID.
  AZURE_SQL_DB_SUBSCRIPTION_ID

  # Filter Azure SQL Managed Instance Databases on resource group name.
  AZURE_SQL_MI_DB_RG_NAME

  # Filter Azure SQL Managed Instances Databases on subscription ID.
  AZURE_SQL_MI_DB_SUBSCRIPTION_ID

  # Filter Azure SQL Managed Instance Database Servers on resource group name.
  AZURE_SQL_MI_SERVER_RG_NAME

  # Filter Azure SQL Managed Instances Database Servers on subscription ID.
  AZURE_SQL_MI_SERVER_SUBSCRIPTION_ID

  # Filter by azure_native_tags.
  AZURE_TAG

  # Filter Azure Virtual Machines based on RBS connection status.
  AZURE_VM_CC_OR_CNP_RBS_CONNECTION_STATUS

  # Filter Azure virtual machines on common resource group name.
  AZURE_VM_CRG_NAME

  # Filter Azure virtual machines on subscription ID of common resource group.
  AZURE_VM_CRG_SUBSCRIPTION_ID

  # Filter Azure virtual machines on virtual machine size.
  AZURE_VM_SIZE

  # Filter Azure virtual machines on subscription ID.
  # todo (SPARK-88655): remove usage of VMRG and DiskRG
  AZURE_VM_SUBSCRIPTION_ID

  # Filter Azure virtual machines on VNet name.
  AZURE_VNET_NAME

  # Filter by ID of parent Cassandra Keyspace.
  CASSANDRA_KEYSPACE_ID

  # Filter by ID of parent Cassandra Source.
  CASSANDRA_SOURCE_ID

  # Filter by status of CassandraSource.
  CASSANDRA_SOURCE_STATUS

  # Filter cloud instances based on whether CDM App Protection
  # is setup through a cloud cluster.
  CLOUD_INSTANCE_CDM_APP_PROTECTION_SETUP

  # Filter cloud instance physical host by descendant object type.
  CLOUD_INSTANCE_HOST_DESCENDANT_OBJECT_TYPE

  # Filter cloud native databases using server name.
  CLOUD_NATIVE_SERVER_NAME_FILTER

  # Filter Rubrik CDM objects by cluster ID.
  CLUSTER_ID

  # Filter clusters by the ClusterTypeEnum.
  CLUSTER_TYPE

  # Filter based on fid of DB2 instance.
  DB2_INSTANCE_ID

  # Filter by status of Db2Instance.
  DB2_INSTANCE_STATUS

  # Filter by relic filesets of a NAS Share.
  DOES_NAS_SHARE_HAVE_RELIC_FILESETS

  # Filter NAS volumes based on whether they are associated
  # with a SnapMirror Cloud object.
  DOES_NAS_VOLUME_HAVE_SMC

  # Filter physical hosts that have protected volume group.
  DOES_PHYSICAL_HOST_HAVE_PROTECTED_VOLUME_GROUP

  # Filter by relic filesets of a physical host.
  DOES_PHYSICAL_HOST_HAVE_RELIC_FILESETS

  # Filter by relic volume group of a physical host.
  DOES_PHYSICAL_HOST_HAVE_RELIC_VOLUME_GROUP

  # Filter whether the sharepoint is relic or contains relic object.
  DOES_SHAREPOINT_HAVE_RELIC_OBJECTS

  # Filter by EBSVolume native ID.
  EBS_VOLUME_ID

  # Filter EBS Volumes by status of indexing.
  EBS_VOLUME_INDEXING_STATUS

  # Filter by EBSVolume.name.
  EBS_VOLUME_NAME

  # Filter by EBS volume name or volume ID.
  EBS_VOLUME_NAME_OR_VOLUME_ID

  # Filter by EbsVolume.type.
  EBS_VOLUME_TYPE

  # Filter by EC2Instance native ID.
  EC2_INSTANCE_ID

  # Filter EC2 Instances by status of indexing. Possible values for
  # filter are generated strings from AwsIndexingStatusFilter enum.
  EC2_INSTANCE_INDEXING_STATUS

  # Filter by EC2Instance.name.
  EC2_INSTANCE_NAME

  # Filter by EC2 instance name or instance ID.
  EC2_INSTANCE_NAME_OR_INSTANCE_ID

  # Filter by Ec2Instance.type.
  EC2_INSTANCE_TYPE

  # Filter managed objects by the SLA Domain ID. Objects returned are
  # either retained or protected by the SLA Domain.
  EFFECTIVE_RETENTION_SLA
  EFFECTIVE_SLA

  # Filter to include or exclude objects with a specific effective SLA
  # source object.
  EFFECTIVE_SLA_SOURCE_OBJECT

  # Filter by the SLA type of the effective SLA.
  EFFECTIVE_SLA_TYPE

  # Filter Exchange Databases by the ID of the Exchange Dag.
  EXCHANGE_DATABASE_BY_DAG_ID

  # Filter Exchange Databases by the ID of the Exchange Host.
  EXCHANGE_DATABASE_BY_HOST_ID

  # Filter Exchange Databases by the ID of the Exchange Server.
  EXCHANGE_DATABASE_BY_SERVER_ID

  # Filter Exchange Server by the ID of the Exchange Dag.
  EXCHANGE_SERVER_BY_DAG_ID

  # Filter SharePoint Libraries by excluding list template types.
  EXCLUDED_SHAREPOINT_LIBRARY_TYPE

  # Filter by the ID of Failover cluster app.
  FAILOVER_CLUSTER_APP_ID

  # Filter by ID of parent of Failover Cluster.
  FAILOVER_CLUSTER_ID

  # Filter physical hosts by SLAs attached to their filesets.
  FILESET_SLA

  # Filter physical hosts by which fileset templates are attached
  # to them.
  FILESET_TEMPLATE_ID

  # Filter fileset templates by OS Type.
  FILESET_TEMPLATE_OS_TYPE

  # Filter by gcp_native_labels.
  GCP_LABEL

  # Filter by GCP Disk location (for regional disk: location=region, for zonal disk: location=zone).
  GCP_NATIVE_DISK_LOCATION

  # Filter by GCP Disk name or native ID.
  GCP_NATIVE_DISK_NAME_OR_NATIVE_ID

  # Filter by GCP Disk project name.
  GCP_NATIVE_DISK_PROJECT

  # Filter by GCP Disk type.
  # Text of the GCP_DISK_TYPE can have one of the following values:
  # regional-pd-ssd regional-pd-standard regional-pd-balanced
  # zonal-pd-ssd zonal-pd-standard zonal-pd-balanced.
  GCP_NATIVE_DISK_TYPE

  # Filter by GCP instance native ID or name.
  GCP_NATIVE_INSTANCE_NAME_OR_NATIVE_ID

  # Filter by GCP Instance Network Name.
  GCP_NATIVE_INSTANCE_NETWORK_NAME

  # Filter by GCP instance type.
  GCP_NATIVE_INSTANCE_TYPE

  # Filter by GCP project ID for GCE instances.
  GCP_NATIVE_PROJECT_ID

  # Filter by GCP project name or project number.
  GCP_NATIVE_PROJECT_NAME_OR_PROJECT_NUMBER

  # Filter GCP projects by their native ID.
  GCP_NATIVE_PROJECT_NATIVE_ID

  # Filter by GCP region.
  GCP_NATIVE_REGION

  # Filter VSphere virtual machines by guest OS type for file export.
  GUEST_OS_TYPE_FOR_FILE_RESTORE

  # Filter if a workload has parent workload.
  HAS_PARENT_SNAPPABLE

  # Filter hosts based on CBT status.
  HOST_CBT_STATUS

  # Filter the hosts by their Operating System.
  HOST_OPERATING_SYSTEM

  # Return only the workloads that are active.
  # An active workload is a workload that is without a workload group or
  # workload with the highest primary sequence number in the workload group.
  IS_ACTIVE

  # Filters active object from a group of duplicated objects.
  IS_ACTIVE_AMONG_DUPLICATED_OBJECTS
  IS_ARCHIVED

  # Filter archived and non-relic managed-objects.
  IS_GHOST

  # Filter by status of a fileset protection on cdm host.
  IS_HOST_PROTECTED

  # Filter Live Mounts from Managed Volume Exports.
  IS_MAIN_MOUNT

  # Filter child objects by Managed Volume archival status.
  IS_MANAGED_VOLUME_ARCHIVED

  # Filter by the protection status of a NAS share.
  IS_NAS_SHARE_PROTECTED

  # Workload must not be a member of any active Blueprint.
  IS_NOT_BLUEPRINT_CHILD

  # Filter by whether object is protected by an SLA Domain.
  IS_PROTECTED
  IS_RELIC
  IS_REPLICATED

  # Filter unmanaged objects.
  IS_UNMANAGED_OBJECT

  # Filter Kubernetes clusters based on associated Rubrik cluster.
  # Since KuprCluster is natively polaris Managed Object, a separate filter is used.
  KUPR_CDM_CLUSTER_ID

  # Filter Kubernetes clusters based on connection status.
  KUPR_CLUSTER_STATUS

  # Filter Kubernetes namespaces based on the associated Rubrik cluster of the parent.
  # Since KuprNamespace is natively polaris Managed Object, a separate filter is used.
  KUPR_NAMESPACE_CDM_CLUSTER_ID

  # Filter Kubernetes namespace based on the connection status of the parent.
  KUPR_NAMESPACE_CLUSTER_STATUS

  # Filter by location or path of an object.
  LOCATION

  # Filter by Managed Volume Export ID.
  MANAGED_VOLUME_EXPORT_ID

  # Filter Managed Volume Exports for a given Managed Volume ID.
  MANAGED_VOLUME_ID

  # Filter Managed Volume Type.
  MANAGED_VOLUME_TYPE

  # Filter by ID of parent MongoDB Keyspace.
  MONGODB_DATABASE_ID

  # Filter by ID of parent MongoDB Source.
  MONGODB_SOURCE_ID

  # Filter by status of MongoDB Source.
  MONGODB_SOURCE_STATUS
  NAME

  # There is already a filter called NAME which filters for all the rows
  # where name is "LIKE" the provided string. We have a use-case in
  # Azure where we would like to Filter by name but exact-match, not just
  # similar match. The use case is that resource groups are identified by
  # the tuple of subscription ID and resource group name, similarity
  # measure will not distinguish between two similar names.
  NAME_EXACT_MATCH

  # Filter by name or email-address of O365 user.
  NAME_OR_EMAIL_ADDRESS

  # Filter by the ID of the NAS namespace.
  NAS_NAMESPACE_ID

  # Filter by hidden shares.
  NAS_SHARE_HIDDEN

  # Filter by the Namespace ID of the NAS Share.
  NAS_SHARE_NAMESPACE_ID

  # Filter by the effective SLA Domain ID of the NAS Share.
  NAS_SHARE_SLA

  # Filter by stale shares.
  NAS_SHARE_STALE

  # Filter by the type of the NAS Share.
  NAS_SHARE_TYPE

  # Filter by the vendor type of the NAS System.
  NAS_VENDOR_TYPE

  # Filter by the SLA Domain of the SnapMirror Cloud objects under
  # the NAS volume.
  NAS_VOLUME_EFFECTIVE_SLA

  # Filter Nutanix virtual machines by the agent's connection status.
  NUTANIX_VM_BY_AGENT_STATUS

  # Filter Nutanix virtual machines by the Nutanix cluster CDMID.
  NUTANIX_VM_BY_NUTANIX_CLUSTER_CDMID

  # O365 specific type: O365_SHARED_USER, O365_SHARED_MAILBOX...This filter is
  # introduced to support api-server since it is not convenient to add object-specific
  # subtype knowledge there. To query for shared users, we can either:
  # 1. Specify O365_USER in object type AND this filter with value O365_SHARED_USER
  # (api-server way)
  # 2. Specify O365_SHARED_USER in object type, ignore this filter
  # (others should do this).
  O365_SPECIFIC_TYPE

  # Filter by software version of the cluster.
  ON_OR_ABOVE_CLUSTER_VERSION

  # Filter by organization ID.
  ORGANIZATION_ID

  # Filter physical hosts by OS name.
  OS_NAME

  # Filter physical hosts by OS type.
  OS_TYPE

  # Filter physical host by cloud instance id.
  PHYSICAL_HOST_BY_CLOUD_INSTANCE_ID

  # Filter by SLA domain of the Microsoft SQL (MSSQL) hosts.
  PHYSICAL_HOST_BY_MSSQL_EFFECTIVE_SLA

  # Filter by the SLA Domain of the volume group of the physical host.
  PHYSICAL_HOST_BY_VOLUME_GROUP_EFFECTIVE_SLA

  # Filter by the RBS status of the physical host.
  PHYSICAL_HOST_CONNECTION_STATUS

  # Filter by the SLA Domain of the host filesets.
  PHYSICAL_HOST_EFFECTIVE_SLA

  # tag_filter_params field.
  # Filter by the ID of a Physical Host.
  PHYSICAL_HOST_ID

  # Filter by whether Polaris native snappable object
  # has an unindexed snapshot or it has a snapshot that is expired
  # and has an unmerged index.
  POLARIS_NATIVE_HAS_UNINDEXED_OR_EXPIRED_SNAPSHOT

  # Filter by the name by a given regex expression
  REGEX

  # Filter by the ID of parent SAP HANA system.
  SAP_HANA_SYSTEM_ID

  # Filter by SID of SapHanaSystem.
  SAP_HANA_SYSTEM_SID

  # Filter by status of SapHanaSystem.
  SAP_HANA_SYSTEM_STATUS

  # Filter based on type of database in UDF schema.
  UDF_DATABASE_TYPE

  # Filter isLocal of virtualhost.descendant.
  VSPHERE_DATASTORE_IS_LOCAL

  # Filter for the the root level of compute resources for the restore
  # hierarchy, which includes compute clusters and standalone hosts.
  VSPHERE_GET_ROOT_RESTORE_HIERARCHY
}
# A generic hierarchy object.
interface HierarchyObject {
  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Type of hierarchy object.
enum HierarchyObjectTypeEnum {
  # AppFlows Recovery Plan.
  APPFLOWS_RECOVERY_PLAN
  AZURE_SQL_DATABASE_DB
  AZURE_SQL_MANAGED_INSTANCE_DB
  AllSubHierarchyType
  AppBlueprint
  AppflowsBlueprint
  AwsNativeAccount
  AwsNativeEbsVolume
  AwsNativeEc2Instance
  AwsNativeRdsInstance
  AzureNativeManagedDisk
  AzureNativeResourceGroup
  AzureNativeSubscription
  AzureNativeVm
  AzureSqlDatabaseServer
  AzureSqlManagedInstanceServer
  Blueprint
  CASSANDRA_COLUMN_FAMILY
  CASSANDRA_KEYSPACE
  CASSANDRA_SOURCE
  CloudNativeTagRule
  Db2Database
  Db2Instance

  # Exchange DAG.
  EXCHANGE_DAG

  # Exchange Server.
  EXCHANGE_SERVER
  Ec2Instance

  # Exchange Database.
  ExchangeDatabase

  # Failover Cluster App.
  FAILOVER_CLUSTER_APP
  FeldsparSite
  Fileset
  FilesetTemplate
  GcpNativeDisk
  GcpNativeGCEInstance
  GcpNativeProject

  # Host Failover Cluster.
  HOST_FAILOVER_CLUSTER
  Hdfs
  HostShare
  HypervCluster
  HypervSCVMM
  HypervServer
  HypervVirtualMachine
  KuprCluster
  KuprNamespace
  LinuxFileset

  # Managed Volume Export.
  MANAGED_VOLUME_EXPORT

  # MongoDB Collection.
  MONGODB_COLLECTION

  # MongoDB Database.
  MONGODB_DATABASE

  # MongoDB Source Cluster.
  MONGODB_SOURCE
  MONGO_COLLECTION
  MONGO_DB
  MONGO_SOURCE

  # Managed Volume.
  ManagedVolume
  Mssql
  MssqlAvailabilityGroup
  MssqlDatabaseBatchMaintenance
  MssqlInstance

  # NAS Fileset.
  NAS_FILESET
  NasNamespace
  NasShare
  NasSystem
  NasVolume
  NutanixCluster
  NutanixVirtualMachine
  O365Calendar
  O365File
  O365Group
  O365Mailbox
  O365Onedrive
  O365Org
  O365SharePointDrive
  O365SharePointList
  O365Site
  O365Teams
  O365User
  ORACLE_DATA_GUARD_GROUP
  OracleDatabase
  OracleHost
  OracleRac
  PhysicalHost
  PolarisEbsVolume
  PolarisEc2Instance
  SapHanaDatabase
  SapHanaSystem
  ShareFileset
  SnapMirrorCloud
  StorageArrayVolumeGroup

  # VSphere Datastore cluster.
  VSPHERE_DATASTORE_CLUSTER

  # VSphere Virtual Disk.
  VSPHERE_VIRTUAL_DISK
  VSphereComputeCluster
  VSphereDatacenter
  VSphereDatastore
  VSphereFolder
  VSphereHost
  VSphereNetwork
  VSphereResourcePool
  VSphereTag
  VSphereTagCategory
  VSphereVCenter
  Vcd
  VcdCatalog
  VcdOrg
  VcdOrgVdc
  VcdVapp
  VcdVimServer
  VmwareVirtualMachine
  VolumeGroup
  WindowsCluster
  WindowsFileset
  WindowsVolumeGroup
}
enum HierarchySortByField {
  ASSIGNED_SLA_DOMAIN
  AWS_NATIVE_ACCOUNT_NAME
  AWS_NATIVE_RDS_DB_ENGINE
  AWS_NATIVE_RDS_DB_INSTANCE_CLASS
  AWS_REGION
  AWS_VPC_ID
  AZURE_DISK_ATTACHED_VM
  AZURE_DISK_CRG_NAME
  AZURE_DISK_CRG_SUBSCRIPTION_NAME
  AZURE_DISK_SIZE
  AZURE_DISK_TYPE
  AZURE_REGION
  AZURE_RG_DISKCOUNT
  AZURE_RG_DISK_EFFECTIVE_SLA
  AZURE_RG_SQL_DATABASE_DB_EFFECTIVE_SLA
  AZURE_RG_SQL_MANAGED_INSTANCE_DB_EFFECTIVE_SLA
  AZURE_RG_SUBSCRIPTION_NAME
  AZURE_RG_VMCOUNT
  AZURE_RG_VM_EFFECTIVE_SLA
  AZURE_SQL_DATABASE_DB_REGION
  AZURE_SQL_DATABASE_SERVER_REGION
  AZURE_SQL_DB_RESOURCE_GROUP
  AZURE_SQL_MANAGED_INSTANCE_DB_REGION
  AZURE_SQL_MANAGED_INSTANCE_SERVER_REGION
  AZURE_SQL_SERVER_RESOURCE_GROUP
  AZURE_SUBNET_NAME
  AZURE_SUBSCRIPTION_DISKCOUNT
  AZURE_SUBSCRIPTION_VMCOUNT
  AZURE_TENANT_ID
  AZURE_VM_CRG_NAME
  AZURE_VM_CRG_SUBSCRIPTION_NAME
  AZURE_VM_SIZE
  AZURE_VNET_NAME

  # Sort DB2 Instance based on instance ID
  DB2_INSTANCE_ID
  EBS_VOLUME_COUNT
  EBS_VOLUME_ID
  EBS_VOLUME_NAME
  EBS_VOLUME_SIZE
  EBS_VOLUME_TYPE
  EC2_INSTANCE_COUNT
  EC2_INSTANCE_ID
  EC2_INSTANCE_NAME
  EC2_INSTANCE_TYPE
  EFFECTIVE_SLA_DOMAIN
  EMAIL_ADDRESS
  FILESET_TEMPLATE_DOES_NOT_EXCLUDE
  FILESET_TEMPLATE_EXCLUDES
  FILESET_TEMPLATE_INCLUDES
  GCP_DISK_LOCATION
  GCP_DISK_NATIVE_ID
  GCP_DISK_NATIVE_NAME
  GCP_DISK_PROJECT_NAME
  GCP_DISK_SIZE
  GCP_INSTANCE_NATIVE_ID
  GCP_INSTANCE_NATIVE_NAME
  GCP_INSTANCE_NETWORK_NAME
  GCP_INSTANCE_PROJECT_NAME
  GCP_INSTANCE_REGION
  GCP_INSTANCE_TYPE
  GCP_PROJECT_DISK_COUNT
  GCP_PROJECT_INSTANCE_COUNT
  GCP_PROJECT_NATIVE_ID
  GCP_PROJECT_NUMBER
  GCP_PROJECT_ORG_NAME
  ID
  MSSQL_AVAILABILITY_GROUP_COPY_ONLY
  MSSQL_DATABASE_COPY_ONLY

  # Sort MSSQL failover clusters by database count.
  MSSQL_FAILOVER_DATABASE_COUNT

  # Sort MSSQL hosts by number of databases.
  MSSQL_HOST_DB_COUNT
  MSSQL_HOST_INSTANCE_COUNT

  # Sort MSSQL instances by number of databases.
  MSSQL_INSTANCE_DB_COUNT
  NAME
  PHYSICAL_HOST_CONNECTION_STATUS
  PHYSICAL_HOST_OS_NAME
  SAP_HANA_SYSTEM_SID
  SAP_HANA_SYSTEM_STATUS

  # Sort unmanaged objects by archival storage size.
  UNMANAGED_OBJECTS_ARCHIVAL_STORAGE_BYTES

  # Sort unmanaged objects by local storage size.
  UNMANAGED_OBJECTS_LOCAL_STORAGE_BYTES

  # Sort based on unmanaged object location.
  UNMANAGED_OBJECTS_LOCATION

  # Sort based on unmanaged object status.
  UNMANAGED_OBJECTS_STATUS

  # Sort unmanaged objects by number of snapshot count.
  UNMANAGED_OBJECTS_UNEXPIRED_SNAPSHOT_COUNT
  VSPHERE_DATASTORE_CAPACITY
  VSPHERE_DATASTORE_FREE_SPACE
  VSPHERE_DATASTORE_TYPE
}
enum HierarchySortOrder {
  ASC
  DESC
}
# The connection status of a host.
type HostConnectionStatus {
  connectivity: HostConnectivityStatusEnum!
  timestampMillis: DateTime
}
enum HostConnectivityStatusEnum {
  BADLY_CONFIGURED
  CONNECTED
  CONNECTING
  CONNECTOR_NOT_DEPLOYED
  DELETED
  DELETING
  DELETION_FAILED
  DISCONNECTED
  PARTIALLY_CONNECTED
  REFRESHING
  REFRESH_FAILED
  REMOTE
  REPLICATED_TARGET
  SECONDARY_CLUSTER
  UNKNOWN_CONNECTIVITY_STATUS
}
type HourlySnapshotSchedule {
  basicSchedule: BasicSnapshotSchedule
}
# The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.
scalar ID
# Instance type of the location.
enum InstanceTypeEnum {
  # Azure China instance type.
  AZURE_CHINA

  # Azure Default instance type.
  AZURE_DEFAULT

  # Azure Germany instance type.
  AZURE_GERMANY

  # Azure Government instance type.
  AZURE_GOVERNMENT

  # Instance type of location is unknown.
  UNKNOWN_INSTANCE
}
# The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
scalar Int
# Interface CIDR Info.
type InterfaceCidr {
  interfaceType: InterfaceTypeEnum!
  cidr: String!
  selected: Boolean!
}
enum InterfaceTypeEnum {
  BOND0
  BOND1
  CUSTOM
  UNKNOWN_TYPE
}
# Specifies whether the volume snapshot is restorable.
type IsVolumeSnapshotRestorableReply {
  # Specifies whether the EBS volume snapshot is restorable. The snapshot would be restorable only if the EBS volume exists in the AWS account, and is attached to exactly one EC2 instance.
  isRestorable: Boolean!
}
type JobMetadata {
  id: Long!
  createdAt: DateTime
  updatedAt: DateTime
  currentInstance: Int!
  state: String!
  progress: String!
  progressedAt: DateTime
  retryAttempts: Int!
  startTime: DateTime
  owner: String!
  info: String!
  lastOwner: String!
  lastSuccess: DateTime
  lastFailure: DateTime
  startedAt: DateTime
  jobType: String!
  numSuccessfulRuns: Int!
  numScheduledRuns: Int!
  lastSkipped: DateTime
  logLevel: LogLevelEnum!
}
type JobReply {
  metadata: JobMetadata
  customerAccount: String!
  clusterUuid: String!
  clusterName: String!
  version: String!
}
type JobsReply {
  jobs: [JobReply!]!
}
# A Key management system (KMS) key in AWS realm.
type KmsEncryptionKey {
  # ID of KMS key.
  id: String!

  # Amazon Resource Name (ARN) of the KMS key.
  arn: String!

  # Aliases of KMS key.
  aliases: [String!]!
}
# History of Ransomware Investigation and Sensitive Data Discovery features.
type LambdaFeatureHistory {
  # True if Ransomware Investigation was ever enabled.
  wasRansomwareInvestigationEverEnabled: Boolean!

  # True if Sensitive Data Discovery was ever enabled.
  wasSensitiveDataDiscoveryEverEnabled: Boolean!
}
# Latest user note information.
type LatestUserNote {
  # User note attachment time.
  time: DateTime!

  # Name of the user who attached the note.
  userName: String

  # Object ID where note is attached.
  objectId: String!

  # User note text.
  userNote: String
}
# Scope of the target location based on how it is managed.
enum LocationScope {
  # Target location is managed by Polaris.
  GLOBAL

  # Target location is managed by CDM.
  LOCAL

  # Scope of target location is unknown.
  UNKNOWN
}
# Type of data location.
enum LocationTypeEnum {
  Azure
  CLOUD_NATIVE_AWS
  CLOUD_NATIVE_GCP
  Cleversafe
  Glacier
  Google
  HDS
  LOCAL
  Nfs
  Qstar
  REPLICATION_OFF
  REPLICATION_POLARIS_SOURCE
  REPLICATION_SOURCE
  REPLICATION_SOURCE_AND_TARGET
  REPLICATION_TARGET
  Rehydrated
  S3
  S3Compatible
  Scality
}
# Locking mechanisms for a user account.
enum LockMethod {
  # Account locked by the administrator.
  ADMINISTRATIVE_LOCK

  # Account locked due to too many failed login attempts (Brute-force attack).
  BRUTE_FORCE

  # Unspecified.
  LOCK_METHOD_UNSPECIFIED
}
# User account lockout details.
type LockoutState {
  # Specifies whether the account is locked.
  isLocked: Boolean!

  # Mechanism for locking the user account.
  lockMethod: LockMethod!

  # Method for unlocking the locked account. Possible values are: self-service, administrative-unlocking, support-unlocking.
  unlockMethod: UnlockMethod!

  # The time at which the account was previously locked.
  lockedAt: DateTime

  # The time at which the account was previously unlocked.
  unlockedAt: DateTime
}
type LogConfigResult {
  slaLogFrequencyConfig: SlaLogFrequencyConfigResult
}
enum LogLevelEnum {
  DEBUG
  INFO
}
# The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1.
scalar Long
# Specifies which Managed Disks are excluded from snapshots.
input ManagedDiskExclusion {
  # Rubrik ID of the Managed Disk.
  managedDiskRubrikId: UUID!

  # Specifies whether the Managed Disk is excluded from snapshots or not. When true, the Managed Disk will be excluded from the snapshot.
  isExcludedFromSnapshot: Boolean!
}
# All supported managed objects.
enum ManagedObjectType {
  # Orchestrated Application Recovery Blueprint.
  APP_BLUEPRINT

  # AWS account.
  AWS_NATIVE_ACCOUNT

  # AWS Elastic Block Store volume.
  AWS_NATIVE_EBS_VOLUME

  # AWS Elastic Compute Cloud instance.
  AWS_NATIVE_EC2_INSTANCE

  # AWS Relational Database Service instance.
  AWS_NATIVE_RDS_INSTANCE

  # Azure managed disk.
  AZURE_MANAGED_DISK

  # Azure common resource group.
  AZURE_RESOURCE_GROUP

  # Azure resource group for disk hierarchy.
  AZURE_RESOURCE_GROUP_FOR_DISK_HIERARCHY

  # Azure resource group for virtual machine hierarchy.
  AZURE_RESOURCE_GROUP_FOR_VM_HIERARCHY

  # Azure SQL Database.
  AZURE_SQL_DATABASE_DB

  # Azure SQL Database server.
  AZURE_SQL_DATABASE_SERVER

  # Azure SQL Managed Instance database.
  AZURE_SQL_MANAGED_INSTANCE_DB

  # Azure SQL Managed Instance server.
  AZURE_SQL_MANAGED_INSTANCE_SERVER

  # Azure subscription.
  AZURE_SUBSCRIPTION

  # Azure unmanaged disk.
  AZURE_UNMANAGED_DISK

  # Azure virtual machine.
  AZURE_VIRTUAL_MACHINE

  # Blueprint.
  BLUEPRINT

  # Cassandra column family.
  CASSANDRA_COLUMN_FAMILY

  # Cassandra keyspace.
  CASSANDRA_KEYSPACE

  # Cassandra source.
  CASSANDRA_SOURCE

  # Cloud tag rule.
  CLOUD_NATIVE_TAG_RULE

  # DB2 database.
  DB2_DATABASE

  # DB2 instance.
  DB2_INSTANCE

  # Exchange Database Availability Group.
  EXCHANGE_DAG

  # Exchange Database.
  EXCHANGE_DATABASE

  # Exchange Server.
  EXCHANGE_SERVER

  # Failover cluster app.
  FAILOVER_CLUSTER_APP

  # Feldspar site.
  FELDSPAR_SITE

  # Fileset template.
  FILESET_TEMPLATE

  # GCP disk.
  GCP_NATIVE_DISK

  # GCP Google Compute Engine instance.
  GCP_NATIVE_GCE_INSTANCE

  # GCP project.
  GCP_NATIVE_PROJECT

  # Rubrik SaaS user group.
  GROUP

  # Host failover cluster.
  HOST_FAILOVER_CLUSTER

  # Host share.
  HOST_SHARE

  # Hyper-V cluster.
  HYPERV_CLUSTER

  # Hyper-V System Center Virtual Machine Manager.
  HYPERV_SCVMM

  # Hyper-V server.
  HYPERV_SERVER

  # Hyper-V virtual machine.
  HYPERV_VIRTUAL_MACHINE

  # Kubernetes cluster.
  KUPR_CLUSTER

  # Kubernetes namespace.
  KUPR_NAMESPACE

  # Linux fileset.
  LINUX_FILESET

  # Managed Volume.
  MANAGED_VOLUME

  # Managed Volume Export.
  MANAGED_VOLUME_EXPORT

  # MongoDB collection.
  MONGODB_COLLECTION

  # MongoDB database.
  MONGODB_DATABASE

  # MongoDB source.
  MONGODB_SOURCE

  # Mongo collection.
  MONGO_COLLECTION

  # Mongo database.
  MONGO_DB

  # Mongo source.
  MONGO_SOURCE

  # MSSQL availability group.
  MSSQL_AVAILABILITY_GROUP

  # MSSQL database availability group.
  MSSQL_DAG

  # MSSQL database.
  MSSQL_DATABASE

  # MSSQL instance.
  MSSQL_INSTANCE

  # NAS fileset associated with a NAS share object.
  NAS_FILESET

  # NAS namespace.
  NAS_NAMESPACE

  # NAS share.
  NAS_SHARE

  # NAS system.
  NAS_SYSTEM

  # NAS volume.
  NAS_VOLUME

  # Nutanix cluster.
  NUTANIX_CLUSTER

  # Nutanix virtual machine.
  NUTANIX_VIRTUAL_MACHINE

  # O365 calendar.
  O365_CALENDAR

  # O365 group.
  O365_GROUP

  # O365 individual mailbox.
  O365_INDIVIDUAL_MAILBOX

  # O365 individual user.
  O365_INDIVIDUAL_USER

  # O365 mailbox.
  O365_MAILBOX

  # O365 OneDrive.
  O365_ONEDRIVE

  # O365 organization.
  O365_ORGANIZATION

  # O365 shared mailbox.
  O365_SHARED_MAILBOX

  # O365 shared user.
  O365_SHARED_USER

  # O365 SharePoint drive.
  O365_SHAREPOINT_DRIVE

  # O365 SharePoint list.
  O365_SHAREPOINT_LIST

  # O365 site.
  O365_SITE

  # O365 Teams.
  O365_TEAMS

  # O365 user.
  O365_USER

  # Oracle database.
  ORACLE_DATABASE

  # Oracle Data Guard Group.
  ORACLE_DATA_GUARD_GROUP

  # Oracle host.
  ORACLE_HOST

  # Oracle Real Application Cluster.
  ORACLE_RAC

  # Physical host.
  PHYSICAL_HOST

  # Recovery plan.
  RECOVERY_PLAN

  # SAP HANA database.
  SAP_HANA_DATABASE

  # SAP HANA system.
  SAP_HANA_SYSTEM

  # Share fileset.
  SHARE_FILESET

  # SnapMirror Cloud.
  SNAPMIRROR_CLOUD

  # Rubrik SaaS user.
  USER

  # VMware vCloud Director.
  VCD

  # VMware vCloud Director catalog.
  VCD_CATALOG

  # VMware vCloud Director organization.
  VCD_ORG

  # VMware vCloud Director organization virtual datacenter.
  VCD_ORG_VDC

  # VMware vCloud Director vApp.
  VCD_VAPP

  # VMware vCloud Director Virtualized Infrastructure Manager Server.
  VCD_VIM_SERVER

  # Volume Group.
  VOLUME_GROUP

  # VMware vSphere compute cluster.
  VSPHERE_COMPUTE_CLUSTER

  # VMware vSphere datacenter.
  VSPHERE_DATACENTER

  # VMware vSphere datastore.
  VSPHERE_DATASTORE

  # VMware vSphere database cluster.
  VSPHERE_DATASTORE_CLUSTER

  # VMware vSphere folder.
  VSPHERE_FOLDER

  # VMware vSphere host.
  VSPHERE_HOST

  # VMware vSphere network.
  VSPHERE_NETWORK

  # VMware vSphere resource pool.
  VSPHERE_RESOURCE_POOL

  # VMware vSphere tag.
  VSPHERE_TAG

  # VMware vSphere tag category.
  VSPHERE_TAG_CATEGORY

  # VMware vSphere vCenter.
  VSPHERE_VCENTER

  # VMware vSphere virtual disk.
  VSPHERE_VIRTUAL_DISK

  # VMware vSphere virtual machine.
  VSPHERE_VIRTUAL_MACHINE

  # Windows cluster.
  WINDOWS_CLUSTER

  # Windows fileset.
  WINDOWS_FILESET
}
interface ManagedVolumeDescendantType {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
interface ManagedVolumeMountDescendantType {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
interface ManagedVolumeMountPhysicalChildType {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
type MinuteSnapshotSchedule {
  basicSchedule: BasicSnapshotSchedule
}
enum Month {
  APRIL
  AUGUST
  DECEMBER
  FEBRUARY
  JANUARY
  JULY
  JUNE
  MARCH
  MAY
  NOVEMBER
  OCTOBER
  SEPTEMBER
}
type MonthlySnapshotSchedule {
  basicSchedule: BasicSnapshotSchedule
  dayOfMonth: DayOfMonth!
}
# The SLA Domain configuration for SQL Server database.
type MssqlConfig {
  # Frequency value for log backups of SQL Server databases.
  frequency: Duration

  # Specifies the duration for which the logs will be retained.
  logRetention: Duration
}
interface MssqlTopLevelDescendantType {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Filter to return objects with a given substring in their name.
input NameSubstringFilter {
  nameSubstring: String!
}
type ObjectIdsForHierarchyType {
  objectIds: [String!]!
  snappableType: SnappableLevelHierarchyTypeEnum!
}
type ObjectSpecificConfigs {
  sapHanaConfig: SapHanaConfig
  awsRdsConfig: AwsRdsConfig
  vmwareVmConfig: VmwareVmConfig

  # SLA Domain configuration for Azure SQL Database DB object.
  azureSqlDatabaseDbConfig: AzureSqlDatabaseDbConfig

  # SLA Domain configuration for Azure SQL Managed Instance DB object.
  azureSqlManagedInstanceDbConfig: AzureSqlManagedInstanceDbConfig

  # SLA Domain configuration for Db2 database object.
  db2Config: Db2Config

  # SLA Domain configuration for SQL Server database object.
  mssqlConfig: MssqlConfig

  # SLA Domain configuration for Oracle database object.
  oracleConfig: OracleConfig
}
enum ObjectTypeEnum {
  AZURE_SQL_DATABASE_DB
  AZURE_SQL_MANAGED_INSTANCE_DB
  AppBlueprint
  AwsNativeEbsVolume
  AwsNativeEc2Instance
  AwsNativeRdsInstance
  AzureNativeManagedDisk
  AzureNativeVm
  CASSANDRA_COLUMN_FAMILY
  CASSANDRA_KEYSPACE
  CASSANDRA_SOURCE
  Db2Database
  Ec2Instance

  # Exchange Database.
  ExchangeDatabase
  Fileset
  GcpNativeDisk
  GcpNativeGCEInstance
  Hdfs
  HypervVirtualMachine
  KuprNamespace
  LinuxFileset

  # MongoDB Collection.
  MONGODB_COLLECTION

  # MongoDB Database.
  MONGODB_DATABASE

  # MongoDB Source Cluster.
  MONGODB_SOURCE

  # Managed Volume.
  ManagedVolume
  Mssql
  MssqlDatabaseBatchMaintenance
  NAS_FILESET
  NutanixVirtualMachine
  O365Calendar
  O365File
  O365Mailbox
  O365Onedrive
  O365SharePointDrive
  O365SharePointList
  O365Site
  O365Teams
  ORACLE_DATA_GUARD_GROUP
  OracleDatabase
  PolarisEbsVolume
  PolarisEc2Instance
  SapHanaDatabase
  ShareFileset
  SnapMirrorCloud
  StorageArrayVolumeGroup
  VcdVapp
  VmwareVirtualMachine
  VolumeGroup
  WindowsFileset
  WindowsVolumeGroup
}
# Operations defined in the RBAC system.
enum Operation {
  AddAwsCloudAccount
  AddAzureCloudAccount
  AddCluster
  AddGcpCloudAccount
  AddInventory
  AddStorageSettings
  CancelRunningActivity
  CategoryManageDataSource
  CategoryProtection
  CategoryRecovery
  CategoryViewDataSource
  ConfigureDataClassGlobal
  CreateReport
  CreateSLA
  CreateThreatHunt
  DeleteAwsCloudAccount
  DeleteAzureCloudAccount
  DeleteGcpCloudAccount
  DeleteInventory
  DeleteReport
  DeleteSLA
  DeleteSnapshot
  DeleteStorageSettings
  Download
  DownloadFromArchivalLocation
  DownloadSnapshotFromReplicationTarget
  EditAwsCloudAccount
  EditAzureCloudAccount
  EditCdmNetworkSetting
  EditCdmSupportSetting
  EditCdmSysConfig
  EditGcpCloudAccount
  EditNetworkThrottleSettings
  EditOrganization
  EditQuarantine
  EditReplicationSettings
  EditSecuritySettings
  EditStorageSettings
  EditSystemPreference
  EditUserManagement
  Export
  ExportDataClassGlobal
  ExportFiles
  ExportSnapshots
  InstantRecover

  # The operation to manage the SMB domain.
  MANAGE_SMB_DOMAIN

  # Add/remove nodes or disks to the cluster.
  MODIFY_CLUSTER_CAPACITY

  # Edit cluster network settings.
  MODIFY_CLUSTER_NETWORK
  ManageAccess
  ManageDataSource
  ManageLegalHold
  ManageProtection
  ManageSLA
  ManageWebhooks
  ModifyCluster
  ModifyInventory
  ModifyReport
  ModifySLA
  Mount
  ProvisionOnInfrastructure

  # Operation to Resize Managed Volume.
  RESIZE_MANAGED_VOLUME
  RecoverFromQuarantine
  RefreshDataSource
  RemoveCluster
  Restore
  RestoreToOrigin
  TakeOnDemandSnapshot
  ToggleBlackoutWindow
  TransferAccountOwnership
  UPDATE_ACCOUNT_OWNERSHIP
  UpgradeCluster

  # View account-wide data security risk metrics, scores, and recommendations.
  VIEW_DATA_SECURITY_DETAILS

  # The operation to view the SMB domain.
  VIEW_SMB_DOMAIN
  ViewAccess
  ViewAuditLog
  ViewAwsCloudAccount
  ViewAzureCloudAccount
  ViewCdmNetworkSetting
  ViewCdmSupportSetting
  ViewCdmSysConfig
  ViewCluster
  ViewDashboard
  ViewDataClassGlobal
  ViewGcpCloudAccount
  ViewInventory
  ViewInventoryWithHierarchy
  ViewNonSystemEvent
  ViewOrganization
  ViewReplicationSettings
  ViewReport
  ViewSLA
  ViewSecuritySettings
  ViewStorageSettings
  ViewSystemEvent
  ViewSystemPreference
  ViewThreatHuntResults
  ViewUserManagement
  ViewWebhooks
}
# Represents option group in AWS.
type OptionGroup {
  # Name of the option group.
  name: String!

  # Option group engine.
  engine: String!

  # Major version of the option group engine.
  majorEngineVersion: String!

  # Amazon Resource Name (ARN) of the option group.
  arn: String!

  # Virtual Private Cloud (VPC) corresponding to the option group.
  vpcId: String!
}
# The SLA Domain configuration for Oracle database.
type OracleConfig {
  # Frequency value for log backups of Oracle databases.
  frequency: Duration

  # Specifies the duration for which the logs will be retained.
  logRetention: Duration

  # Specifies the duration for which the archived redo logs will be retained.
  hostLogRetention: Duration
}
# The Oracle user details of this Physical Host.
type OracleUserDetails {
  # The system database administrator of this Physical Host.
  sysDbaUser: String!

  # The query user of this Physical Host.
  queryUser: String!
}
# Details of an org.
type Org {
  # ID of the organization.
  id: String!

  # Name of the organization.
  name: String!

  # Description of the organization.
  description: String!

  # Full name of the organization.
  fullName: String!

  # Specifies whether to use the SSO/LDAP configuration of the global organization or to use configuration specific to this organization.
  authDomainConfig: TenantAuthDomainConfig!

  # Specifies whether MFA is enforced for all users in the organization.
  shouldEnforceMfaForAll: Boolean!

  # Specifies whether organization is forced to use Rubrik Envoy to connect their hosts.
  isEnvoyRequired: Boolean!

  # Allowed clusters for the organization.
  allowedClusters: [String!]!

  # Physical storage used by the organization.
  physicalStorageUsed: Long!

  # Health of the tenant networks associated with the organization.
  tenantNetworkHealth: TenantNetworkHealth!

  # Organization admin role.
  orgAdminRole: Role!

  # Existing users in the organization.
  users: [ExistingUser!]!

  # Permissions given to the organization.
  permissions: [Permission!]!

  # SSO groups authorized for the organization.
  ssoGroups: [SsoGroup!]!
}
enum OsTypeEnum {
  Linux
  Other
  Undefined
  Windows
}
# General information about a page of results.
type PageInfo {
  # String used to identify the first edge in the response.
  startCursor: String!

  # String used to identify the last edge in the response.
  endCursor: String!

  # Specifies whether edges exist prior to the current page.
  hasPreviousPage: Boolean!

  # Specifies whether edges exist following the current page.
  hasNextPage: Boolean!
}
type PathNode {
  fid: UUID!
  name: String!
  objectType: HierarchyObjectTypeEnum!
}
# SLA Domain paused clusters information.
type PausedClustersInfo {
  # Number of Rubrik clusters where the SLA Domain is paused.
  pausedClustersCount: Int!

  # Rubrik clusters where the SLA Domain is paused.
  pausedClusters: [Cluster!]
}
enum PendingActionStatusEnum {
  FAILED
  IN_PROGRESS
  QUEUED
  SUCCEEDED
  SYNCED_TO_CDM
}
type PendingSnapshotsOfObjectDeletion {
  objectFid: UUID!
  status: PendingActionStatusEnum!
}
type Permission {
  operation: Operation!
  objectsForHierarchyTypes: [ObjectIdsForHierarchyType!]!
}
# Persistent storage configured for storing backups.
type PersistentStorage {
  # ID of the configured storage setting.
  id: String!

  # Name of the configured storage setting.
  name: String!
}
type PhysicalHost implements CdmHierarchyObject , HierarchyObject , MssqlTopLevelDescendantType , Db2InstanceDescendantType , Db2InstancePhysicalChildType , ManagedVolumeDescendantType , ManagedVolumeMountDescendantType , ManagedVolumeMountPhysicalChildType {
  cdmId: String!
  ipAddresses: [String!]!
  osName: String
  connectionStatus: HostConnectionStatus
  hostVolumes: [CdmHostVolume!]!
  isArchived: Boolean!
  vfdState: String!

  # Specifies if Physical Host is an Oracle Host.
  isOracleHost: Boolean!

  # The Oracle User details of this Physical Host.
  oracleUserDetails: OracleUserDetails

  # The operating system type of the physical host.
  osType: GuestOsTypeEnum

  # The default CBT status of this Physical Host.
  defaultCbt: Boolean

  # The CBT status of this Physical Host.
  cbtStatus: String

  # List of descendants.
  descendantConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Sort hierarchy objects by hierarchy field.
    sortBy: HierarchySortByField,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, typeFilter: [HierarchyObjectTypeEnum!],

    # The hierarchy object filter.
    filter: [Filter!],

    # Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects.
    snappableHierarchy: SnappableLevelHierarchyTypeEnum): PhysicalHostDescendantTypeConnection!

  # List of physical children.
  physicalChildConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Sort hierarchy objects by hierarchy field.
    sortBy: HierarchySortByField,

    # Sort hierarchy object by hierarchy order.
    sortOrder: HierarchySortOrder, typeFilter: [HierarchyObjectTypeEnum!],

    # The hierarchy object filter.
    filter: [Filter!],

    # Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects.
    snappableHierarchy: SnappableLevelHierarchyTypeEnum): PhysicalHostPhysicalChildTypeConnection!

  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
interface PhysicalHostDescendantType {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Paginated list of PhysicalHostDescendantType objects.
type PhysicalHostDescendantTypeConnection {
  # List of PhysicalHostDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [PhysicalHostDescendantTypeEdge!]!

  # List of PhysicalHostDescendantType objects.
  nodes: [PhysicalHostDescendantType!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of PhysicalHostDescendantType objects matching the request arguments.
  count: Int!
}
# Wrapper around the PhysicalHostDescendantType object. This wrapper is used for pagination.
type PhysicalHostDescendantTypeEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual PhysicalHostDescendantType object wrapped by this edge.
  node: PhysicalHostDescendantType!
}
interface PhysicalHostPhysicalChildType {
  # Rubrik cluster where this object originated.
  cluster: Cluster!

  # The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster.
  primaryClusterLocation: DataLocation!

  # SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM.
  pendingSla: SlaDomain

  # Mapping from objectID to pending object deletion status.
  pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion

  # Objects either replicated by this object or related to this object by replication.
  replicatedObjects: [CdmHierarchyObject!]!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # The number of objects either replicated by this object or related to this object by replication.
  replicatedObjectCount: Int!

  # The authorized operations on the object.
  authorizedOperations: [Operation!]!

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Paginated list of PhysicalHostPhysicalChildType objects.
type PhysicalHostPhysicalChildTypeConnection {
  # List of PhysicalHostPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [PhysicalHostPhysicalChildTypeEdge!]!

  # List of PhysicalHostPhysicalChildType objects.
  nodes: [PhysicalHostPhysicalChildType!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of PhysicalHostPhysicalChildType objects matching the request arguments.
  count: Int!
}
# Wrapper around the PhysicalHostPhysicalChildType object. This wrapper is used for pagination.
type PhysicalHostPhysicalChildTypeEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual PhysicalHostPhysicalChildType object wrapped by this edge.
  node: PhysicalHostPhysicalChildType!
}
# A Polaris Managed Hierarchy Object.
interface PolarisHierarchyObject {
  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Polaris protectable object.
interface PolarisHierarchySnappable {
  # The list of snapshots taken for this workload.
  snapshotConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Sort Polaris snapshots by field.
    sortBy: PolarisSnapshotSortByEnum = Date,

    # Sort order.
    sortOrder: SortOrderEnum): PolarisSnapshotConnection

  # The list of snapshots taken for this workload.
  snapshotsOfSnappableConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String, snappableId: String!,

    # Filter for snapshot connection.
    snapshotFilter: [SnapshotQueryFilterInput!],

    # Sort order.
    sortOrder: SortOrderEnum, sortBy: SnapshotQuerySortByField,

    # Time range input.
    timeRange: TimeRangeInput,

    # Specifies whether to ignore the active protected object check.
    ignoreActiveSnappableCheck: Boolean): GenericSnapshotConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    filter: PolarisSnapshotFilterInput,

    # Group Polaris snapshots by field.
    groupBy: PolarisSnapshotGroupByEnum!): PolarisSnapshotGroupByConnection

  # GroupBy connection for this snappable's snapshots.
  snapshotGroupByNewConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Offset based on customer timezone.
    timezoneOffset: Float = 0.0,

    # Filter Polaris snapshot connection.
    snapshotFilter: [PolarisSnapshotFilterNewInput!]!,

    # Group Polaris snapshots by field.
    snapshotGroupBy: SnapshotGroupByTimeEnum!): PolarisSnapshotGroupByNewConnection

  # The most recent snapshot of this workload.
  newestSnapshot: PolarisSnapshot

  # The oldest snapshot of this workload.
  oldestSnapshot: PolarisSnapshot

  # The number of on-demand snapshots.
  onDemandSnapshotCount: Int!

  # The newest snapshot that is indexed and unexpired, and therefore restorable.
  newestIndexedSnapshot: PolarisSnapshot

  # The fid of the hierarchy object.
  id: UUID!

  # The name of the hierarchy object.
  name: String!

  # The type of this object.
  objectType: HierarchyObjectTypeEnum!

  # The SLA Domain assignment type for this object.
  slaAssignment: SlaAssignmentTypeEnum!

  # The effective SLA Domain of the hierarchy object.
  effectiveSlaDomain: SlaDomain!

  # The pause status of the effective SLA Domain of the hierarchy object.
  slaPauseStatus: Boolean!

  # The distribution of the snapshots of the hierarchy object.
  snapshotDistribution: SnapshotDistribution!

  # The effective Retention SLA Domain of the hierarchy object.
  effectiveRetentionSlaDomain: SlaDomain

  # The configured SLA Domain of the hierarchy object.
  configuredSlaDomain: SlaDomain!

  # The path node of the effective SLA Domain source.
  effectiveSlaSourceObject: PathNode

  # A sequential list of this object's logical ancestors.
  logicalPath: [PathNode!]!

  # A sequential list of this object's physical ancestors.
  physicalPath: [PathNode!]!

  # The number of descendant workloads of this object.
  numSnappableDescendants: Int!

  # The organizations to which this hierarchy object belongs.
  allOrgs: [Org!]!
}
# Specific information for Amazon Web Services (AWS) target created on Polaris.
type PolarisManagedAwsTarget implements Target {
  # Template type of the storage settings.
  cloudNativeLocTemplateType: CloudNativeLocTemplateType!

  # Immutability settings of AWS target.
  immutabilitySettings: AwsImmutabilitySettingsType

  # Cloud account details of the AWS target.
  cloudAccount: CloudAccount!

  # Bucket name of the AWS target.
  bucket: String!

  # Region of the AWS target.
  region: AwsRegion!

  # Sync status of AWS target.
  syncStatus: TargetSyncStatusEnum!

  # Retrieval tier of the AWS target.
  awsRetrievalTier: AwsRetrievalTier!

  # Storage class of the AWS target.
  storageClass: AwsStorageClassTypeEnum!

  # Compute settings of the AWS target.
  computeSettings: AwsComputeSettings

  # Proxy settings of the AWS target.
  proxySettings: ProxySettings

  # Encryption type to be used for the AWS target.
  encryptionType: TargetEncryptionTypeEnum!

  # KMS master key ID required for encryption for the AWS target.
  kmsMasterKeyId: String!

  # Flag to check if consolidation is enabled or not in this target.
  isConsolidationEnabled: Boolean!

  # Reason why sync of this target with CDM failed.
  syncFailureReason: String!

  # Connected/Disconnected status of the AWS target.
  connectionStatus: ConnectionStatusType!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The ID of this Target.
  id: String!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific information for Azure target created on Polaris
type PolarisManagedAzureTarget implements Target {
  accessKey: String!

  # Compute settings of the Azure target.
  computeSettings: AzureComputeSettings

  # Connection status of the Azure target.
  connectionStatus: ConnectionStatusType!
  cloudNativeCompanion: AzureCloudNativeTargetCompanion

  # Cloud account details of the Azure target.
  cloudAccount: CloudAccount!

  # Instance type of the Azure location.
  instanceType: InstanceTypeEnum!

  # Immutability settings of the Azure target.
  immutabilitySettings: AzureImmutabilitySettingsType

  # Storage account name of the Azure target.
  storageAccountName: String!

  # Container name of the Azure target.
  containerName: String!

  # Proxy settings of the AWS target.
  proxySettings: ProxySettings

  # Sync status of Azure location.
  syncStatus: TargetSyncStatusEnum!

  # Flag to check if consolidation is enabled or not in this target.
  isConsolidationEnabled: Boolean!

  # Reason why sync of this target with CDM failed.
  syncFailureReason: String!

  # Flag to determine if tiering is supported in the Azure target.
  isAzureTieringSupported: Boolean

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The ID of this Target.
  id: String!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific information for Google Cloud Platform (GCP) target created on Polaris.
type PolarisManagedGcpTarget implements Target {
  encryptionPassword: String!
  serviceAccountJsonKey: String!

  # Proxy setting of this GCP target.
  archivalProxySettings: ProxySettings

  # Connection status of the GCP target.
  connectionStatus: ConnectionStatusType!

  # Region of GCP target.
  region: GcpRegionEnum!

  # Sync status of GCP target.
  syncStatus: TargetSyncStatusEnum!

  # Storage class of the GCP target.
  storageClass: GcpStorageClassTypeEnum!

  # Bucket of the GCP target.
  bucket: String!

  # Reason why sync of this target with CDM failed.
  syncFailureReason: String!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The ID of this Target.
  id: String!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific information for Network File System (NFS) target created on Polaris.
type PolarisManagedNfsTarget implements Target {
  # Field for specifying the authentication type of NFS.
  nfsAuthType: AuthTypeEnum!

  # Connection status of the Azure target.
  connectionStatus: ConnectionStatusType!

  # Host of the Nfs location.
  host: String!

  # Sync status of NFS location.
  syncStatus: TargetSyncStatusEnum!

  # Directory in the NFS location where snapshots will be exported.
  exportDir: String!

  # Version of NFS target.
  nfsVersion: Int!

  # Other NFS options.
  otherNfsOptions: String!

  # Lock period of the files in NFS in seconds.
  fileLockPeriodInSeconds: Int!

  # Destination folder in the NFS location.
  destinationFolder: String!

  # Flag to check if consolidation is enabled or not in this target.
  isConsolidationEnabled: Boolean!

  # Reason why sync of this target with CDM failed.
  syncFailureReason: String!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The ID of this Target.
  id: String!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific information for Rich Communication Services (RCS) target created on Polaris.
type PolarisManagedRcsTarget implements Target {
  rsaKey: String!

  # Sync status of RCV target.
  syncStatus: TargetSyncStatusEnum!

  # Region of RCV target.
  region: RcsRegionEnumType!

  # Tiers for RCV target.
  tier: RcsTierEnumType!

  # Space usage threshold of RCV target above which alert will be raised.
  spaceUsageAlertThreshold: Int!

  # Reason why sync of this target with CDM failed.
  syncFailureReason: String!

  # Storage consumption value of RCV target.
  storageConsumptionValue: Float!

  # Immutability lock duration of RCV target in days.
  immutabilityPeriodDays: Long!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The ID of this Target.
  id: String!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Specific information for Amazon S3 compatible target created on Polaris.
type PolarisManagedS3CompatibleTarget implements Target {
  accessKey: String!
  secretKey: String!
  encryptionKeyInDer: String!

  # Connection status of the S3Compatible target.
  connectionStatus: ConnectionStatusType!

  # Host of the S3Compatible location.
  endpoint: String!

  # Sync status of S3Compatible target.
  syncStatus: TargetSyncStatusEnum!

  # Prefix of the S3Compatible target bucket.
  bucketPrefix: String!

  # Number of buckets in the S3Compatible target.
  numberOfBuckets: Int!

  # Flag to check if consolidation is enabled or not in this target.
  isConsolidationEnabled: Boolean!

  # Flag to check if system proxy is being used in this target.
  useSystemProxy: Boolean!

  # Reason why sync of this target with CDM failed.
  syncFailureReason: String!

  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The ID of this Target.
  id: String!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
enum PolarisObjectAuthorizedOperationsEnum {
  ManageDataSource
  ManageProtection
  RefreshDataSource
  ViewInventory
}
# SLA Domain Sync status for a specified Rubrik cluster.
type PolarisSlaSyncStatus {
  clusterUuid: String!
  slaSyncStatus: SlaSyncStatus!
}
enum PolarisSnappableAuthorizedOperationsEnum {
  DeleteSnapshot
  Download
  ExportSnapshots
  ManageProtection
  RestoreToOrigin
  TakeOnDemandSnapshot
  ViewInventory
}
type PolarisSnapshot implements GenericSnapshot {
  id: UUID!
  date: DateTime!
  expirationDate: DateTime
  expiryHint: Boolean!
  snappableId: String!
  parentSnapshotId: String
  isCorrupted: Boolean!
  indexingAttempts: Long!
  indexTime: DateTime
  isUnindexable: Boolean!
  isOnDemandSnapshot: Boolean!
  isDeletedFromSource: Boolean!
  isReplicated: Boolean!
  unexpiredReplicaCount: Int!
  isArchived: Boolean!
  unexpiredArchivedSnapshotCount: Int!
  sequenceNumber: Int!
  consistencyLevel: SnapshotConsistencyLevelEnum!
  isDownloadedSnapshot: Boolean
  isReplica: Boolean
  isArchivalCopy: Boolean
  replicationLocations: [DataLocation!]

  # Indicates whether the snapshot has a valid replica.
  hasUnexpiredReplica: Boolean!

  # Indicates whether the snapshot has a valid archived copy.
  hasUnexpiredArchivedCopy: Boolean!

  # Latest User note information.
  latestUserNote: LatestUserNote

  # Polaris-specific information about snapshots of specific object types. Currently, this is only valid for Azure Virtual Machine and AWS EC2 snapshots.
  polarisSpecificSnapshot: PolarisSpecificSnapshot
  slaDomain: SlaDomain

  # Specifies whether or not the snapshot is indexed.
  isIndexed: Boolean!

  # Specifies whether or not the snapshot is expired.
  isExpired: Boolean!
}
# Paginated list of PolarisSnapshot objects.
type PolarisSnapshotConnection {
  # List of PolarisSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [PolarisSnapshotEdge!]!

  # List of PolarisSnapshot objects.
  nodes: [PolarisSnapshot!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of PolarisSnapshot objects matching the request arguments.
  count: Int!
}
# Wrapper around the PolarisSnapshot object. This wrapper is used for pagination.
type PolarisSnapshotEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual PolarisSnapshot object wrapped by this edge.
  node: PolarisSnapshot!
}
input PolarisSnapshotFilterInput {
  snappableId: [String!]
  timeRange: TimeRangeInput
  isOnDemandSnapshot: Boolean
}
input PolarisSnapshotFilterNewInput {
  field: FieldEnum = ALL
  texts: [String!] = []
}
# Polaris Snapshot data with groupby info applied to it.
type PolarisSnapshotGroupBy {
  # The data groupby info.
  groupByInfo: PolarisSnapshotGroupByInfo!

  # Paginated snapshot data.
  polarisSnapshotConnection(
    # Returns the first n elements from the list.
    first: Int,

    # Returns the elements in the list that come after the specified cursor.
    after: String,

    # Returns the last n elements from the list.
    last: Int,

    # Returns the elements in the list that come before the specified cursor.
    before: String,

    # Sort order.
    sortOrder: SortOrderEnum,

    # Sort Polaris snapshots by field.
    sortBy: PolarisSnapshotSortByEnum = Date): PolarisSnapshotConnection!

  # Further provide groupings for the data.
  polarisSnapshotGroupBy(
    # Group Polaris snapshots by field.
    groupBy: PolarisSnapshotGroupByEnum!): [PolarisSnapshotGroupBy!]!
}
# Paginated list of PolarisSnapshotGroupBy objects.
type PolarisSnapshotGroupByConnection {
  # List of PolarisSnapshotGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [PolarisSnapshotGroupByEdge!]!

  # List of PolarisSnapshotGroupBy objects.
  nodes: [PolarisSnapshotGroupBy!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of PolarisSnapshotGroupBy objects matching the request arguments.
  count: Int!
}
# Wrapper around the PolarisSnapshotGroupBy object. This wrapper is used for pagination.
type PolarisSnapshotGroupByEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual PolarisSnapshotGroupBy object wrapped by this edge.
  node: PolarisSnapshotGroupBy!
}
enum PolarisSnapshotGroupByEnum {
  Day
  Hour
  Month
  Quarter
  Week
  Year
}
union PolarisSnapshotGroupByInfo = TimeRangeWithUnit
# Polaris Snapshot data with groupby info applied to it.
type PolarisSnapshotGroupByNew {
  # The data groupby info.
  groupByInfo: PolarisSnapshotGroupByInfo!

  # Paginated snapshot data.
  polarisSnapshotConnection: PolarisSnapshotConnection!
}
# Paginated list of PolarisSnapshotGroupByNew objects.
type PolarisSnapshotGroupByNewConnection {
  # List of PolarisSnapshotGroupByNew objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [PolarisSnapshotGroupByNewEdge!]!

  # List of PolarisSnapshotGroupByNew objects.
  nodes: [PolarisSnapshotGroupByNew!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of PolarisSnapshotGroupByNew objects matching the request arguments.
  count: Int!
}
# Wrapper around the PolarisSnapshotGroupByNew object. This wrapper is used for pagination.
type PolarisSnapshotGroupByNewEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual PolarisSnapshotGroupByNew object wrapped by this edge.
  node: PolarisSnapshotGroupByNew!
}
enum PolarisSnapshotSortByEnum {
  Date
  SnappableId
  SnapshotId
}
# Polaris-specific information about snapshots of specific object types. Currently, this is only valid for Azure Virtual Machine and AWS EC2 snapshots.
interface PolarisSpecificSnapshot {
  # ID of the snapshot.
  snapshotId: UUID!
}
# Status of various CDM-to-Polaris data syncing jobs.
type PolarisSyncStatus {
  # Last success time of the object metadata syncing job.
  objectMetadataSyncLastSuccessTime: DateTime

  # Last success time of the cluster syncing job.
  clusterSyncLastSuccessTime: DateTime

  # Last success time of the events syncing job.
  eventsSyncLastSuccessTime: DateTime

  # Last success time of the reports syncing job.
  reportsSyncLastSuccessTime: DateTime

  # Last success time of the job-monitoring dashboard syncing job.
  jobMonitoringSyncLastSuccessTime: DateTime
}
# Input to initiate deletion of AWS cloud account.
input PrepareAwsCloudAccountDeletionInput {
  # Rubrik ID of account to be deleted.
  cloudAccountId: UUID!

  # Protection feature to be deleted for the cloud account.
  feature: CloudAccountFeature!
}
# Prepares AWS cloud account for deletion and initiates deletion of the account.
type PrepareAwsCloudAccountDeletionReply {
  # CloudFormation URL to delete the stack.
  cloudFormationUrl: String!

  # List of feature versions.
  featureRegionMap: [AwsCloudAccountFeatureVersion!]!

  # Template URL of the Cloudformation stack. The template URL is empty when the cloud account has no connected features and is to be deleted.
  templateUrl: String!
}
# Input to prepare feature update for AWS cloud account.
input PrepareFeatureUpdateForAwsCloudAccountInput {
  # AWS account ID.
  cloudAccountId: UUID!

  # List of features to be updated for the AWS account.
  features: [CloudAccountFeature!]!
}
# Response to prepare updation of AWS cloud account.
type PrepareFeatureUpdateForAwsCloudAccountReply {
  # CloudFormation URL to update cloud account.
  cloudFormationUrl: String!

  # AWS CloudFormation template URL.
  templateUrl: String!
}
type PreviewerClusterConfig {
  clusterId: String!
  enabled: Boolean!
}
# Represents a protected object and its corresponding SLA Domain.
type ProtectedObjectTypeToSla {
  # The type of the protected object.
  protectedObjectType: SnappableLevelHierarchyTypeEnum!

  # SLA Domain assigned to the object.
  slaAssignment: AzureNativeResourceGroupSlaAssignment!
}
enum ProtectionStatusEnum {
  DoNotProtect
  NoSla
  Protected
}
# Proxy settings for target.
type ProxySettings {
  proxyServer: String!
  portNumber: Int!
  username: String!
  protocol: String!
}
type QuarterlySnapshotSchedule {
  basicSchedule: BasicSnapshotSchedule
  dayOfQuarter: DayOfQuarter!
  quarterStartMonth: Month!
}
# Specific info for Rcs Azure Target Template.
type RcsAzureTargetTemplate implements TargetTemplate {
  # Region of RCV location template.
  region: RcsRegionEnumType!

  # Access tier for the RCV location.
  tier: RcsTierEnumType!

  # Immutability setting of the template, that defines thenumber of days for which stored data will be immutable.
  immutabilitySettings: RcsImmutabilitySettings!

  # The type of this Target.
  targetType: TargetTypeEnum!
}
# Immutability settings information for RCS Azure Target.
type RcsImmutabilitySettings {
  # Lock duration days defines the number of days for which stored data will be immutable.
  lockDurationDays: Long!
}
# Regions for Rubrik Cloud Storage Archival Location.
enum RcsRegionEnumType {
  # Canada East or Quebec City.
  CANADA_EAST

  # Europe north or Netherlands.
  EUROPE_NORTH

  # Europe west or Ireland.
  EUROPE_WEST

  # UK South or London.
  UK_SOUTH

  # US central or Iowa.
  US_CENTRAL

  # US east 2 or Virginia.
  US_EAST_2

  # US west 2 or Washington.
  US_WEST_2
}
# Tiers for Rubrik Cloud Vault Archival Location.
enum RcsTierEnumType {
  # Archive tier for Rubrik Cloud Vault Archival Location.
  ARCHIVE

  # Backup tier for Rubrik Cloud Vault Archival Location.
  BACKUP
}
# RDS DB Instance details from AWS.
type RdsInstanceDetailsFromAws {
  # Amazon Resource Name (ARN) of RDS Instance.
  rdsInstanceArn: String!

  # DB Engine of RDS Instance.
  dbEngine: String!

  # DB class for RDS Instance.
  dbInstanceClass: String!

  # Status of an RDS Instance. Refers to the health of the RDS Instance.
  dbInstanceStatus: String!

  # Allocated size of an RDS Instance.
  allocatedStorageInGb: Long!

  # ID of VPC in AWS.
  vpcId: String!

  # Name of option group of RDS Instance.
  optionGroupName: String!

  # Name of parameter group of RDS Instance.
  dbParameterGroupName: String!

  # Subnet group name of RDS Instance.
  dbSubnetGroupName: String!

  # Maintenance window for the RDS Instance.
  dbMaintenanceWindow: String!

  # Specifies whether RDS is available in multi Availability Zones (AZs). If true, it means it is a multi-AZ RDS Instance.
  isMultiAz: Boolean!

  # Primary Availability Zone (AZ) of RDS Instance.
  primaryAz: String!

  # Retention time for RDS backups.
  backupRetentionPeriod: Long!

  # Input/Output (IO) operation limit per second for RDS Instance.
  iops: Long!

  # RDS DB Instance engine version.
  engineVersion: String!

  # Key Management System (KMS) key ID associated with RDS Instance.
  kmsKeyId: String!

  # Storage type of RDS Instance. Amazon RDS provides three storage types: General Purpose SSD (also known as gp2), Provisioned IOPS SSD (also known as io1), and magnetic (also known as standard).
  storageType: String!

  # Port used to connect to the RDS Instance.
  port: Long!
}
# RDS Export defaults from AWS.
type RdsInstanceExportDefaults {
  # DB Engine of RDS Instance.
  dbEngine: AwsNativeRdsDbEngine!

  # Version of DB engine.
  dbEngineVersion: String!

  # DB class for RDS Instance.
  dbInstanceClass: AwsNativeRdsDbInstanceClass!

  # Virtual Private Cloud (VPC) associated with RDS Instance.
  vpcId: String!

  # Allocated size of an RDS Instance.
  allocatedStorageInGb: Long!

  # Key Management System (KMS) key ID associated with RDS Instance.
  kmsKeyId: String!

  # Name of option group of RDS Instance.
  optionGroupName: String!

  # NParameter group name of the RDS Instance.
  dbParameterGroupName: String!

  # Subnet group name of the RDS Instance.
  dbSubnetGroupName: String!

  # Primary Availability Zone (AZ) of RDS Instance.
  primaryAz: String!

  # Storage type of RDS Instance. Amazon RDS provides three storage types: General Purpose SSD (also known as gp2), Provisioned IOPS SSD (also known as io1), and magnetic (also known as standard).
  storageType: AwsNativeRdsStorageType!

  # Input/Output (IO) operation limit per second for RDS Instance.
  iops: Int!

  # Port used to connect to the RDS Instance.
  port: Long!

  # Specifies whether RDS is available in multi Availability Zones (AZs). If true, it means it is a multi-AZ RDS Instance.
  isMultiAz: Boolean!
}
# Retrieval method for reader archival locations.
enum ReaderRetrievalMethod {
  # Retrieval method that lists workloads as well as snapshots of each workload.
  OBJECT_LIST_AND_DETAILS

  # Retrieval method that lists only workloads.
  OBJECT_LIST_ONLY

  # Unknown retrieval method.
  UNKNOWN_RETRIEVAL_METHOD
}
# Filter to return objects which are relic or not.
input RelicFilter {
  relic: Boolean!
}
# Replication source for a given replication target.
type ReplicationSource {
  # UUID of the cluster.
  id: String!

  # UUID of the source cluster.
  sourceClusterUuid: UUID!

  # Name of the source cluster.
  sourceClusterName: String!

  # IP address of the source cluster.
  sourceClusterAddress: String

  # Total replicated storage on the target cluster from the source cluster.
  totalStorage: Long
}
type ReplicationSpec {
  replicationType: ReplicationType!
  specificReplicationSpec: SpecificReplicationSpec
}
type ReplicationSpecV2 {
  retentionDuration: Duration

  # Time snapshot is kept on local target cluster.
  replicationLocalRetentionDuration: Duration

  # Cascading Archival Specifications.
  cascadingArchivalSpecs: [CascadingArchivalSpec!]!
  targetMapping: TargetMapping

  # Rubrik cluster used as the replication target.
  cluster: SlaReplicationCluster
  awsRegion: String!
  azureRegion: String!

  # AWS location used as the replication target.
  awsTarget: AwsReplicationTarget!

  # Azure location used as the replication target.
  azureTarget: AzureReplicationTarget!
}
# Replication target for a given replication source.
type ReplicationTarget {
  # UUID of the cluster.
  id: String!

  # UUID of the target cluster.
  targetClusterUuid: UUID!

  # Name of the target cluster.
  targetClusterName: String!

  # IP address of the target cluster.
  targetClusterAddress: String

  # Total replicated storage on the target cluster from the source cluster.
  totalStorage: Long
}
type ReplicationToCloudLocationSpec {
  retentionDuration: Duration
  targetMapping: TargetMapping
}
type ReplicationToCloudRegionSpec {
  replicationTargetRegion: String!
  cloudProvider: CloudProvider!
  retention: Int!
  retentionUnit: RetentionUnitEnum!
}
# Type of replication.
enum ReplicationType {
  # Replication to cloud location.
  REPLICATION_TO_CLOUD_LOCATION

  # Replication to the cloud region.
  REPLICATION_TO_CLOUD_REGION

  # Unidirectional replication to the Rubrik CDM cluster.
  UNIDIRECTIONAL_REPLICATION_TO_CLUSTER

  # Replication type unknown.
  UNKNOWN_REPLICATION_TYPE
}
enum RetentionUnitEnum {
  DAYS
  HOURS
  MINUTES
  MONTHS
  QUARTERS
  WEEKS
  YEARS
}
type Role {
  id: String!
  name: String!
  description: String!
  isReadOnly: Boolean!
  protectableClusters: [String!]!
  permissions: [Permission!]!
}
enum SLAComplianceTimeRangeEnum {
  Last24Hours
  Last2Snapshots
  Last3Snapshots
  LastSnapshot
  Past30Days
  Past365Days
  Past7Days
  Past90Days
  SinceProtection
}
# Type of objects managed by SLA Domains.
enum SLAObjectTypeEnum {
  AWS_EC2_EBS_OBJECT_TYPE
  AWS_RDS_OBJECT_TYPE
  AZURE_OBJECT_TYPE
  AZURE_SQL_DATABASE_OBJECT_TYPE
  AZURE_SQL_MANAGED_INSTANCE_OBJECT_TYPE
  CASSANDRA_OBJECT_TYPE

  # Db2.
  DB2_OBJECT_TYPE

  # Microsoft Exchange.
  EXCHANGE_OBJECT_TYPE
  FILESET_OBJECT_TYPE
  GCP_OBJECT_TYPE

  # HyperV SLA Object.
  HYPERV_OBJECT_TYPE
  KUPR_OBJECT_TYPE
  MANAGED_VOLUME_OBJECT_TYPE
  MONGODB_OBJECT_TYPE
  MSSQL_OBJECT_TYPE
  NAS_OBJECT_TYPE

  # Nutanix object.
  NUTANIX_OBJECT_TYPE
  O365_OBJECT_TYPE

  # Oracle object.
  ORACLE_OBJECT_TYPE
  SAP_HANA_OBJECT_TYPE
  SNAPMIRROR_CLOUD_OBJECT_TYPE
  UNKNOWN_OBJECT_TYPE
  VOLUME_GROUP_OBJECT_TYPE
  VSPHERE_OBJECT_TYPE
}
type SapHanaConfig {
  incrementalFrequency: Duration
  logRetention: Duration
  differentialFrequency: Duration
}
# Input for setting the app credentials in the Azure Cloud Accounts.
input SetAzureCloudAccountCustomerAppCredentialsInput {
  # Client ID of the Application.
  appId: String!

  # Client secret key of the Application.
  appSecretKey: String!

  # ID of the home tenant of the application.
  appTenantId: String

  # Name of the application.
  appName: String

  # Domain Name of the Azure tenant.
  tenantDomainName: String

  # Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud.
  azureCloudType: AzureCloudType! = AZUREPUBLICCLOUD
}
# Information about the Rubrik cluster where the archival location is created.
type SlaArchivalCluster {
  # ID of the Rubrik cluster.
  id: UUID!

  # Name of the cluster.
  name: String!
}
enum SlaAssignmentTypeEnum {
  Derived
  Direct
  Unassigned
}
interface SlaDomain {
  # The ID of the SLA Domain.
  id: String!

  # The name of the SLA Domain.
  name: String!

  # The version of the SLA Domain.
  version: String

  # The object-specific configurations of the SLA Domain.
  objectSpecificConfigs: ObjectSpecificConfigs
}
type SlaLogFrequencyConfigResult {
  retention: Duration
}
# Reasons for the SLA being ineligible for migration.
enum SlaMigrationIneligibilityReason {
  # The remote SLA Domain has an archival policy configured, which is not supported in Polaris currently.
  CASCADED_ARCHIVAL_CONFIGURED

  # Rubrik cluster associated with the SLA Domain is disconnected.
  CLUSTER_DISCONNECTED

  # The version of the Rubrik cluster associated with the SLA Domain is not valid for SLA migration.
  INVALID_CLUSTER_VERSION

  # SLA Domain is not associated with a Rubrik cluster.
  INVALID_LOCAL_SLA

  # The type of replication targets is invalid for migration.
  INVALID_REPLICATION_TARGET

  # Replication targets associated with the SLA Domain have invalid cluster version for migration.
  INVALID_REPLICATION_TARGET_VERSION

  # The SLA Domain has frequency configured in minutes, which is currently not supported in Polaris.
  MINUTE_FREQUENCY_CONFIGURED

  # SLA Domain is eligible for migration.
  NOT_APPLICABLE

  # Replication targets associated with the SLA Domain are disconnected.
  REPLICATION_TARGET_DISCONNECTED

  # The SLA Domain has retention lock configured, which is not supported in Polaris currently.
  RETENTION_LOCK_CONFIGURED

  # The SLA Domain is protecting some objects which are currently not supported for upgrade.
  UNSUPPORTED_PROTECTED_OBJECTS
}
enum SlaMigrationStatus {
  FAILED
  IN_PROGRESS
  STUCK
  SUCCEEDED
}
# Replication cluster specific information.
type SlaReplicationCluster {
  # Id of replication cluster.
  id: UUID!

  # Name of replication cluster.
  name: String!
}
# Status of the latest attempt to sync the SLA Domain to the clusters.
enum SlaSyncStatus {
  # Sync failed.
  FAILED

  # Sync not attempted.
  NOT_ATTEMPTED

  # Sync pending.
  PENDING

  # Sync successful.
  SUCCEEDED
}
# Information about the most recently attempted SLA Domain upgrade.
type SlaUpgrade {
  # Status of the upgrade.
  status: SlaMigrationStatus!

  # Failure message.
  msg: String!

  # Taskchain ID for upgrade.
  taskchainId: String!
}
# Information about eligibility of the SLA Domain for upgrade.
type SlaUpgradeEligibility {
  # Specifies whether the SLA Domain is eligible for upgrade.
  isEligible: Boolean!

  # Reason for the SLA Domain being ineligible for upgrade.
  ineligibilityReason: SlaMigrationIneligibilityReason!
}
# SLA Domain upgrade information.
type SlaUpgradeInfo {
  # Information about eligibility of the SLA Domain for upgrade.
  eligibility: SlaUpgradeEligibility

  # Information about the most recently attempted SLA Domain upgrade.
  latestUpgrade: SlaUpgrade
}
# An object that can be backed-up by taking snapshots.
type Snappable {
  # The ID of the workload.
  id: String!

  # The name of the workload.
  name: String!

  # The current compliance status of the workload.
  complianceStatus: ComplianceStatusEnum

  # The protection status of the workload.
  protectionStatus: ProtectionStatusEnum!

  # The type of the workload.
  objectType: ObjectTypeEnum!

  # The date and time when the workload was last protected.
  protectedOn: DateTime

  # The total number of snapshots present for the snapshot.
  totalSnapshots: Int

  # The number of snapshots that were missed.
  missedSnapshots: Int

  # The timestamp of the last taken snapshot.
  lastSnapshot: DateTime
  latestArchivalSnapshot: DateTime
  latestReplicationSnapshot: DateTime
  localOnDemandSnapshots: Int
  localSlaSnapshots: Int
  archivalSnapshotLag: Int
  replicationSnapshotLag: Int
  archivalComplianceStatus: ComplianceStatusEnum
  replicationComplianceStatus: ComplianceStatusEnum
  awaitingFirstFull: Boolean

  # The time at which the workload data was retrieved from CDM.
  pullTime: DateTime!
  location: String!

  # The local storage size in bytes.
  localStorage: Long

  # The local metered data size in bytes.
  localMeteredData: Long

  # Total bytes used.
  usedBytes: Long

  # The provisioned bytes size.
  provisionedBytes: Long

  # The local protected data size in bytes.
  localProtectedData: Long

  # The local effective storage size in bytes.
  localEffectiveStorage: Long

  # The organization ID of this workload.
  orgId: UUID

  # The SLA Domain of the protected objects.
  slaDomain: SlaDomain

  # The Rubrik cluster to which the protected objects belong.
  cluster: Cluster
  fid: UUID

  # The number of snapshots locally present.
  localSnapshots: Int

  # The number of snapshots that have been replicated.
  replicaSnapshots: Int

  # The number of snapshots that have been archived.
  archiveSnapshots: Int

  # Physical bytes taken by snapshots of this workload.
  physicalBytes: Long

  # Bytes ingested over the network for this workload.
  transferredBytes: Long

  # Logical bytes taken by snapshots of this workload.
  logicalBytes: Long

  # The amount of storage taken by replicated snapshots.
  replicaStorage: Long

  # The amount of storage taken by archived snapshots.
  archiveStorage: Long

  # The change from transferred bytes to physical bytes.
  dataReduction: Float
  logicalDataReduction: Float

  # The organization name related to the workload.
  orgName: String
}
type SnappableAggregation {
  totalSnapshots: Int!
  missedSnapshots: Int!
  archiveStorage: Long!
  replicaStorage: Long!
  physicalBytes: Long!
  logicalBytes: Long!
}
# Paginated list of Snappable objects.
type SnappableConnection {
  # List of Snappable objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed.
  edges: [SnappableEdge!]!

  # List of Snappable objects.
  nodes: [Snappable!]!

  # General information about this page of results.
  pageInfo: PageInfo!

  # Total number of Snappable objects matching the request arguments.
  count: Int!
  aggregation: SnappableAggregation!
}
# Wrapper around the Snappable object. This wrapper is used for pagination.
type SnappableEdge {
  # String used to identify this edge.
  cursor: String!

  # The actual Snappable object wrapped by this edge.
  node: Snappable!
}
# Filter snappable data.
input SnappableFilterInput {
  protectionStatus: [ProtectionStatusEnum!]
  slaDomain: SnappableSlaDomainFilterInput
  complianceStatus: [ComplianceStatusEnum!]
  objectType: [ObjectTypeEnum!]
  cluster: CommonClusterFilterInput
  searchTerm: String
  slaTimeRange: SLAComplianceTimeRangeEnum
}
enum SnappableLevelHierarchyTypeEnum {
  AllSubHierarchyType
  AwsNativeEbsVolume
  AwsNativeEc2Instance
  AwsNativeRdsInstance
  AzureNativeManagedDisk
  AzureNativeVirtualMachine
  AzureSqlDatabaseDb
  AzureSqlManagedInstanceDb
  GcpNativeGCEInstance
  KuprNamespace
  O365Mailbox
  O365Onedrive
  O365SharePointDrive
  O365SharePointList
  O365Site
  O365Teams
}
# Filter snappable data based on properties of its Sla domain.
input SnappableSlaDomainFilterInput {
  id: [String!]
}
# Details of the setup for performing backups for various object types.
type SnappableTypeToBackupSetupSpecs {
  # The object type.
  snappableType: SnappableLevelHierarchyTypeEnum!

  # The object from where the setup specification is inherited.
  setupSourceObject: PathNode!
}
enum SnapshotConsistencyLevelEnum {
  SNAPSHOT_APP_CONSISTENT
  SNAPSHOT_CRASH_CONSISTENT
  UNKNOWN_CONSISTENCY_LEVEL
}
# A generic snapshot type.
type SnapshotDistribution {
  # Total number of snapshots.
  totalCount: Long!

  # Number of scheduled snapshots.
  scheduledCount: Long!

  # Number of on demand snapshots.
  onDemandCount: Long!

  # Number of retrieved snapshots.
  retrievedCount: Long!

  # The ID of the snappable.
  id: UUID!
}
enum SnapshotGroupByTimeEnum {
  Day
  Hour
  Month
  Quarter
  Week
  Year
}
# Filters to query snapshots.
enum SnapshotQueryFilterField {
  # A comma-separated list of archival location IDs. Returns snapshots from
  # all archival locations corresponding to the specified IDs.
  ARCHIVAL_LOCATION_IDS

  # Returns all AWS EBS snapshots from the specified AWS account.
  EBS_AWS_NATIVE_ACCOUNT_ID

  # Returns all AWS EC2 snapshots from the specified AWS account.
  EC2_AWS_NATIVE_ACCOUNT_ID

  # When true, returns snapshots that are not anomalous.
  EXCLUDE_ANOMALOUS

  # When true, returns snapshots that are not quarantined.
  EXCLUDE_QUARANTINED

  # When true, returns snapshots for which index files are present,
  # i.e. either the index storage path is present or there have been indexing
  # attempts on the snapshot.
  # Note: In case of cloud native indexing failures(indexing attempts > 0),
  # some indexing status log files are stored at the location where index
  # files are usually stored.
  HAS_CLOUD_NATIVE_INDEX_FILES

  # When the value is true, returns snapshots with one or more unexpired
  # archived snapshots.
  HAS_UNEXPIRED_ARCHIVED_SNAPSHOTS

  # When the value is true, this filter returns snapshots with one or more
  # unexpired replicas.
  HAS_UNEXPIRED_REPLICAS

  # Returns the entries where value of lock_end_time column is null or
  # is less than the the provided time in the field time.
  IMMUTABLE_LOCK_END_TIME_BEFORE

  # Does not return AppFlows-related details for the snapshots.
  IS_APPFLOWS_QUERY_SNAPSHOT_DETAILS_NOT_NEEDED

  # When true, this filter returns the snapshots created as a result of
  # archiving source snapshots. When false, the filter returns snapshots
  # that were not created due to archiving.
  IS_ARCHIVAL_COPY

  # When the value is true, this filter returns snapshots that are archived.
  IS_ARCHIVED

  # When true, returns snapshots that are deleted from source.
  IS_DELETED_FROM_SOURCE
  IS_DOWNLOADED

  # When true, returns snapshots that have been deleted, else
  # returns all non-deleted snapshots (may/may not be expired).
  IS_GCED

  # When true, this returns snapshots that have been indexed, else
  # returns snapshots that have not been indexed.
  IS_INDEXED

  # When true, returns snapshots that have been placed on legal
  # hold, else return all snapshots which are not legally held.
  IS_LEGALLY_HELD

  # When true, returns source snapshots that are not globally expired
  # i.e. snapshot is unexpired on source or has an unexpired replica/archival
  # copy, else returns globally expired source snapshots.
  IS_NOT_GLOBALLY_EXPIRED
  IS_ON_DEMAND
  IS_REPLICA

  # When true, returns snapshots that have been replicated.
  # When false, returns snapshots which have not been replicated.
  IS_REPLICATED

  # When true, returns incremental snapshots of SAP HANA
  # snappable. When false, returns full snapshots.
  IS_SAP_HANA_INCREMENTAL_SNAPSHOT

  # When true, returns snapshots that were skipped for
  # replication. When false, returns snapshots which were not skipped.
  IS_SKIPPED_FOR_REPLICATION

  # When the filter text list is provided, returns all on-demand snapshots
  # that are assigned any of the given SLA Domain IDs.
  # Note: text field will not be used for this filter.
  ON_DEMAND_SLA_ID

  # Returns all AWS RDS snapshots from the specified AWS account.
  RDS_AWS_NATIVE_ACCOUNT_ID
  SLA_ID

  # List of protectable object types. When this list is configured with
  # object types, it returns snapshots of that type.
  SNAPPABLE_TYPES

  # Returns snapshots for which the snapshot_status field is in
  # the specified state. This is a text field.
  SNAPSHOT_STATUS
  SNAPSHOT_TYPE
}
# Filter snapshots.
input SnapshotQueryFilterInput {
  # Type of filter.
  field: SnapshotQueryFilterField = SLA_ID

  # Additional Information for the filter type.
  text: String = ""

  # Snapshot types to be filtered.
  typeFilters: [SnapshotTypeEnum!] = []

  # Snapshots from linked snappables.
  shouldFetchLinked: Boolean = false

  # List of search texts for the filter type.
  textList: [String!] = []
  time: DateTime
}
enum SnapshotQuerySortByField {
  CREATION_TIME
  UNKNOWN
}
type SnapshotSchedule {
  minute: MinuteSnapshotSchedule
  hourly: HourlySnapshotSchedule
  daily: DailySnapshotSchedule
  weekly: WeeklySnapshotSchedule
  monthly: MonthlySnapshotSchedule
  quarterly: QuarterlySnapshotSchedule
  yearly: YearlySnapshotSchedule
}
# Enum to describe whether snapshot has AMI-based or crash-consistent consistency.
enum SnapshotServiceConsistencyLevel {
  # AMI-based consistency level.
  AMI_BASED

  # Crash-consistent snapshot.
  CRASH_CONSISTENT
}
# Type of snapshot to be used for recovery.
enum SnapshotType {
  # Archived snapshot.
  ARCHIVED

  # Replicated snapshot.
  REPLICATED

  # Source snapshot.
  SOURCE
}
enum SnapshotTypeEnum {
  DOWNLOADED
  ON_DEMAND
  SCHEDULED
}
# The type of snapshot to be used for recovery operations if source snapshot is expired.
enum SnapshotTypeForRestoreIfSourceExpired {
  # Use the archived snapshot.
  ARCHIVED

  # Use the replicated snapshot.
  REPLICATED
}
# The snapshot type to use if source snapshot is expired.
enum SnapshotTypeToUseIfSourceExpired {
  # Archived snapshot.
  ARCHIVED

  # Replicated snapshot.
  REPLICATED
}
enum SortOrderEnum {
  Asc
  Desc
}
type SpecificReplicationSpec {
  unidirectionalSpec: UnidirectionalReplicationSpec
  bidirectionalSpec: BidirectionalReplicationSpec
  cloudRegionSpec: ReplicationToCloudRegionSpec
  cloudLocationSpec: ReplicationToCloudLocationSpec
}
# Details of an SSO Group.
type SsoGroup {
  # Name of the SSO Group.
  name: String!

  # Specifies whether the users in the group are org admins.
  isOrgAdmin: Boolean!
}
# Input required to start the job to disable AWS Exocompute.
input StartAwsExocomputeDisableJobInput {
  # Rubrik ID of the account for which Exocompute needs to be disabled.
  cloudAccountId: UUID!
}
# Input to trigger AWS native account disable job.
input StartAwsNativeAccountDisableJobInput {
  # Rubrik ID of AWS account.
  awsAccountRubrikId: UUID!

  # Specifies whether to delete snapshots in the account.
  shouldDeleteNativeSnapshots: Boolean!

  # Type of native protection to be disabled.
  awsNativeProtectionFeature: AwsNativeProtectionFeature!
}
# Input to initiate a job to create AWS EC2 instance snapshots.
input StartAwsNativeEc2InstanceSnapshotsJobInput {
  # List of Rubrik EC2 instance IDs.
  ec2InstanceIds: [UUID!]!

  # Retention SLA Rubrik ID.
  retentionSlaId: String = ""
}
# Input to initiate job to create AWS RDS Instance snapshots.
input StartAwsNativeRdsInstanceSnapshotsJobInput {
  # List of Rubrik UUIDs of the RDS Instances.
  rdsInstanceIds: [UUID!]!

  # ID of the SLA Domain to be used for retention of the snapshots that are created by the RDS instance snapshot job.
  retentionSlaId: String = ""
}
# Input for initiating authentication of the Azure Cloud Accounts.
input StartAzureCloudAccountOauthInput {
  # Domain name of the Azure Tenant.
  tenantDomainName: String

  # Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud.
  azureCloudType: AzureCloudType = AZUREPUBLICCLOUD
}
# Response of the operation to initiate Azure Cloud Account OAuth.
type StartAzureCloudAccountOauthReply {
  # Client ID of the application configured for authentication of the Azure tenant.
  clientId: String!

  # Session ID of the current OAuth session.
  sessionId: String!
}
# Input to initiate the snapshot creation job for AWS native EBS volume.
input StartCreateAwsNativeEbsVolumeSnapshotsJobInput {
  # Rubrik UUIDs of EBS volumes for snapshot creation.
  ebsVolumeIds: [UUID!]!

  # Retention SLA ID to be used for the snapshots to be created.
  retentionSlaId: String = ""
}
# Input to initiate a job to create Azure Native Managed Disk snapshots.
input StartCreateAzureNativeManagedDiskSnapshotsJobInput {
  # Rubrik UUIDs of the managed disks whose snapshots are to be taken..
  managedDiskRubrikIds: [UUID!]!

  # The ID of the SLA Domain assigned to protect the on-demand snapshot.
  retentionSlaId: String
}
# Input to initiate a job to create Azure Native Virtual Machine snapshots.
input StartCreateAzureNativeVirtualMachineSnapshotsJobInput {
  # Rubrik UUIDs of the Virtual Machines (VMs) whose snapshots are to be taken.
  virtualMachineRubrikIds: [UUID!]!

  # Retention SLA ID of the on-demand snapshot.
  retentionSlaId: String
}
# Input for the job to start disabling protection from the Azure Native Subscription.
input StartDisableAzureNativeSubscriptionProtectionJobInput {
  # The Rubrik ID of the Azure subscription for which to disable protection.
  azureSubscriptionRubrikId: UUID!

  # Specifies whether to delete the snapshots associated with the subscription being deleted. When true, deletes the snapshots associated with the subscription being deleted.
  shouldDeleteNativeSnapshots: Boolean!

  # Type of native protection to be disabled.
  azureNativeProtectionFeature: AzureNativeProtectionFeature!
}
# Input to initiate an export job for an AWS native EC2 instance.
input StartEc2InstanceSnapshotExportJobInput {
  # ID of the snapshot to be exported.
  snapshotId: UUID!

  # Rubrik UUID of the AWS account where the instance will be exported.
  destinationAwsAccountRubrikId: UUID!

  # AWS Native EC2 instance type to be used after export. Some examples are: t2.nano, m5.xlarge. For more information, see https://aws.amazon.com/ec2/instance-types.
  instanceType: AwsNativeEc2InstanceType!

  # Name of the exported instance.
  instanceName: String!

  # List of security group IDs to be used for the exported instance.
  securityGroupIds: [String!]!

  # ID of the subnet to use for the exported instance.
  subnetId: String!

  # Region of the exported instance.
  destinationRegionId: AwsNativeRegion!

  # Specifies whether to copy tags to the exported instance.
  shouldCopyTags: Boolean!

  # ID of the KMS key to be used for export.
  kmsKeyId: String = ""

  # Name of the SSH key pair to be used for export.
  sshKeyPairName: String = ""

  # Power state of the exported instance.
  exportInstanceInPoweredOffState: Boolean = false

  # Type of snapshot used for export.
  snapshotType: SnapshotType = SOURCE

  # ID of the Amazon Machine Image (AMI) to be used for launching the EC2 instance. This field should be specified only when snapshotType is specified as Archived and amiTypeForAwsNativeArchivedSnapshot returns AMI type as USER_SPECIFIED. In other cases, either a pre-existing AMI is picked, or a new AMI is created at runtime, and an AMI ID is not required. The AMI specified here should be present in the target account and region of export. The specified AMI will be used for launching the instance for export, and all its volumes will be replaced.
  amiId: String

  # ARN of the IAM instance profile to be attached to the exported EC2 instance.
  iamInstanceProfileArn: String
}
# Input to initiate an export job for the AWS native EBS volume.
input StartExportAwsNativeEbsVolumeSnapshotJobInput {
  # ID of the snapshot to be exported.
  snapshotId: UUID!

  # Rubrik UUID of the AWS account where exported volume will reside.
  destinationAwsAccountRubrikId: UUID!

  # Region of the exported volume.
  destinationRegionNativeId: AwsNativeRegion!

  # Name of the exported volume.
  volumeName: String!

  # Size of the exported volume in Giga Bytes.
  volumeSize: Int!

  # AWS Native EBS volume type. Some examples are: g3, io2. For more information, see https://aws.amazon.com/ebs/volume-types.
  volumeType: AwsNativeEbsVolumeType!

  # Availability Zone (AZ) of the exported volume.
  availabilityZone: String!

  # Input/Output (IO) operation limit per second for the exported volume.
  iops: Int!

  # Specifies whether to copy tags to the exported volume.
  shouldCopyTags: Boolean!

  # Specifies whether to replace attached volumes.
  shouldReplaceAttached: Boolean!

  # ID of the KMS key to be used for export.
  kmsKeyId: String = ""

  # Type of snapshot used for export.
  snapshotType: SnapshotType = SOURCE
}
# Input for the job to export the specified Azure Native Managed Disk to the specified destination.
input StartExportAzureNativeManagedDiskJobInput {
  # Snapshot ID of the snapshot with which the disk is to be exported.
  snapshotId: UUID!

  # Name of the disk created after export.
  diskName: String!

  # Native ID of the disk encryption set for encrypting the newly created disks.
  diskEncryptionSetNativeId: String

  # Type of the disk created after export.
  diskStorageTier: AzureNativeManagedDiskType!

  # Size of the disk created after export, in GiB.
  diskSize: Int!

  # Resource group to be associated with the disk created after export.
  resourceGroup: String!

  # Region in which the disk created after export will exist.
  destinationRegion: AzureNativeRegion!

  # Availability Zone in which to export the disk. It is empty for regions types which do not support availability zones.
  destinationAvailabilityZone: String

  # Rubrik ID of the subscription in which to export the disk. When empty, the disk is exported to same subscription.
  destinationSubscriptionRubrikId: UUID

  # Specifies whether to export tags from the snapshot or not. When true, the tags from the snapshot are exported as well.
  shouldExportTags: Boolean!

  # Specifies whether to run only the export job or to run both the export and replace jobs. When true, the attached managed disk is exported and replaced.
  shouldReplaceAttachedManagedDisk: Boolean!

  # Specifies whether to recover from the replica of the source snapshot or not. Default value is false.
  shouldUseReplica: Boolean

  # The type of the snapshot to recover from.
  snapshotType: AzureSnapshotType
}
# Input for the job to export the specified Azure Native Virtual Machine to the specified destination.
input StartExportAzureNativeVirtualMachineJobInput {
  # The snapshot ID of the snapshot used to export a virtual machine.
  snapshotId: UUID!

  # The name of the virtual machine created as a result of the export job.
  virtualMachineName: String!

  # Native ID of the disk encryption set for encrypting the newly created disks.
  diskEncryptionSetNativeId: String

  # The resource group associated with the virtual machine created by the export job.
  resourceGroupName: String!

  # The region where the virtual machine created by the export job exists.
  destinationRegion: AzureNativeRegion!

  # The Availability Zone where the virtual machine created by the export job exists. When the region type does not support Availability Zones, this value is null.
  destinationAvailabilityZone: String

  # The Rubrik ID of the Azure subscription to which the virtual machine is exported. When this value is not specified, the virtual machine is exported to the same Azure subscription.
  destinationSubscriptionRubrikId: UUID

  # The size, in GiB, of the virtual machine created by the export job.
  virtualMachineSize: String!

  # The native ID of the subnet used by the virtual machine created by the export job.
  subnetNativeId: String!

  # The native ID of the network security group used by the virtual machine created by the export job.
  networkSecurityGroupNativeId: String

  # Specifies whether to export the tags from the snapshot.
  shouldExportTags: Boolean!

  # Specifies whether to export the virtual machine in a powered-down state.
  shouldPowerOff: Boolean!

  # Specifies whether to recover from a replica of the source snapshot.
  shouldUseReplica: Boolean

  # The native ID of the availability set used by the virtual machine created by the export job.
  availabilitySetNativeId: String

  # Specifies whether to enable accelerated networking for the virtual machine created by the export job. This value is false by default.
  shouldEnableAcceleratedNetworking: Boolean

  # The type of the snapshot to recover from.
  snapshotType: AzureSnapshotType

  # Specifies a list of Azure disk unique native IDs that will be exported. When empty, all disks from the snapshot will be exported.
  recoveryDiskIds: [UUID!]
}
# Input to trigger AWS native RDS Instance export job.
input StartExportRdsInstanceJobInput {
  # Rubrik ID of the RDS Instance to be exported.
  rdsInstanceId: UUID!

  # Specifies whether the export of the instance is from snapshot or point-in-time.
  isPointInTime: Boolean!

  # ID of the snapshot if the export is from snapshot.
  snapshotId: String

  # Export timestamp for Point in Time recovery of the instance.
  exportTime: DateTime

  # Name of the exported RDS DB instance.
  dbInstanceName: String!

  # AWS account in which the exported RDS instance will be launched.
  destinationAwsNativeAccountId: String!

  # Region in which the exported RDS DB instance will be launched.
  destinationRegionNativeId: AwsNativeRegion!

  # Instance class of RDS instance.
  dbInstanceClass: AwsNativeRdsDbInstanceClass!

  # Availability Zone (AZ) in which the exported RDS DB instance must be launched.
  primaryAz: String = ""

  # Port on which the exported RDS DB instance accepts connections.
  port: Long!

  # Name of the option group selected by the user for the new RDS instance.
  optionGroupName: String = ""

  # Name of the DB parameter group selected by the user for the new RDS instance.
  parameterGroupName: String = ""

  # Name of the subnet group for the new RDS instance.
  subnetGroupName: String = ""

  # Storage type of the exported RDS DB instance.
  storageType: AwsNativeRdsStorageType = NOT_SPECIFIED

  # List of security group IDs for the new RDS instance. Default security group is used if empty list is provided here.
  securityGroupIds: [String!] = []

  # Input Output (I/O) per second of the exported RDS DB instance.
  iops: Int = 0

  # Specifies whether the new RDS instance is publicly accessible or not.
  isPubliclyAccessible: Boolean!

  # Specifies whether tags will be exported to the new RDS instance.
  shouldExportTags: Boolean!

  # Specifies whether the exported RDS DB instance is multi-AZ or not.
  isMultiAz: Boolean!

  # KMS Key ID of the exported RDS DB instance.
  kmsKeyId: String = ""

  # List of subnet IDs for the newly created subnet group, which will be associated with the exported RDS DB instance. Default subnet ids are used if empty list is provided here.
  subnetIds: [String!] = []

  # Type of snapshot used for export. Required only if export is from a snapshot.
  snapshotType: SnapshotType = SOURCE
}
# Input to initiate a job to refresh an AWS native account.
input StartRefreshAwsNativeAccountsJobInput {
  # Rubrik UUIDs of the AWS account to be refreshed.
  awsAccountRubrikIds: [UUID!]!

  # Native protection feature to be refreshed.
  awsNativeProtectionFeatures: [AwsNativeProtectionFeature!]!
}
# Input to trigger the Refresh Azure Native Subscriptions job.
input StartRefreshAzureNativeSubscriptionsJobInput {
  # Rubrik IDs of the Azure Native Subscriptions to be refreshed.
  azureSubscriptionRubrikIds: [UUID!]!
}
# Trigger AWS EC2 instance snapshot restore job.
input StartRestoreAwsNativeEc2InstanceSnapshotJobInput {
  # ID of snapshot to restore.
  snapshotId: String!

  # Specifies the power status of the restored EC2 Instance. When true, the EC2 Instance is powered-on after completion of the restore.
  shouldPowerOn: Boolean!

  # Specifies whether to restore associated tags. If true, the restored EC2 Instance will have same tags associated.
  shouldRestoreTags: Boolean!

  # Snapshot type to use if source snapshot is expired.
  snapshotTypeToUseIfSourceExpired: SnapshotTypeToUseIfSourceExpired
}
# Inputs to trigger the job to restore Azure Native Virtual Machine.
input StartRestoreAzureNativeVirtualMachineJobInput {
  # Snapshot ID of the snapshot which is to be restored.
  snapshotId: UUID!

  # Specifies whether the restored VM is to be launched in powered on state. When false, the restored VM will not be connected to the internet.
  shouldPowerOn: Boolean!

  # Specifies whether the tags at the time of snapshot should also be restored. When true, the tags on the VM will be reverted to the time of the backup.
  shouldRestoreTags: Boolean!

  # Snapshot type to use if source snapshot is expired.
  snapshotTypeToUseIfSourceExpired: SnapshotTypeForRestoreIfSourceExpired

  # Specifies a list of Azure disk unique native IDs that will be restored. When empty, all disks from the snapshot will be restored.
  recoveryDiskIds: [UUID!]
}
type StartTimeAttributes {
  dayOfWeek: DayOfWeekOpt
  hour: Int!
  minute: Int!
}
# The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
scalar String
# Represents a subnet group on AWS.
type SubnetGroup {
  # Name of the subnet group.
  name: String!

  # Amazon Resource Name (ARN) of the subnet group.
  arn: String!

  # Virtual Private Cloud (VPC) corresponding to the subnet group.
  vpcId: String!

  # Subnets associated with the subnet group.
  subnets: [AwsNativeSubnet!]!
}
# Represents a tag key-value pair of an AWS resource.
type Tag {
  # Tag key.
  key: String!

  # Tag value.
  value: String!
}
# Tag filter parameters.
input TagFilterParams {
  filterType: TagFilterType = TAG_KEY
  tagKey: String = ""
  tagValue: String = ""
}
enum TagFilterType {
  # Filter by exact value of key, and all the tag values.
  TAG_KEY

  # Filter by exact values of tag key and value.
  TAG_KEY_VALUE
}
input TagInput {
  key: String!
  value: String!
}
# Key-value pair of string.
type TagObject {
  # Key of the tag or label.
  key: String!

  # Value of the tag or label.
  value: String!
}
input TagsInput {
  tagList: [TagInput!]!
}
# Target information used for archival or replication.
interface Target {
  # The cluster to which this target belongs.
  cluster: Cluster!

  # The type of this Target.
  targetType: TargetTypeEnum!

  # The ID of this Target.
  id: String!

  # The name of this Target.
  name: String!

  # The scope of location, whether Global or Local.
  locationScope: LocationScope!

  # The pause/resume status of this Target.
  isActive: Boolean!

  # Specifies whether this Target is archived.
  isArchived: Boolean!

  # Archival location to which the mapping target belongs.
  targetMapping: TargetMappingBasic

  # Name of the Rubrik cluster that archives to this archival location.
  clusterName: String

  # Status of the target.
  status: ArchivalLocationStatus!

  # Number of bytes stored on target.
  consumedBytes: Long

  # Number of running tasks acting on this target.
  runningTasks: Int

  # Number of failed tasks acting on this target.
  failedTasks: Int

  # The retrieval method of the reader target.
  readerRetrievalMethod: ReaderRetrievalMethod

  # List of archival groups to which the archival target belongs.
  targetMappingBasic: [TargetMappingBasic!]

  # Connected or Disconnected status of the target.
  locationConnectionStatus: ConnectionStatusType!
}
# Encryption type for data on AWS storage location.
enum TargetEncryptionTypeEnum {
  # Password based encryption.
  ENCRYPTION_PASSWORD_BASED

  # KMS Master Key ID based encryption.
  KMS_MASTER_KEY_BASED

  # RSA Key based encryption.
  RSA_KEY_BASED

  # Unknown encryption type.
  UNKNOWN_ENCRYPTION_TYPE
}
# Target mapping information.
type TargetMapping {
  id: UUID!
  name: String!
  groupType: ArchivalGroupTypeEnum!
  targetType: TargetTypeEnum!

  # Connection status for archival group.
  connectionStatus: ArchivalGroupConnectionStatus

  # Tiering status for archival group.
  tieringStatus: [ArchivalGroupTieringStatus!]
  targets: [Target!]
  targetTemplate: TargetTemplate
}
# Information about the target mapping identifier.
type TargetMappingBasic {
  # Id of the target mapping.
  id: UUID!

  # Name of the target mapping.
  name: String!
}
# Sync status of the archival location.
enum TargetSyncStatusEnum {
  # Location sync failed.
  ACTION_FAILED

  # Location sync failure being retried.
  ACTION_FAILED_RETRY

  # Location is not created on cluster.
  NOT_CREATED_ON_CDM

  # Reader location is being promoted to owner.
  PENDING_PROMOTE

  # Reader location is being refreshed.
  PENDING_REFRESH

  # Location is syncing with cluster.
  PENDING_SYNC

  # Location is synced with cluster.
  SYNCED
}
# Target Template to be used for automatic archival group.
interface TargetTemplate {
  # The type of this Target.
  targetType: TargetTypeEnum!
}
# Type of storage location.
enum TargetTypeEnum {
  # AWS S3 type of storage location.
  AWS

  # Azure container type of storage location.
  AZURE

  # Google Cloud Platform type of storage location.
  GOOGLE

  # Network File System type of storage location.
  NFS

  # Rubrik Cloud Vault type of storage location.
  RCS_AZURE

  # AWS S3 compatible type of storage location.
  S3_COMPATIBLE
}
# Specifies whether to use the SSO/LDAP configuration of the global organization or to use configuration specific to this organization.
enum TenantAuthDomainConfig {
  # Allows the tenant to set its own SSO/LDAP configuration.
  ALLOW_AUTH_DOMAIN_CONTROL

  # Auth domain configuration unspecified.
  AUTH_DOMAIN_UNSPECIFIED

  # Uses the global org's SSO/LDAP configuration.
  INHERIT_AUTH_DOMAIN

  # Only local users allowed.
  LOCAL_AUTH_DOMAIN_ONLY
}
# Tenant network health.
enum TenantNetworkHealth {
  # One or more tenant networks unreachable.
  CRITICAL_TENANT_NETWORK_HEALTH

  # All tenant networks are connected, but at least one or more Rubrik Envoys are disconnected.
  DEGRADED_TENANT_NETWORK_HEALTH

  # All tenant networks and all Rubrik Envoys are connected.
  HEALTHY_TENANT_NETWORK_HEALTH

  # Tenant network health unspecified.
  TENANT_NETWORK_HEALTH_UNSPECIFIED
}
input TimeRangeInput {
  # Start time of the range.
  start: DateTime!

  # End time of the range.
  end: DateTime!
}
# A time range and the unit of that range.
type TimeRangeWithUnit {
  # Time range unit.
  unit: TimeUnitEnum!

  # Time range start.
  start: DateTime!

  # Time range end.
  end: DateTime!
}
enum TimeUnitEnum {
  Day
  Hour
  Month
  Quarter
  Week
  Year
}
# TOTP status for a user.
type TotpStatus {
  # Specifies whether TOTP is enforced.
  isEnforced: Boolean!

  # Specifies whether TOTP is enforced at the user level.
  isEnforcedUserLevel: Boolean!

  # Specifies whether TOTP is enabled for the user.
  isEnabled: Boolean!

  # Specifies whether TOTP is supported for the user.
  isSupported: Boolean!

  # The timestamp of the last TOTP configuration update.
  totpConfigUpdateAt: DateTime
}
# Input to initiate Exocompute health check.
input TriggerExocomputeHealthCheckInput {
  # Cloud provider type.
  cloudVendor: CloudVendor!

  # ID for Exocompute configuration.
  exocomputeConfigId: UUID!

  # Compute instance type of the worker nodes (applicable only for Azure).
  nodeType: String
}
# Response for Exocompute health check job submission.
type TriggerExocomputeHealthCheckReply {
  # ID for the Exocompute health check job.
  healthCheckJobId: String!
}
scalar UUID
type UnidirectionalReplicationSpec {
  replicationTargetId: String!
  replicationTargetName: String!
  retention: Int!
  retentionUnit: RetentionUnitEnum!

  # The cluster to which this SLA will replicate the snapshots.
  targetCluster: Cluster
}
# Methods for unlocking a locked account.
enum UnlockMethod {
  # Account unlocked by the administrator.
  ADMINISTRATIVE_UNLOCK

  # Account unlocked automatically.
  AUTO_UNLOCK

  # Account unlocked using a self-service link.
  SELF_SERVICE

  # Account unlocked with help from Rubrik Support.
  SUPPORT_UNLOCK

  # Unspecified.
  UNLOCK_METHOD_UNSPECIFIED
}
# The types of status for unmanaged object.
enum UnmanagedObjectAvailabilityFilter {
  # Unmanaged object status is Protected.
  PROTECTED

  # Unmanaged object status is Relic.
  RELIC

  # Unmanaged object status is Remote unrotected.
  REMOTE_UNPROTECTED

  # Unmanaged object status is Repliocated relic.
  REPLICATED_RELIC

  # Unmanaged object status is unknown.
  UNMANAGED_OBJECT_UNKNOWN

  # Unmanaged object status is Unprotected.
  UNPROTECTED
}
# Input to update an AWS account.
input UpdateAwsCloudAccountFeatureInput {
  # Rubrik ID of the AWS account.
  cloudAccountId: UUID!

  # Action to be taken for cloud account update.
  action: CloudAccountAction!

  # Native protection feature to be updated.
  feature: CloudAccountFeature!

  # List of regions to be added.
  awsRegions: [AwsCloudAccountRegion!]

  # Role ARN for the cloud account.
  roleArn: String = ""

  # Stack ARN for the cloud account.
  stackArn: String = ""

  # AWS account name.
  awsAccountName: String = ""
}
# Response of the operation to update an AWS cloud account.
type UpdateAwsCloudAccountFeatureReply {
  # Contains success response message.
  message: String
}
# Input to update the AWS account.
input UpdateAwsCloudAccountInput {
  # Rubrik ID of the AWS account.
  cloudAccountId: UUID!

  # AWS account name.
  awsAccountName: String = ""
}
# Input for updating an Azure Cloud Account.
input UpdateAzureCloudAccountInput {
  # Subscriptions to be updated.
  subscriptions: [AzureCloudAccountSubscriptionInput!]!

  # Features enabled on the Azure Cloud Account.
  features: [CloudAccountFeature!]!

  # Regions to be added.
  regionsToAdd: [AzureCloudAccountRegion!]

  # Regions to be removed.
  regionsToRemove: [AzureCloudAccountRegion!]
}
# Response of the operation to Update Azure Cloud Account.
type UpdateAzureCloudAccountReply {
  # Status of the operation to update Azure Cloud Account.
  status: [UpdateAzureCloudAccountStatus!]!
}
# Status of the operation to Update Azure Cloud Account.
type UpdateAzureCloudAccountStatus {
  # Native ID of the Azure Subscription.
  azureSubscriptionNativeId: String!

  # Specifies whether the update of Azure Cloud Account was successful. When true, the update was successful.
  isSuccess: Boolean!
}
# Input for upgrading an Azure Cloud Account.
input UpgradeAzureCloudAccountInput {
  # Session ID of the current OAuth session.
  sessionId: String!

  # Features enabled on the Azure Cloud Account.
  features: [CloudAccountFeature!]!

  # Rubrik IDs of the subscriptions to be upgraded.
  azureSubscriptionRubrikIds: [UUID!]!
}
# Input for upgrading Azure Cloud Account feature to connected state from update permissions without OAuth.
input UpgradeAzureCloudAccountPermissionsWithoutOauthInput {
  # Rubrik ID of the cloud accounts to upgrade permissions.
  cloudAccountId: UUID!

  # Feature enabled on the Azure Cloud Account, which is currently in Update Permissions state.
  feature: CloudAccountFeature!
}
# Response of the operation to set Azure cloud account feature status to connected, when in update permissions state.
type UpgradeAzureCloudAccountPermissionsWithoutOauthReply {
  # Status of the request.
  status: Boolean!
}
# Response of the operation to upgrade Azure Cloud Account.
type UpgradeAzureCloudAccountReply {
  # Status of the operation to upgrade Azure Cloud Account permission.
  status: [UpgradeAzureCloudAccountStatus!]!
}
# Status of the operation to Azure Cloud Account Upgrade permission.
type UpgradeAzureCloudAccountStatus {
  # Native ID of the Azure Subscription.
  azureSubscriptionNativeId: String!

  # Specifies whether the upgrade of Azure Cloud Account was successful. When true, the upgrade was successful.
  isSuccess: Boolean!

  # Error received during upgrade of Azure Cloud Account.
  error: String!
}
type UpgradeDurationReply {
  # Time taken by the last successful rolling upgrade, in seconds.
  rollingUpgradeDuration: Long!

  # Time taken by the last successful fast upgrade, in seconds.
  fastUpgradeDuration: Long!
}
# Upgrade recommendation information.
type UpgradeRecommendationInfo {
  # Recommended version for upgrade in the same release.
  recommendation: String!

  # List of upgradable versions for the cluster.
  upgradability: [String!]!

  # Latest upgradable version from the next release.
  nextReleaseRecommendation: String!
}
# User account details.
type User {
  # The user ID.
  id: String!

  # The user's email address.
  email: String!

  # The domain the user belongs to.
  domain: UserDomainEnum!

  # The last time the user logged in.
  lastLogin: DateTime

  # The status of the user account.
  status: UserStatusEnum!

  # The groups that the user belongs to.
  groups: [String!]!

  # The TOTP status of user.
  totpStatus: TotpStatus!

  # The user account lockout information.
  lockoutState: LockoutState!

  # Specifies whether user is an account owner.
  isAccountOwner: Boolean!

  # The user's username.
  username: String!

  # The number of unread notifications for the current user.
  unreadCount: Long!
  roles: [Role!]!
  emailConfig: [EventDigest!]!
}
enum UserDomainEnum {
  CLIENT
  LDAP
  LOCAL
  SHARED_SSO
  SSO
}
enum UserStatusEnum {
  ACTIVE
  DEACTIVATED
  UNKNOWN
}
# Input to validate and set up an AWS account.
input ValidateAndCreateAwsCloudAccountInput {
  # Action to be performed with the cloud account.
  action: CloudAccountAction!

  # List of features to be enabled for cloud native protection.
  features: [CloudAccountFeature!]!

  # Admin account, required for bulk upload.
  awsAdminAccount: AwsCloudAccountInput

  # Details for cloud accounts to be initiated.
  awsChildAccounts: [AwsCloudAccountInput!]!
}
# Aws cloud accounts validate response.
type ValidateAndCreateAwsCloudAccountReply {
  # Error messages related to the failure of the request to create an AWS cloud account.
  validateResponse: AwsCloudAccountValidateResponse

  # AWS cloud account initiate response if the request is successful.
  initiateResponse: AwsCloudAccountCreateResponse
}
# Validate AWS RDS Instance name for export.
type ValidateAwsNativeRdsInstanceNameForExportReply {
  # Specifies whether the RDS name is valid or not.
  isValid: Boolean!

  # Refers to the reason for the RDS name being invalid.
  error: String!
}
# Input for validating Exocompute configurations for an Azure Cloud Account.
input ValidateAzureCloudAccountExocomputeConfigurationsInput {
  # Rubrik ID of the Azure Cloud Account.
  cloudAccountId: UUID!

  # List of Exocompute configurations to be validated.
  azureExocomputeRegionConfigs: [AzureExocomputeAddConfigInputType!]!
}
# Response of the operation to validate Azure Cloud Account Exocompute Configurations.
type ValidateAzureSubnetsForCloudAccountExocomputeReply {
  # List of validation information on Azure Exocompute Configurations provided.
  validationInfo: [AzureExocomputeConfigValidationInfo!]!
}
enum VersionStatusTypeEnum {
  Stable
  Unknown
  UpgradeRecommended
}
# Vm Application Consistency Specs Info
type VmAppConsistentSpecsInternal {
  # Path for the script to be run before taking snapshot.
  preSnapshotScriptPath: String!

  # Timeout value in seconds for the pre snapshot script.
  preScriptTimeoutInSeconds: Int!

  # Path for the script to be run after taking snapshot.
  postSnapshotScriptPath: String!

  # Pre-snapshot script timeout in seconds.
  postScriptTimeoutInSeconds: Int!

  # Specifies whether to cancel backup if the pre-snapshot script fails.
  cancelBackupIfPreScriptFails: Boolean!

  # Rubrik Backup Service status.
  rbaStatus: CloudNativeRbaStatusType!
}
type VmwareVmConfig {
  logRetentionSeconds: Long!
}
# No value is returned.
scalar Void
# Exclusion status of AWS EBS volumes.
input VolumeIdExclusion {
  # ID of the AWS EBS volume.
  volumeId: String!

  # Specfies whether the EBS volume is excluded from snapshot.
  isExcluded: Boolean!
}
type WeeklySnapshotSchedule {
  basicSchedule: BasicSnapshotSchedule
  dayOfWeek: DayOfWeek!
}
type YearlySnapshotSchedule {
  basicSchedule: BasicSnapshotSchedule
  dayOfYear: DayOfYear!
  yearStartMonth: Month!
}
type clusterState {
  # Connected status of the Rubrik CDM cluster.
  connectedState: ClusterStatus!

  # The removal status of the Rubrik CDM cluster.
  clusterRemovalState: ClusterRemovalState!

  # Cluster removal job creation time.
  clusterRemovalCreatedAt: DateTime

  # Cluster removal job update time.
  clusterRemovalUpdatedAt: DateTime
}
# Cluster metric data grouped by a time unit.
type metricTimeSeries {
  # The time groupby info.
  timeInfo: ClusterMetricGroupByInfo!

  # The Rubrik cluster metric data for the specified time period.
  metric: ClusterMetric!
}
